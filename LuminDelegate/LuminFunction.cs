// <auto-generated>
//     This code was generated by a T4 template.
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>

using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;

using static LuminDelegates.LuminDelegate;

#nullable enable
namespace LuminDelegates;


public unsafe struct LuminFunction<
#if NET8_0_OR_GREATER
[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)]
#endif
TTarget, TResult> : IDisposable, ICloneable, ISerializable, IEquatable<LuminFunction<TTarget, TResult>>
#if NET9_0_OR_GREATER
    where TTarget : allows ref struct
    where TResult : allows ref struct
#endif
{
    private void* _targetPointer; // 值类型对象
    private object? _referenceTarget; // 引用类型对象
    private readonly IntPtr _methodPtr;
    private readonly bool _isStatic;
    private readonly MethodInfo _method;
    private bool _disposed;

    private static readonly bool IsValueType = typeof(TTarget).IsValueType;
    
    public TTarget? Target
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            ThrowIfDisposed();
            
            if (_isStatic)
                return default;
            
            if (IsValueType)
                return Unsafe.AsRef<TTarget?>(_targetPointer);
            
            var target = _referenceTarget;
            return Unsafe.As<object?, TTarget?>(ref target);
        }
    }
    
    public MethodInfo Method => _method;

    #region Constructors
    
    private LuminFunction(MethodCache method)
    {
        _method = method.MethodBase ?? throw new ArgumentNullException(nameof(method));
        _isStatic = method.IsStatic;
        _methodPtr = method.MethodPtr;

        if (!_isStatic)
            throw new ArgumentException("methods are not static!", method.MethodBase.Name);
        
        _referenceTarget = null;
        _targetPointer = null;
    }
    
    private LuminFunction(scoped ref TTarget? target, MethodCache method)
    {
        _method = method.MethodBase ?? throw new ArgumentNullException(nameof(method));
        _isStatic = method.IsStatic;
        _methodPtr = method.MethodPtr;
        _referenceTarget = null;

        if (!_isStatic)
        {
            if (IsValueType)
            {
#if NET8_0_OR_GREATER
                if (Unsafe.IsNullRef(ref target))
                    throw new ArgumentException("Target value instance cannot be null.", nameof(target));
#endif                

#if NET8_0_OR_GREATER
                _targetPointer = NativeMemory.Alloc((nuint)Unsafe.SizeOf<TTarget>());
#else
                _targetPointer = Marshal.AllocHGlobal(Unsafe.SizeOf<TTarget>()).ToPointer();
#endif
                Unsafe.CopyBlock(
                    _targetPointer,
                    Unsafe.AsPointer(ref target),
                    (uint)Unsafe.SizeOf<TTarget>()
                );
            }
            else
            {
                if (target is null)
                    throw new ArgumentException("Target instance object is null.", nameof(target));
                
                _referenceTarget = Unsafe.As<TTarget, object?>(ref target);
                
            }
        }
        else
        {
            _targetPointer = null;
        }
    }
    
    private LuminFunction(Delegate @delegate)
    {
        _method = @delegate.Method ?? throw new ArgumentNullException(nameof(@delegate.Method));
        _isStatic = @delegate.Method.IsStatic;
        _methodPtr = @delegate.Method.MethodHandle.GetFunctionPointer();
        _referenceTarget = null;
        
        var target = @delegate.Target;
        if (!_isStatic)
        {
            if (target is not TTarget)
                throw new ArgumentException("Target instance object is not type.", typeof(TTarget).Name);
                
            if (IsValueType)
            {
#if NET8_0_OR_GREATER
                if (Unsafe.IsNullRef(ref target))
                    throw new ArgumentException("Target value instance cannot be null.", nameof(target));
#endif
                
                var unboxedTarget = Unsafe.AsRef<TTarget>(Unsafe.AsPointer(ref target));
                
#if NET8_0_OR_GREATER
                _targetPointer = NativeMemory.Alloc((nuint)Unsafe.SizeOf<TTarget>());
#else
                _targetPointer = Marshal.AllocHGlobal(Unsafe.SizeOf<TTarget>()).ToPointer();
#endif
                Unsafe.CopyBlock(
                    _targetPointer,
                    Unsafe.AsPointer(ref unboxedTarget),
                    (uint)Unsafe.SizeOf<TTarget>()
                );
            }
            else
            {
                if (target is null)
                    throw new ArgumentException("Target instance object is null.", nameof(target));
                
                _referenceTarget = target;
            }
        }
        else
        {
            _targetPointer = null;
        }
    }

    #endregion
    
    #region Create Factory

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, TResult> Create(scoped ref TTarget? target, string methodName, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(IsValueType
                ? TargetTypeHandle
                : Unsafe.As<TTarget, object?>(ref target!)?.GetType().TypeHandle ?? TargetTypeHandle,
            methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        return new LuminFunction<TTarget, TResult>(ref target, method);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, TResult> Create(scoped ref TTarget? target, string methodName, Type targetType, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(targetType.TypeHandle, methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        return new LuminFunction<TTarget, TResult>(ref target, method);
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, TResult> Create(scoped ref TTarget? target, ReadOnlySpan<char> methodName, int methodNameHash = 0) =>
        Create(ref target, methodName.ToString(), methodNameHash);
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, TResult> Create(scoped ref TTarget? target, ReadOnlySpan<char> methodName, Type targetType, int methodNameHash = 0) =>
        Create(ref target, methodName.ToString(), targetType, methodNameHash);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, TResult> Create(Delegate @delegate) => 
        new LuminFunction<TTarget, TResult>(@delegate);
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, TResult> Create(string methodName, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(TargetTypeHandle, methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        if (!method.IsStatic)
            throw new ArgumentException("Method is not static, please pass in instance as parameter.", nameof(methodName));
        
        return new LuminFunction<TTarget, TResult>(method);
    }

    #endregion
    
    #region Interface Implementation

    public void Dispose()
    {
        if (_disposed)
            return;
        
        
        if (IsValueType && !_isStatic && _targetPointer != null)
        {
#if NET8_0_OR_GREATER
            NativeMemory.Free(_targetPointer);
#else
            Marshal.FreeHGlobal(new IntPtr(_targetPointer));
#endif
        }
       
        _targetPointer = null;
        _referenceTarget = null;

        _disposed = true;
    }
    
    public object Clone()
    {
        ThrowIfDisposed();
        var target = _referenceTarget;
        if (target is null)
            throw new NullReferenceException("Target instance cannot be null.");
                
        return new LuminFunction<TTarget, TResult>(ref Unsafe.As<object?, TTarget>(ref target)!, new MethodCache(_isStatic, _methodPtr, _method));
    }

    public void GetObjectData(SerializationInfo info, StreamingContext context)
    {
        throw new NotSupportedException();
    }
    
    public override bool Equals(object? obj)
    {
        return obj is LuminFunction<TTarget, TResult> other && Equals(other);
    }

    public bool Equals(LuminFunction<TTarget, TResult> other)
    {
        ThrowIfDisposed();
        return _methodPtr == other._methodPtr &&
               _isStatic == other._isStatic &&
               _targetPointer == other._targetPointer;
    }

    public override int GetHashCode()
    {
        ThrowIfDisposed();
        unchecked
        {
            int hash = 17;
            hash = hash * 31 + _methodPtr.GetHashCode();
            hash = hash * 31 + _isStatic.GetHashCode();
            hash = hash * 31 + ((IntPtr)_targetPointer).GetHashCode();
            return hash;
        }
    }

    #endregion
    
    #region Implicit
    
    public static implicit operator LuminFunction<TTarget, TResult>(in Delegate func) 
        => Create(func);

    public static implicit operator LuminFunction<TTarget, TResult>(Func<TResult> func) => 
        Create(func);
    
    #endregion

    #region Invoke

    public object? DynamicInvoke(params object?[] args)
    {
        ThrowIfDisposed();
        
        if (_isStatic)
        {
            return _method.Invoke(null, args);
        }
        else
        {
            if (typeof(TTarget).IsByRefLike)
                throw new ArgumentException(
                    "The target type is a by-ref-like type and cannot be converted to a delegate.");

#if !NET9_0_OR_GREATER
            if (IsValueType)
                throw new ArgumentException("The target type is value type and cannot dynamic invoke.");
#endif

#if NET9_0_OR_GREATER
            object? instance = IsValueType
                ? RuntimeHelpers.Box(ref Unsafe.AsRef<byte>(_targetPointer), typeof(TTarget).TypeHandle)
                : _referenceTarget;
#else
            object? instance = _referenceTarget;
#endif

            if (instance is null)
                throw new InvalidOperationException("Target instance is null.");

            return _method.Invoke(instance, args);
        }
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public TResult Invoke()
    {
        ThrowIfDisposed();

        if (!_isStatic && !IsValueType)
            return ((delegate* managed<TTarget, TResult>)_methodPtr)(Unsafe.As<object?, TTarget>(ref _referenceTarget));
        else if (IsValueType)
            return ((delegate* managed<ref TTarget, TResult>)_methodPtr)(ref Unsafe.AsRef<TTarget>(_targetPointer));
        else
            return ((delegate* managed<TResult>)_methodPtr)();
    }

    #endregion
    
    #region Auxiliary methods
    
    public TDelegate ToDelegate<TDelegate>()
        where TDelegate : Delegate
    {
        ThrowIfDisposed();
        if (_isStatic)
        {
            return (TDelegate)Delegate.CreateDelegate(typeof(TDelegate), _method);
        }
        else
        {
            if (typeof(TTarget).IsByRefLike)
                throw new ArgumentException("The target type is a by-ref-like type and cannot be converted to a delegate.");
            
#if !NET9_0_OR_GREATER
            if (IsValueType)
                throw new ArgumentException("The target type is value type and cannot be converted to a delegate.");
#endif

#if NET9_0_OR_GREATER
            object? instance = IsValueType 
                ? RuntimeHelpers.Box(ref Unsafe.AsRef<byte>(_targetPointer), typeof(TTarget).TypeHandle)
                : _referenceTarget;
#else
            object? instance = _referenceTarget;
#endif
            
            if (instance is null)
                throw new InvalidOperationException("Target instance is null.");
            
            return (TDelegate)Delegate.CreateDelegate(typeof(TDelegate), instance, _method);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void ThrowIfDisposed()
    {
        if (_disposed)
            throw new ObjectDisposedException(nameof(LuminFunction<TTarget, TResult>));
    }
    
    #endregion
    
    #region Static Type Hash

    private static readonly int TypeHash = ComputeTypeHash();
    private static readonly int TargetTypeHash = TargetTypeHandle.GetHashCode();
    private static readonly RuntimeTypeHandle TargetTypeHandle = typeof(TTarget).TypeHandle;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static int ComputeTypeHash()
    {
        unchecked
        {
            int h = (int)2166136261;
            h = (h * 16777619) ^ typeof(TResult).TypeHandle.GetHashCode();
            return h;
        }
    }

    #endregion

    #region Method Caching

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static MethodCache GetCachedMethod(scoped in RuntimeTypeHandle type, string methodName, int nameHash = 0)
    {
        nameHash = nameHash is 0 ? StringComparer.Ordinal.GetHashCode(methodName) : nameHash;
        int key = type.Equals(TargetTypeHandle)
                      ? TypeHash ^ nameHash ^ TargetTypeHash
                      : TypeHash ^ nameHash ^ type.GetHashCode();
       
        if (!Methods.TryGetValue(key, out var result))
        {
            const BindingFlags flags = BindingFlags.Public | BindingFlags.NonPublic |
                                       BindingFlags.Instance | BindingFlags.Static;
    
            Type[] paramTypes = Type.EmptyTypes;

#if NET8_0_OR_GREATER
            var method = Type.GetTypeFromHandle(type)!.GetMethod(methodName, flags, paramTypes)
                         ?? throw new MissingMethodException($"Method {methodName} not found on {Type.GetTypeFromHandle(type)!}");
#else
            var method = Type.GetTypeFromHandle(type)!.GetMethod(methodName, flags, null, paramTypes, null)
                         ?? throw new MissingMethodException($"Method {methodName} not found on {Type.GetTypeFromHandle(type)!}");
#endif
            result = new MethodCache(method.IsStatic, method.MethodHandle.GetFunctionPointer(), method);

            Methods.TryAdd(key, result);
        }

        return result;
    }
    
    #endregion
}

public unsafe struct LuminFunction<
#if NET8_0_OR_GREATER
[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)]
#endif
TTarget, T1, TResult> : IDisposable, ICloneable, ISerializable, IEquatable<LuminFunction<TTarget, T1, TResult>>
#if NET9_0_OR_GREATER
    where TTarget : allows ref struct
    where TResult : allows ref struct
    where T1 : allows ref struct
#endif
{
    private void* _targetPointer; 
    private object? _referenceTarget; 
    private readonly IntPtr _methodPtr;
    private readonly bool _isStatic;
    private readonly MethodInfo _method;
    private bool _disposed;

    private static readonly bool IsValueType = typeof(TTarget).IsValueType;
    
    public TTarget? Target
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            ThrowIfDisposed();
            
            if (_isStatic)
                return default;
            
            if (IsValueType)
                return Unsafe.AsRef<TTarget?>(_targetPointer);
            
            var target = _referenceTarget;
            return Unsafe.As<object?, TTarget?>(ref target);
        }
    }
    
    public MethodInfo Method => _method;

    #region Constructors
    
    private LuminFunction(MethodCache method)
    {
        _method = method.MethodBase ?? throw new ArgumentNullException(nameof(method));
        _isStatic = method.IsStatic;
        _methodPtr = method.MethodPtr;

        if (!_isStatic)
            throw new ArgumentException("methods are not static!", method.MethodBase.Name);
        
        _referenceTarget = null;
        _targetPointer = null;
    }
    
    private LuminFunction(scoped ref TTarget? target, MethodCache method)
    {
        _method = method.MethodBase ?? throw new ArgumentNullException(nameof(method));
        _isStatic = method.IsStatic;
        _methodPtr = method.MethodPtr;
        _referenceTarget = null;

        if (!_isStatic)
        {
            if (IsValueType)
            {
#if NET8_0_OR_GREATER
                if (Unsafe.IsNullRef(ref target))
                    throw new ArgumentException("Target value instance cannot be null.", nameof(target));
#endif                

#if NET8_0_OR_GREATER
                _targetPointer = NativeMemory.Alloc((nuint)Unsafe.SizeOf<TTarget>());
#else
                _targetPointer = Marshal.AllocHGlobal(Unsafe.SizeOf<TTarget>()).ToPointer();
#endif
                Unsafe.CopyBlock(
                    _targetPointer,
                    Unsafe.AsPointer(ref target),
                    (uint)Unsafe.SizeOf<TTarget>()
                );
            }
            else
            {
                if (target is null)
                    throw new ArgumentException("Target instance object is null.", nameof(target));
                
                _referenceTarget = Unsafe.As<TTarget, object?>(ref target);
                
            }
        }
        else
        {
            _targetPointer = null;
        }
    }
    
    private LuminFunction(Delegate @delegate)
    {
        _method = @delegate.Method ?? throw new ArgumentNullException(nameof(@delegate.Method));
        _isStatic = @delegate.Method.IsStatic;
        _methodPtr = @delegate.Method.MethodHandle.GetFunctionPointer();
        _referenceTarget = null;
        
        var target = @delegate.Target;
        if (!_isStatic)
        {
            if (target is not TTarget)
                throw new ArgumentException("Target instance object is not type.", typeof(TTarget).Name);
                
            if (IsValueType)
            {
#if NET8_0_OR_GREATER
                if (Unsafe.IsNullRef(ref target))
                    throw new ArgumentException("Target value instance cannot be null.", nameof(target));
#endif
                
                var unboxedTarget = Unsafe.AsRef<TTarget>(Unsafe.AsPointer(ref target));
                
#if NET8_0_OR_GREATER
                _targetPointer = NativeMemory.Alloc((nuint)Unsafe.SizeOf<TTarget>());
#else
                _targetPointer = Marshal.AllocHGlobal(Unsafe.SizeOf<TTarget>()).ToPointer();
#endif
                Unsafe.CopyBlock(
                    _targetPointer,
                    Unsafe.AsPointer(ref unboxedTarget),
                    (uint)Unsafe.SizeOf<TTarget>()
                );
            }
            else
            {
                if (target is null)
                    throw new ArgumentException("Target instance object is null.", nameof(target));
                
                _referenceTarget = target;
            }
        }
        else
        {
            _targetPointer = null;
        }
    }

    #endregion
    
    #region Create Factory

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, TResult> Create(scoped ref TTarget? target, string methodName, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(IsValueType
                ? TargetTypeHandle
                : Unsafe.As<TTarget, object?>(ref target!)?.GetType().TypeHandle ?? TargetTypeHandle,
            methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        return new LuminFunction<TTarget, T1, TResult>(ref target, method);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, TResult> Create(scoped ref TTarget? target, string methodName, Type targetType, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(targetType.TypeHandle, methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        return new LuminFunction<TTarget, T1, TResult>(ref target, method);
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, TResult> Create(scoped ref TTarget? target, ReadOnlySpan<char> methodName, int methodNameHash = 0) =>
        Create(ref target, methodName.ToString(), methodNameHash);
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, TResult> Create(scoped ref TTarget? target, ReadOnlySpan<char> methodName, Type targetType, int methodNameHash = 0) =>
        Create(ref target, methodName.ToString(), targetType, methodNameHash);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, TResult> Create(Delegate @delegate) => 
        new LuminFunction<TTarget, T1, TResult>(@delegate);
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, TResult> Create(string methodName, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(TargetTypeHandle, methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        if (!method.IsStatic)
            throw new ArgumentException("Method is not static, please pass in instance as parameter.", nameof(methodName));
        
        return new LuminFunction<TTarget, T1, TResult>(method);
    }

    #endregion
    
    #region Interface Implementation

    public void Dispose()
    {
        if (_disposed)
            return;
        
        
        if (IsValueType && !_isStatic && _targetPointer != null)
        {
#if NET8_0_OR_GREATER
            NativeMemory.Free(_targetPointer);
#else
            Marshal.FreeHGlobal(new IntPtr(_targetPointer));
#endif
        }
       
        _targetPointer = null;
        _referenceTarget = null;

        _disposed = true;
    }
    
    public object Clone()
    {
        ThrowIfDisposed();
        var target = _referenceTarget;
        if (target is null)
            throw new NullReferenceException("Target instance cannot be null.");
                
        return new LuminFunction<TTarget, T1, TResult>(ref Unsafe.As<object?, TTarget>(ref target)!, new MethodCache(_isStatic, _methodPtr, _method));
    }

    public void GetObjectData(SerializationInfo info, StreamingContext context)
    {
        throw new NotSupportedException();
    }
    
    public override bool Equals(object? obj)
    {
        return obj is LuminFunction<TTarget, T1, TResult> other && Equals(other);
    }

    public bool Equals(LuminFunction<TTarget, T1, TResult> other)
    {
        ThrowIfDisposed();
        return _methodPtr == other._methodPtr &&
               _isStatic == other._isStatic &&
               _targetPointer == other._targetPointer;
    }

    public override int GetHashCode()
    {
        ThrowIfDisposed();
        unchecked
        {
            int hash = 17;
            hash = hash * 31 + _methodPtr.GetHashCode();
            hash = hash * 31 + _isStatic.GetHashCode();
            hash = hash * 31 + ((IntPtr)_targetPointer).GetHashCode();
            return hash;
        }
    }

    #endregion
    
    #region Implicit
    
    public static implicit operator LuminFunction<TTarget, T1, TResult>(in Delegate func) 
        => Create(func);

    public static implicit operator LuminFunction<TTarget, T1, TResult>(Func<T1, TResult> func) => 
        Create(func);
    
    #endregion

    #region Invoke

    public object? DynamicInvoke(params object?[] args)
    {
        ThrowIfDisposed();
        
        if (_isStatic)
        {
            return _method.Invoke(null, args);
        }
        else
        {
            if (typeof(TTarget).IsByRefLike)
                throw new ArgumentException(
                    "The target type is a by-ref-like type and cannot be converted to a delegate.");

#if !NET9_0_OR_GREATER
            if (IsValueType)
                throw new ArgumentException("The target type is value type and cannot dynamic invoke.");
#endif

#if NET9_0_OR_GREATER
            object? instance = IsValueType
                ? RuntimeHelpers.Box(ref Unsafe.AsRef<byte>(_targetPointer), typeof(TTarget).TypeHandle)
                : _referenceTarget;
#else
            object? instance = _referenceTarget;
#endif

            if (instance is null)
                throw new InvalidOperationException("Target instance is null.");

            return _method.Invoke(instance, args);
        }
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public TResult Invoke(T1 arg1)
    {
        ThrowIfDisposed();

        if (!_isStatic && !IsValueType)
            return ((delegate* managed<TTarget, T1, TResult>)_methodPtr)(Unsafe.As<object?, TTarget>(ref _referenceTarget), arg1);
        else if (IsValueType)
            return ((delegate* managed<ref TTarget, T1, TResult>)_methodPtr)(ref Unsafe.AsRef<TTarget>(_targetPointer), arg1);
        else
            return ((delegate* managed<T1, TResult>)_methodPtr)(arg1);
    }

    #endregion
    
    #region Auxiliary methods
    
    public TDelegate ToDelegate<TDelegate>()
        where TDelegate : Delegate
    {
        ThrowIfDisposed();
        if (_isStatic)
        {
            return (TDelegate)Delegate.CreateDelegate(typeof(TDelegate), _method);
        }
        else
        {
            if (typeof(TTarget).IsByRefLike)
                throw new ArgumentException("The target type is a by-ref-like type and cannot be converted to a delegate.");
            
#if !NET9_0_OR_GREATER
            if (IsValueType)
                throw new ArgumentException("The target type is value type and cannot be converted to a delegate.");
#endif

#if NET9_0_OR_GREATER
            object? instance = IsValueType 
                ? RuntimeHelpers.Box(ref Unsafe.AsRef<byte>(_targetPointer), typeof(TTarget).TypeHandle)
                : _referenceTarget;
#else
            object? instance = _referenceTarget;
#endif
            
            if (instance is null)
                throw new InvalidOperationException("Target instance is null.");
            
            return (TDelegate)Delegate.CreateDelegate(typeof(TDelegate), instance, _method);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void ThrowIfDisposed()
    {
        if (_disposed)
            throw new ObjectDisposedException(nameof(LuminFunction<TTarget, T1, TResult>));
    }
    
    #endregion
    
    #region Static Type Hash

    private static readonly int TypeHash = ComputeTypeHash();
    private static readonly int TargetTypeHash = TargetTypeHandle.GetHashCode();
    private static readonly RuntimeTypeHandle TargetTypeHandle = typeof(TTarget).TypeHandle;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static int ComputeTypeHash()
    {
        unchecked
        {
            int h = (int)2166136261;
            h = (h * 16777619) ^ typeof(TResult).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T1).TypeHandle.GetHashCode();
            return h;
        }
    }

    #endregion

    #region Method Caching

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static MethodCache GetCachedMethod(scoped in RuntimeTypeHandle type, string methodName, int nameHash = 0)
    {
        nameHash = nameHash is 0 ? StringComparer.Ordinal.GetHashCode(methodName) : nameHash;
        int key = type.Equals(TargetTypeHandle)
                      ? TypeHash ^ nameHash ^ TargetTypeHash
                      : TypeHash ^ nameHash ^ type.GetHashCode();
       
        if (!Methods.TryGetValue(key, out var result))
        {
            const BindingFlags flags = BindingFlags.Public | BindingFlags.NonPublic |
                                       BindingFlags.Instance | BindingFlags.Static;
    
            Type[] paramTypes = [ typeof(T1) ];

#if NET8_0_OR_GREATER
            var method = Type.GetTypeFromHandle(type)!.GetMethod(methodName, flags, paramTypes)
                         ?? throw new MissingMethodException($"Method {methodName} not found on {Type.GetTypeFromHandle(type)!}");
#else
            var method = Type.GetTypeFromHandle(type)!.GetMethod(methodName, flags, null, paramTypes, null)
                         ?? throw new MissingMethodException($"Method {methodName} not found on {Type.GetTypeFromHandle(type)!}");
#endif
            result = new MethodCache(method.IsStatic, method.MethodHandle.GetFunctionPointer(), method);

            Methods.TryAdd(key, result);
        }

        return result;
    }
    
    #endregion
}

public unsafe struct LuminFunction<
#if NET8_0_OR_GREATER
[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)]
#endif
TTarget, T1, T2, TResult> : IDisposable, ICloneable, ISerializable, IEquatable<LuminFunction<TTarget, T1, T2, TResult>>
#if NET9_0_OR_GREATER
    where TTarget : allows ref struct
    where TResult : allows ref struct
    where T1 : allows ref struct
    where T2 : allows ref struct
#endif
{
    private void* _targetPointer; 
    private object? _referenceTarget; 
    private readonly IntPtr _methodPtr;
    private readonly bool _isStatic;
    private readonly MethodInfo _method;
    private bool _disposed;

    private static readonly bool IsValueType = typeof(TTarget).IsValueType;
    
    public TTarget? Target
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            ThrowIfDisposed();
            
            if (_isStatic)
                return default;
            
            if (IsValueType)
                return Unsafe.AsRef<TTarget?>(_targetPointer);
            
            var target = _referenceTarget;
            return Unsafe.As<object?, TTarget?>(ref target);
        }
    }
    
    public MethodInfo Method => _method;

    #region Constructors
    
    private LuminFunction(MethodCache method)
    {
        _method = method.MethodBase ?? throw new ArgumentNullException(nameof(method));
        _isStatic = method.IsStatic;
        _methodPtr = method.MethodPtr;

        if (!_isStatic)
            throw new ArgumentException("methods are not static!", method.MethodBase.Name);
        
        _referenceTarget = null;
        _targetPointer = null;
    }
    
    private LuminFunction(scoped ref TTarget? target, MethodCache method)
    {
        _method = method.MethodBase ?? throw new ArgumentNullException(nameof(method));
        _isStatic = method.IsStatic;
        _methodPtr = method.MethodPtr;
        _referenceTarget = null;

        if (!_isStatic)
        {
            if (IsValueType)
            {
#if NET8_0_OR_GREATER
                if (Unsafe.IsNullRef(ref target))
                    throw new ArgumentException("Target value instance cannot be null.", nameof(target));
#endif                

#if NET8_0_OR_GREATER
                _targetPointer = NativeMemory.Alloc((nuint)Unsafe.SizeOf<TTarget>());
#else
                _targetPointer = Marshal.AllocHGlobal(Unsafe.SizeOf<TTarget>()).ToPointer();
#endif
                Unsafe.CopyBlock(
                    _targetPointer,
                    Unsafe.AsPointer(ref target),
                    (uint)Unsafe.SizeOf<TTarget>()
                );
            }
            else
            {
                if (target is null)
                    throw new ArgumentException("Target instance object is null.", nameof(target));
                
                _referenceTarget = Unsafe.As<TTarget, object?>(ref target);
                
            }
        }
        else
        {
            _targetPointer = null;
        }
    }
    
    private LuminFunction(Delegate @delegate)
    {
        _method = @delegate.Method ?? throw new ArgumentNullException(nameof(@delegate.Method));
        _isStatic = @delegate.Method.IsStatic;
        _methodPtr = @delegate.Method.MethodHandle.GetFunctionPointer();
        _referenceTarget = null;
        
        var target = @delegate.Target;
        if (!_isStatic)
        {
            if (target is not TTarget)
                throw new ArgumentException("Target instance object is not type.", typeof(TTarget).Name);
                
            if (IsValueType)
            {
#if NET8_0_OR_GREATER
                if (Unsafe.IsNullRef(ref target))
                    throw new ArgumentException("Target value instance cannot be null.", nameof(target));
#endif
                
                var unboxedTarget = Unsafe.AsRef<TTarget>(Unsafe.AsPointer(ref target));
                
#if NET8_0_OR_GREATER
                _targetPointer = NativeMemory.Alloc((nuint)Unsafe.SizeOf<TTarget>());
#else
                _targetPointer = Marshal.AllocHGlobal(Unsafe.SizeOf<TTarget>()).ToPointer();
#endif
                Unsafe.CopyBlock(
                    _targetPointer,
                    Unsafe.AsPointer(ref unboxedTarget),
                    (uint)Unsafe.SizeOf<TTarget>()
                );
            }
            else
            {
                if (target is null)
                    throw new ArgumentException("Target instance object is null.", nameof(target));
                
                _referenceTarget = target;
            }
        }
        else
        {
            _targetPointer = null;
        }
    }

    #endregion
    
    #region Create Factory

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, TResult> Create(scoped ref TTarget? target, string methodName, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(IsValueType
                ? TargetTypeHandle
                : Unsafe.As<TTarget, object?>(ref target!)?.GetType().TypeHandle ?? TargetTypeHandle,
            methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        return new LuminFunction<TTarget, T1, T2, TResult>(ref target, method);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, TResult> Create(scoped ref TTarget? target, string methodName, Type targetType, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(targetType.TypeHandle, methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        return new LuminFunction<TTarget, T1, T2, TResult>(ref target, method);
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, TResult> Create(scoped ref TTarget? target, ReadOnlySpan<char> methodName, int methodNameHash = 0) =>
        Create(ref target, methodName.ToString(), methodNameHash);
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, TResult> Create(scoped ref TTarget? target, ReadOnlySpan<char> methodName, Type targetType, int methodNameHash = 0) =>
        Create(ref target, methodName.ToString(), targetType, methodNameHash);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, TResult> Create(Delegate @delegate) => 
        new LuminFunction<TTarget, T1, T2, TResult>(@delegate);
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, TResult> Create(string methodName, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(TargetTypeHandle, methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        if (!method.IsStatic)
            throw new ArgumentException("Method is not static, please pass in instance as parameter.", nameof(methodName));
        
        return new LuminFunction<TTarget, T1, T2, TResult>(method);
    }

    #endregion
    
    #region Interface Implementation

    public void Dispose()
    {
        if (_disposed)
            return;
        
        
        if (IsValueType && !_isStatic && _targetPointer != null)
        {
#if NET8_0_OR_GREATER
            NativeMemory.Free(_targetPointer);
#else
            Marshal.FreeHGlobal(new IntPtr(_targetPointer));
#endif
        }
       
        _targetPointer = null;
        _referenceTarget = null;

        _disposed = true;
    }
    
    public object Clone()
    {
        ThrowIfDisposed();
        var target = _referenceTarget;
        if (target is null)
            throw new NullReferenceException("Target instance cannot be null.");
                
        return new LuminFunction<TTarget, T1, T2, TResult>(ref Unsafe.As<object?, TTarget>(ref target)!, new MethodCache(_isStatic, _methodPtr, _method));
    }

    public void GetObjectData(SerializationInfo info, StreamingContext context)
    {
        throw new NotSupportedException();
    }
    
    public override bool Equals(object? obj)
    {
        return obj is LuminFunction<TTarget, T1, T2, TResult> other && Equals(other);
    }

    public bool Equals(LuminFunction<TTarget, T1, T2, TResult> other)
    {
        ThrowIfDisposed();
        return _methodPtr == other._methodPtr &&
               _isStatic == other._isStatic &&
               _targetPointer == other._targetPointer;
    }

    public override int GetHashCode()
    {
        ThrowIfDisposed();
        unchecked
        {
            int hash = 17;
            hash = hash * 31 + _methodPtr.GetHashCode();
            hash = hash * 31 + _isStatic.GetHashCode();
            hash = hash * 31 + ((IntPtr)_targetPointer).GetHashCode();
            return hash;
        }
    }

    #endregion
    
    #region Implicit
    
    public static implicit operator LuminFunction<TTarget, T1, T2, TResult>(in Delegate func) 
        => Create(func);

    public static implicit operator LuminFunction<TTarget, T1, T2, TResult>(Func<T1, T2, TResult> func) => 
        Create(func);
    
    #endregion

    #region Invoke

    public object? DynamicInvoke(params object?[] args)
    {
        ThrowIfDisposed();
        
        if (_isStatic)
        {
            return _method.Invoke(null, args);
        }
        else
        {
            if (typeof(TTarget).IsByRefLike)
                throw new ArgumentException(
                    "The target type is a by-ref-like type and cannot be converted to a delegate.");

#if !NET9_0_OR_GREATER
            if (IsValueType)
                throw new ArgumentException("The target type is value type and cannot dynamic invoke.");
#endif

#if NET9_0_OR_GREATER
            object? instance = IsValueType
                ? RuntimeHelpers.Box(ref Unsafe.AsRef<byte>(_targetPointer), typeof(TTarget).TypeHandle)
                : _referenceTarget;
#else
            object? instance = _referenceTarget;
#endif

            if (instance is null)
                throw new InvalidOperationException("Target instance is null.");

            return _method.Invoke(instance, args);
        }
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public TResult Invoke(T1 arg1, T2 arg2)
    {
        ThrowIfDisposed();

        if (!_isStatic && !IsValueType)
            return ((delegate* managed<TTarget, T1, T2, TResult>)_methodPtr)(Unsafe.As<object?, TTarget>(ref _referenceTarget), arg1, arg2);
        else if (IsValueType)
            return ((delegate* managed<ref TTarget, T1, T2, TResult>)_methodPtr)(ref Unsafe.AsRef<TTarget>(_targetPointer), arg1, arg2);
        else
            return ((delegate* managed<T1, T2, TResult>)_methodPtr)(arg1, arg2);
    }

    #endregion
    
    #region Auxiliary methods
    
    public TDelegate ToDelegate<TDelegate>()
        where TDelegate : Delegate
    {
        ThrowIfDisposed();
        if (_isStatic)
        {
            return (TDelegate)Delegate.CreateDelegate(typeof(TDelegate), _method);
        }
        else
        {
            if (typeof(TTarget).IsByRefLike)
                throw new ArgumentException("The target type is a by-ref-like type and cannot be converted to a delegate.");
            
#if !NET9_0_OR_GREATER
            if (IsValueType)
                throw new ArgumentException("The target type is value type and cannot be converted to a delegate.");
#endif

#if NET9_0_OR_GREATER
            object? instance = IsValueType 
                ? RuntimeHelpers.Box(ref Unsafe.AsRef<byte>(_targetPointer), typeof(TTarget).TypeHandle)
                : _referenceTarget;
#else
            object? instance = _referenceTarget;
#endif
            
            if (instance is null)
                throw new InvalidOperationException("Target instance is null.");
            
            return (TDelegate)Delegate.CreateDelegate(typeof(TDelegate), instance, _method);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void ThrowIfDisposed()
    {
        if (_disposed)
            throw new ObjectDisposedException(nameof(LuminFunction<TTarget, T1, T2, TResult>));
    }
    
    #endregion
    
    #region Static Type Hash

    private static readonly int TypeHash = ComputeTypeHash();
    private static readonly int TargetTypeHash = TargetTypeHandle.GetHashCode();
    private static readonly RuntimeTypeHandle TargetTypeHandle = typeof(TTarget).TypeHandle;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static int ComputeTypeHash()
    {
        unchecked
        {
            int h = (int)2166136261;
            h = (h * 16777619) ^ typeof(TResult).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T1).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T2).TypeHandle.GetHashCode();
            return h;
        }
    }

    #endregion

    #region Method Caching

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static MethodCache GetCachedMethod(scoped in RuntimeTypeHandle type, string methodName, int nameHash = 0)
    {
        nameHash = nameHash is 0 ? StringComparer.Ordinal.GetHashCode(methodName) : nameHash;
        int key = type.Equals(TargetTypeHandle)
                      ? TypeHash ^ nameHash ^ TargetTypeHash
                      : TypeHash ^ nameHash ^ type.GetHashCode();
       
        if (!Methods.TryGetValue(key, out var result))
        {
            const BindingFlags flags = BindingFlags.Public | BindingFlags.NonPublic |
                                       BindingFlags.Instance | BindingFlags.Static;
    
            Type[] paramTypes = [ typeof(T1), typeof(T2) ];

#if NET8_0_OR_GREATER
            var method = Type.GetTypeFromHandle(type)!.GetMethod(methodName, flags, paramTypes)
                         ?? throw new MissingMethodException($"Method {methodName} not found on {Type.GetTypeFromHandle(type)!}");
#else
            var method = Type.GetTypeFromHandle(type)!.GetMethod(methodName, flags, null, paramTypes, null)
                         ?? throw new MissingMethodException($"Method {methodName} not found on {Type.GetTypeFromHandle(type)!}");
#endif
            result = new MethodCache(method.IsStatic, method.MethodHandle.GetFunctionPointer(), method);

            Methods.TryAdd(key, result);
        }

        return result;
    }
    
    #endregion
}

public unsafe struct LuminFunction<
#if NET8_0_OR_GREATER
[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)]
#endif
TTarget, T1, T2, T3, TResult> : IDisposable, ICloneable, ISerializable, IEquatable<LuminFunction<TTarget, T1, T2, T3, TResult>>
#if NET9_0_OR_GREATER
    where TTarget : allows ref struct
    where TResult : allows ref struct
    where T1 : allows ref struct
    where T2 : allows ref struct
    where T3 : allows ref struct
#endif
{
    private void* _targetPointer; 
    private object? _referenceTarget; 
    private readonly IntPtr _methodPtr;
    private readonly bool _isStatic;
    private readonly MethodInfo _method;
    private bool _disposed;

    private static readonly bool IsValueType = typeof(TTarget).IsValueType;
    
    public TTarget? Target
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            ThrowIfDisposed();
            
            if (_isStatic)
                return default;
            
            if (IsValueType)
                return Unsafe.AsRef<TTarget?>(_targetPointer);
            
            var target = _referenceTarget;
            return Unsafe.As<object?, TTarget?>(ref target);
        }
    }
    
    public MethodInfo Method => _method;

    #region Constructors
    
    private LuminFunction(MethodCache method)
    {
        _method = method.MethodBase ?? throw new ArgumentNullException(nameof(method));
        _isStatic = method.IsStatic;
        _methodPtr = method.MethodPtr;

        if (!_isStatic)
            throw new ArgumentException("methods are not static!", method.MethodBase.Name);
        
        _referenceTarget = null;
        _targetPointer = null;
    }
    
    private LuminFunction(scoped ref TTarget? target, MethodCache method)
    {
        _method = method.MethodBase ?? throw new ArgumentNullException(nameof(method));
        _isStatic = method.IsStatic;
        _methodPtr = method.MethodPtr;
        _referenceTarget = null;

        if (!_isStatic)
        {
            if (IsValueType)
            {
#if NET8_0_OR_GREATER
                if (Unsafe.IsNullRef(ref target))
                    throw new ArgumentException("Target value instance cannot be null.", nameof(target));
#endif                

#if NET8_0_OR_GREATER
                _targetPointer = NativeMemory.Alloc((nuint)Unsafe.SizeOf<TTarget>());
#else
                _targetPointer = Marshal.AllocHGlobal(Unsafe.SizeOf<TTarget>()).ToPointer();
#endif
                Unsafe.CopyBlock(
                    _targetPointer,
                    Unsafe.AsPointer(ref target),
                    (uint)Unsafe.SizeOf<TTarget>()
                );
            }
            else
            {
                if (target is null)
                    throw new ArgumentException("Target instance object is null.", nameof(target));
                
                _referenceTarget = Unsafe.As<TTarget, object?>(ref target);
                
            }
        }
        else
        {
            _targetPointer = null;
        }
    }
    
    private LuminFunction(Delegate @delegate)
    {
        _method = @delegate.Method ?? throw new ArgumentNullException(nameof(@delegate.Method));
        _isStatic = @delegate.Method.IsStatic;
        _methodPtr = @delegate.Method.MethodHandle.GetFunctionPointer();
        _referenceTarget = null;
        
        var target = @delegate.Target;
        if (!_isStatic)
        {
            if (target is not TTarget)
                throw new ArgumentException("Target instance object is not type.", typeof(TTarget).Name);
                
            if (IsValueType)
            {
#if NET8_0_OR_GREATER
                if (Unsafe.IsNullRef(ref target))
                    throw new ArgumentException("Target value instance cannot be null.", nameof(target));
#endif
                
                var unboxedTarget = Unsafe.AsRef<TTarget>(Unsafe.AsPointer(ref target));
                
#if NET8_0_OR_GREATER
                _targetPointer = NativeMemory.Alloc((nuint)Unsafe.SizeOf<TTarget>());
#else
                _targetPointer = Marshal.AllocHGlobal(Unsafe.SizeOf<TTarget>()).ToPointer();
#endif
                Unsafe.CopyBlock(
                    _targetPointer,
                    Unsafe.AsPointer(ref unboxedTarget),
                    (uint)Unsafe.SizeOf<TTarget>()
                );
            }
            else
            {
                if (target is null)
                    throw new ArgumentException("Target instance object is null.", nameof(target));
                
                _referenceTarget = target;
            }
        }
        else
        {
            _targetPointer = null;
        }
    }

    #endregion
    
    #region Create Factory

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, TResult> Create(scoped ref TTarget? target, string methodName, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(IsValueType
                ? TargetTypeHandle
                : Unsafe.As<TTarget, object?>(ref target!)?.GetType().TypeHandle ?? TargetTypeHandle,
            methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        return new LuminFunction<TTarget, T1, T2, T3, TResult>(ref target, method);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, TResult> Create(scoped ref TTarget? target, string methodName, Type targetType, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(targetType.TypeHandle, methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        return new LuminFunction<TTarget, T1, T2, T3, TResult>(ref target, method);
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, TResult> Create(scoped ref TTarget? target, ReadOnlySpan<char> methodName, int methodNameHash = 0) =>
        Create(ref target, methodName.ToString(), methodNameHash);
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, TResult> Create(scoped ref TTarget? target, ReadOnlySpan<char> methodName, Type targetType, int methodNameHash = 0) =>
        Create(ref target, methodName.ToString(), targetType, methodNameHash);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, TResult> Create(Delegate @delegate) => 
        new LuminFunction<TTarget, T1, T2, T3, TResult>(@delegate);
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, TResult> Create(string methodName, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(TargetTypeHandle, methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        if (!method.IsStatic)
            throw new ArgumentException("Method is not static, please pass in instance as parameter.", nameof(methodName));
        
        return new LuminFunction<TTarget, T1, T2, T3, TResult>(method);
    }

    #endregion
    
    #region Interface Implementation

    public void Dispose()
    {
        if (_disposed)
            return;
        
        
        if (IsValueType && !_isStatic && _targetPointer != null)
        {
#if NET8_0_OR_GREATER
            NativeMemory.Free(_targetPointer);
#else
            Marshal.FreeHGlobal(new IntPtr(_targetPointer));
#endif
        }
       
        _targetPointer = null;
        _referenceTarget = null;

        _disposed = true;
    }
    
    public object Clone()
    {
        ThrowIfDisposed();
        var target = _referenceTarget;
        if (target is null)
            throw new NullReferenceException("Target instance cannot be null.");
                
        return new LuminFunction<TTarget, T1, T2, T3, TResult>(ref Unsafe.As<object?, TTarget>(ref target)!, new MethodCache(_isStatic, _methodPtr, _method));
    }

    public void GetObjectData(SerializationInfo info, StreamingContext context)
    {
        throw new NotSupportedException();
    }
    
    public override bool Equals(object? obj)
    {
        return obj is LuminFunction<TTarget, T1, T2, T3, TResult> other && Equals(other);
    }

    public bool Equals(LuminFunction<TTarget, T1, T2, T3, TResult> other)
    {
        ThrowIfDisposed();
        return _methodPtr == other._methodPtr &&
               _isStatic == other._isStatic &&
               _targetPointer == other._targetPointer;
    }

    public override int GetHashCode()
    {
        ThrowIfDisposed();
        unchecked
        {
            int hash = 17;
            hash = hash * 31 + _methodPtr.GetHashCode();
            hash = hash * 31 + _isStatic.GetHashCode();
            hash = hash * 31 + ((IntPtr)_targetPointer).GetHashCode();
            return hash;
        }
    }

    #endregion
    
    #region Implicit
    
    public static implicit operator LuminFunction<TTarget, T1, T2, T3, TResult>(in Delegate func) 
        => Create(func);

    public static implicit operator LuminFunction<TTarget, T1, T2, T3, TResult>(Func<T1, T2, T3, TResult> func) => 
        Create(func);
    
    #endregion

    #region Invoke

    public object? DynamicInvoke(params object?[] args)
    {
        ThrowIfDisposed();
        
        if (_isStatic)
        {
            return _method.Invoke(null, args);
        }
        else
        {
            if (typeof(TTarget).IsByRefLike)
                throw new ArgumentException(
                    "The target type is a by-ref-like type and cannot be converted to a delegate.");

#if !NET9_0_OR_GREATER
            if (IsValueType)
                throw new ArgumentException("The target type is value type and cannot dynamic invoke.");
#endif

#if NET9_0_OR_GREATER
            object? instance = IsValueType
                ? RuntimeHelpers.Box(ref Unsafe.AsRef<byte>(_targetPointer), typeof(TTarget).TypeHandle)
                : _referenceTarget;
#else
            object? instance = _referenceTarget;
#endif

            if (instance is null)
                throw new InvalidOperationException("Target instance is null.");

            return _method.Invoke(instance, args);
        }
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public TResult Invoke(T1 arg1, T2 arg2, T3 arg3)
    {
        ThrowIfDisposed();

        if (!_isStatic && !IsValueType)
            return ((delegate* managed<TTarget, T1, T2, T3, TResult>)_methodPtr)(Unsafe.As<object?, TTarget>(ref _referenceTarget), arg1, arg2, arg3);
        else if (IsValueType)
            return ((delegate* managed<ref TTarget, T1, T2, T3, TResult>)_methodPtr)(ref Unsafe.AsRef<TTarget>(_targetPointer), arg1, arg2, arg3);
        else
            return ((delegate* managed<T1, T2, T3, TResult>)_methodPtr)(arg1, arg2, arg3);
    }

    #endregion
    
    #region Auxiliary methods
    
    public TDelegate ToDelegate<TDelegate>()
        where TDelegate : Delegate
    {
        ThrowIfDisposed();
        if (_isStatic)
        {
            return (TDelegate)Delegate.CreateDelegate(typeof(TDelegate), _method);
        }
        else
        {
            if (typeof(TTarget).IsByRefLike)
                throw new ArgumentException("The target type is a by-ref-like type and cannot be converted to a delegate.");
            
#if !NET9_0_OR_GREATER
            if (IsValueType)
                throw new ArgumentException("The target type is value type and cannot be converted to a delegate.");
#endif

#if NET9_0_OR_GREATER
            object? instance = IsValueType 
                ? RuntimeHelpers.Box(ref Unsafe.AsRef<byte>(_targetPointer), typeof(TTarget).TypeHandle)
                : _referenceTarget;
#else
            object? instance = _referenceTarget;
#endif
            
            if (instance is null)
                throw new InvalidOperationException("Target instance is null.");
            
            return (TDelegate)Delegate.CreateDelegate(typeof(TDelegate), instance, _method);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void ThrowIfDisposed()
    {
        if (_disposed)
            throw new ObjectDisposedException(nameof(LuminFunction<TTarget, T1, T2, T3, TResult>));
    }
    
    #endregion
    
    #region Static Type Hash

    private static readonly int TypeHash = ComputeTypeHash();
    private static readonly int TargetTypeHash = TargetTypeHandle.GetHashCode();
    private static readonly RuntimeTypeHandle TargetTypeHandle = typeof(TTarget).TypeHandle;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static int ComputeTypeHash()
    {
        unchecked
        {
            int h = (int)2166136261;
            h = (h * 16777619) ^ typeof(TResult).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T1).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T2).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T3).TypeHandle.GetHashCode();
            return h;
        }
    }

    #endregion

    #region Method Caching

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static MethodCache GetCachedMethod(scoped in RuntimeTypeHandle type, string methodName, int nameHash = 0)
    {
        nameHash = nameHash is 0 ? StringComparer.Ordinal.GetHashCode(methodName) : nameHash;
        int key = type.Equals(TargetTypeHandle)
                      ? TypeHash ^ nameHash ^ TargetTypeHash
                      : TypeHash ^ nameHash ^ type.GetHashCode();
       
        if (!Methods.TryGetValue(key, out var result))
        {
            const BindingFlags flags = BindingFlags.Public | BindingFlags.NonPublic |
                                       BindingFlags.Instance | BindingFlags.Static;
    
            Type[] paramTypes = [ typeof(T1), typeof(T2), typeof(T3) ];

#if NET8_0_OR_GREATER
            var method = Type.GetTypeFromHandle(type)!.GetMethod(methodName, flags, paramTypes)
                         ?? throw new MissingMethodException($"Method {methodName} not found on {Type.GetTypeFromHandle(type)!}");
#else
            var method = Type.GetTypeFromHandle(type)!.GetMethod(methodName, flags, null, paramTypes, null)
                         ?? throw new MissingMethodException($"Method {methodName} not found on {Type.GetTypeFromHandle(type)!}");
#endif
            result = new MethodCache(method.IsStatic, method.MethodHandle.GetFunctionPointer(), method);

            Methods.TryAdd(key, result);
        }

        return result;
    }
    
    #endregion
}

public unsafe struct LuminFunction<
#if NET8_0_OR_GREATER
[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)]
#endif
TTarget, T1, T2, T3, T4, TResult> : IDisposable, ICloneable, ISerializable, IEquatable<LuminFunction<TTarget, T1, T2, T3, T4, TResult>>
#if NET9_0_OR_GREATER
    where TTarget : allows ref struct
    where TResult : allows ref struct
    where T1 : allows ref struct
    where T2 : allows ref struct
    where T3 : allows ref struct
    where T4 : allows ref struct
#endif
{
    private void* _targetPointer; 
    private object? _referenceTarget; 
    private readonly IntPtr _methodPtr;
    private readonly bool _isStatic;
    private readonly MethodInfo _method;
    private bool _disposed;

    private static readonly bool IsValueType = typeof(TTarget).IsValueType;
    
    public TTarget? Target
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            ThrowIfDisposed();
            
            if (_isStatic)
                return default;
            
            if (IsValueType)
                return Unsafe.AsRef<TTarget?>(_targetPointer);
            
            var target = _referenceTarget;
            return Unsafe.As<object?, TTarget?>(ref target);
        }
    }
    
    public MethodInfo Method => _method;

    #region Constructors
    
    private LuminFunction(MethodCache method)
    {
        _method = method.MethodBase ?? throw new ArgumentNullException(nameof(method));
        _isStatic = method.IsStatic;
        _methodPtr = method.MethodPtr;

        if (!_isStatic)
            throw new ArgumentException("methods are not static!", method.MethodBase.Name);
        
        _referenceTarget = null;
        _targetPointer = null;
    }
    
    private LuminFunction(scoped ref TTarget? target, MethodCache method)
    {
        _method = method.MethodBase ?? throw new ArgumentNullException(nameof(method));
        _isStatic = method.IsStatic;
        _methodPtr = method.MethodPtr;
        _referenceTarget = null;

        if (!_isStatic)
        {
            if (IsValueType)
            {
#if NET8_0_OR_GREATER
                if (Unsafe.IsNullRef(ref target))
                    throw new ArgumentException("Target value instance cannot be null.", nameof(target));
#endif                

#if NET8_0_OR_GREATER
                _targetPointer = NativeMemory.Alloc((nuint)Unsafe.SizeOf<TTarget>());
#else
                _targetPointer = Marshal.AllocHGlobal(Unsafe.SizeOf<TTarget>()).ToPointer();
#endif
                Unsafe.CopyBlock(
                    _targetPointer,
                    Unsafe.AsPointer(ref target),
                    (uint)Unsafe.SizeOf<TTarget>()
                );
            }
            else
            {
                if (target is null)
                    throw new ArgumentException("Target instance object is null.", nameof(target));
                
                _referenceTarget = Unsafe.As<TTarget, object?>(ref target);
                
            }
        }
        else
        {
            _targetPointer = null;
        }
    }
    
    private LuminFunction(Delegate @delegate)
    {
        _method = @delegate.Method ?? throw new ArgumentNullException(nameof(@delegate.Method));
        _isStatic = @delegate.Method.IsStatic;
        _methodPtr = @delegate.Method.MethodHandle.GetFunctionPointer();
        _referenceTarget = null;
        
        var target = @delegate.Target;
        if (!_isStatic)
        {
            if (target is not TTarget)
                throw new ArgumentException("Target instance object is not type.", typeof(TTarget).Name);
                
            if (IsValueType)
            {
#if NET8_0_OR_GREATER
                if (Unsafe.IsNullRef(ref target))
                    throw new ArgumentException("Target value instance cannot be null.", nameof(target));
#endif
                
                var unboxedTarget = Unsafe.AsRef<TTarget>(Unsafe.AsPointer(ref target));
                
#if NET8_0_OR_GREATER
                _targetPointer = NativeMemory.Alloc((nuint)Unsafe.SizeOf<TTarget>());
#else
                _targetPointer = Marshal.AllocHGlobal(Unsafe.SizeOf<TTarget>()).ToPointer();
#endif
                Unsafe.CopyBlock(
                    _targetPointer,
                    Unsafe.AsPointer(ref unboxedTarget),
                    (uint)Unsafe.SizeOf<TTarget>()
                );
            }
            else
            {
                if (target is null)
                    throw new ArgumentException("Target instance object is null.", nameof(target));
                
                _referenceTarget = target;
            }
        }
        else
        {
            _targetPointer = null;
        }
    }

    #endregion
    
    #region Create Factory

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, T4, TResult> Create(scoped ref TTarget? target, string methodName, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(IsValueType
                ? TargetTypeHandle
                : Unsafe.As<TTarget, object?>(ref target!)?.GetType().TypeHandle ?? TargetTypeHandle,
            methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        return new LuminFunction<TTarget, T1, T2, T3, T4, TResult>(ref target, method);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, T4, TResult> Create(scoped ref TTarget? target, string methodName, Type targetType, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(targetType.TypeHandle, methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        return new LuminFunction<TTarget, T1, T2, T3, T4, TResult>(ref target, method);
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, T4, TResult> Create(scoped ref TTarget? target, ReadOnlySpan<char> methodName, int methodNameHash = 0) =>
        Create(ref target, methodName.ToString(), methodNameHash);
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, T4, TResult> Create(scoped ref TTarget? target, ReadOnlySpan<char> methodName, Type targetType, int methodNameHash = 0) =>
        Create(ref target, methodName.ToString(), targetType, methodNameHash);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, T4, TResult> Create(Delegate @delegate) => 
        new LuminFunction<TTarget, T1, T2, T3, T4, TResult>(@delegate);
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, T4, TResult> Create(string methodName, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(TargetTypeHandle, methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        if (!method.IsStatic)
            throw new ArgumentException("Method is not static, please pass in instance as parameter.", nameof(methodName));
        
        return new LuminFunction<TTarget, T1, T2, T3, T4, TResult>(method);
    }

    #endregion
    
    #region Interface Implementation

    public void Dispose()
    {
        if (_disposed)
            return;
        
        
        if (IsValueType && !_isStatic && _targetPointer != null)
        {
#if NET8_0_OR_GREATER
            NativeMemory.Free(_targetPointer);
#else
            Marshal.FreeHGlobal(new IntPtr(_targetPointer));
#endif
        }
       
        _targetPointer = null;
        _referenceTarget = null;

        _disposed = true;
    }
    
    public object Clone()
    {
        ThrowIfDisposed();
        var target = _referenceTarget;
        if (target is null)
            throw new NullReferenceException("Target instance cannot be null.");
                
        return new LuminFunction<TTarget, T1, T2, T3, T4, TResult>(ref Unsafe.As<object?, TTarget>(ref target)!, new MethodCache(_isStatic, _methodPtr, _method));
    }

    public void GetObjectData(SerializationInfo info, StreamingContext context)
    {
        throw new NotSupportedException();
    }
    
    public override bool Equals(object? obj)
    {
        return obj is LuminFunction<TTarget, T1, T2, T3, T4, TResult> other && Equals(other);
    }

    public bool Equals(LuminFunction<TTarget, T1, T2, T3, T4, TResult> other)
    {
        ThrowIfDisposed();
        return _methodPtr == other._methodPtr &&
               _isStatic == other._isStatic &&
               _targetPointer == other._targetPointer;
    }

    public override int GetHashCode()
    {
        ThrowIfDisposed();
        unchecked
        {
            int hash = 17;
            hash = hash * 31 + _methodPtr.GetHashCode();
            hash = hash * 31 + _isStatic.GetHashCode();
            hash = hash * 31 + ((IntPtr)_targetPointer).GetHashCode();
            return hash;
        }
    }

    #endregion
    
    #region Implicit
    
    public static implicit operator LuminFunction<TTarget, T1, T2, T3, T4, TResult>(in Delegate func) 
        => Create(func);

    public static implicit operator LuminFunction<TTarget, T1, T2, T3, T4, TResult>(Func<T1, T2, T3, T4, TResult> func) => 
        Create(func);
    
    #endregion

    #region Invoke

    public object? DynamicInvoke(params object?[] args)
    {
        ThrowIfDisposed();
        
        if (_isStatic)
        {
            return _method.Invoke(null, args);
        }
        else
        {
            if (typeof(TTarget).IsByRefLike)
                throw new ArgumentException(
                    "The target type is a by-ref-like type and cannot be converted to a delegate.");

#if !NET9_0_OR_GREATER
            if (IsValueType)
                throw new ArgumentException("The target type is value type and cannot dynamic invoke.");
#endif

#if NET9_0_OR_GREATER
            object? instance = IsValueType
                ? RuntimeHelpers.Box(ref Unsafe.AsRef<byte>(_targetPointer), typeof(TTarget).TypeHandle)
                : _referenceTarget;
#else
            object? instance = _referenceTarget;
#endif

            if (instance is null)
                throw new InvalidOperationException("Target instance is null.");

            return _method.Invoke(instance, args);
        }
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4)
    {
        ThrowIfDisposed();

        if (!_isStatic && !IsValueType)
            return ((delegate* managed<TTarget, T1, T2, T3, T4, TResult>)_methodPtr)(Unsafe.As<object?, TTarget>(ref _referenceTarget), arg1, arg2, arg3, arg4);
        else if (IsValueType)
            return ((delegate* managed<ref TTarget, T1, T2, T3, T4, TResult>)_methodPtr)(ref Unsafe.AsRef<TTarget>(_targetPointer), arg1, arg2, arg3, arg4);
        else
            return ((delegate* managed<T1, T2, T3, T4, TResult>)_methodPtr)(arg1, arg2, arg3, arg4);
    }

    #endregion
    
    #region Auxiliary methods
    
    public TDelegate ToDelegate<TDelegate>()
        where TDelegate : Delegate
    {
        ThrowIfDisposed();
        if (_isStatic)
        {
            return (TDelegate)Delegate.CreateDelegate(typeof(TDelegate), _method);
        }
        else
        {
            if (typeof(TTarget).IsByRefLike)
                throw new ArgumentException("The target type is a by-ref-like type and cannot be converted to a delegate.");
            
#if !NET9_0_OR_GREATER
            if (IsValueType)
                throw new ArgumentException("The target type is value type and cannot be converted to a delegate.");
#endif

#if NET9_0_OR_GREATER
            object? instance = IsValueType 
                ? RuntimeHelpers.Box(ref Unsafe.AsRef<byte>(_targetPointer), typeof(TTarget).TypeHandle)
                : _referenceTarget;
#else
            object? instance = _referenceTarget;
#endif
            
            if (instance is null)
                throw new InvalidOperationException("Target instance is null.");
            
            return (TDelegate)Delegate.CreateDelegate(typeof(TDelegate), instance, _method);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void ThrowIfDisposed()
    {
        if (_disposed)
            throw new ObjectDisposedException(nameof(LuminFunction<TTarget, T1, T2, T3, T4, TResult>));
    }
    
    #endregion
    
    #region Static Type Hash

    private static readonly int TypeHash = ComputeTypeHash();
    private static readonly int TargetTypeHash = TargetTypeHandle.GetHashCode();
    private static readonly RuntimeTypeHandle TargetTypeHandle = typeof(TTarget).TypeHandle;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static int ComputeTypeHash()
    {
        unchecked
        {
            int h = (int)2166136261;
            h = (h * 16777619) ^ typeof(TResult).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T1).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T2).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T3).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T4).TypeHandle.GetHashCode();
            return h;
        }
    }

    #endregion

    #region Method Caching

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static MethodCache GetCachedMethod(scoped in RuntimeTypeHandle type, string methodName, int nameHash = 0)
    {
        nameHash = nameHash is 0 ? StringComparer.Ordinal.GetHashCode(methodName) : nameHash;
        int key = type.Equals(TargetTypeHandle)
                      ? TypeHash ^ nameHash ^ TargetTypeHash
                      : TypeHash ^ nameHash ^ type.GetHashCode();
       
        if (!Methods.TryGetValue(key, out var result))
        {
            const BindingFlags flags = BindingFlags.Public | BindingFlags.NonPublic |
                                       BindingFlags.Instance | BindingFlags.Static;
    
            Type[] paramTypes = [ typeof(T1), typeof(T2), typeof(T3), typeof(T4) ];

#if NET8_0_OR_GREATER
            var method = Type.GetTypeFromHandle(type)!.GetMethod(methodName, flags, paramTypes)
                         ?? throw new MissingMethodException($"Method {methodName} not found on {Type.GetTypeFromHandle(type)!}");
#else
            var method = Type.GetTypeFromHandle(type)!.GetMethod(methodName, flags, null, paramTypes, null)
                         ?? throw new MissingMethodException($"Method {methodName} not found on {Type.GetTypeFromHandle(type)!}");
#endif
            result = new MethodCache(method.IsStatic, method.MethodHandle.GetFunctionPointer(), method);

            Methods.TryAdd(key, result);
        }

        return result;
    }
    
    #endregion
}

public unsafe struct LuminFunction<
#if NET8_0_OR_GREATER
[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)]
#endif
TTarget, T1, T2, T3, T4, T5, TResult> : IDisposable, ICloneable, ISerializable, IEquatable<LuminFunction<TTarget, T1, T2, T3, T4, T5, TResult>>
#if NET9_0_OR_GREATER
    where TTarget : allows ref struct
    where TResult : allows ref struct
    where T1 : allows ref struct
    where T2 : allows ref struct
    where T3 : allows ref struct
    where T4 : allows ref struct
    where T5 : allows ref struct
#endif
{
    private void* _targetPointer; 
    private object? _referenceTarget; 
    private readonly IntPtr _methodPtr;
    private readonly bool _isStatic;
    private readonly MethodInfo _method;
    private bool _disposed;

    private static readonly bool IsValueType = typeof(TTarget).IsValueType;
    
    public TTarget? Target
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            ThrowIfDisposed();
            
            if (_isStatic)
                return default;
            
            if (IsValueType)
                return Unsafe.AsRef<TTarget?>(_targetPointer);
            
            var target = _referenceTarget;
            return Unsafe.As<object?, TTarget?>(ref target);
        }
    }
    
    public MethodInfo Method => _method;

    #region Constructors
    
    private LuminFunction(MethodCache method)
    {
        _method = method.MethodBase ?? throw new ArgumentNullException(nameof(method));
        _isStatic = method.IsStatic;
        _methodPtr = method.MethodPtr;

        if (!_isStatic)
            throw new ArgumentException("methods are not static!", method.MethodBase.Name);
        
        _referenceTarget = null;
        _targetPointer = null;
    }
    
    private LuminFunction(scoped ref TTarget? target, MethodCache method)
    {
        _method = method.MethodBase ?? throw new ArgumentNullException(nameof(method));
        _isStatic = method.IsStatic;
        _methodPtr = method.MethodPtr;
        _referenceTarget = null;

        if (!_isStatic)
        {
            if (IsValueType)
            {
#if NET8_0_OR_GREATER
                if (Unsafe.IsNullRef(ref target))
                    throw new ArgumentException("Target value instance cannot be null.", nameof(target));
#endif                

#if NET8_0_OR_GREATER
                _targetPointer = NativeMemory.Alloc((nuint)Unsafe.SizeOf<TTarget>());
#else
                _targetPointer = Marshal.AllocHGlobal(Unsafe.SizeOf<TTarget>()).ToPointer();
#endif
                Unsafe.CopyBlock(
                    _targetPointer,
                    Unsafe.AsPointer(ref target),
                    (uint)Unsafe.SizeOf<TTarget>()
                );
            }
            else
            {
                if (target is null)
                    throw new ArgumentException("Target instance object is null.", nameof(target));
                
                _referenceTarget = Unsafe.As<TTarget, object?>(ref target);
                
            }
        }
        else
        {
            _targetPointer = null;
        }
    }
    
    private LuminFunction(Delegate @delegate)
    {
        _method = @delegate.Method ?? throw new ArgumentNullException(nameof(@delegate.Method));
        _isStatic = @delegate.Method.IsStatic;
        _methodPtr = @delegate.Method.MethodHandle.GetFunctionPointer();
        _referenceTarget = null;
        
        var target = @delegate.Target;
        if (!_isStatic)
        {
            if (target is not TTarget)
                throw new ArgumentException("Target instance object is not type.", typeof(TTarget).Name);
                
            if (IsValueType)
            {
#if NET8_0_OR_GREATER
                if (Unsafe.IsNullRef(ref target))
                    throw new ArgumentException("Target value instance cannot be null.", nameof(target));
#endif
                
                var unboxedTarget = Unsafe.AsRef<TTarget>(Unsafe.AsPointer(ref target));
                
#if NET8_0_OR_GREATER
                _targetPointer = NativeMemory.Alloc((nuint)Unsafe.SizeOf<TTarget>());
#else
                _targetPointer = Marshal.AllocHGlobal(Unsafe.SizeOf<TTarget>()).ToPointer();
#endif
                Unsafe.CopyBlock(
                    _targetPointer,
                    Unsafe.AsPointer(ref unboxedTarget),
                    (uint)Unsafe.SizeOf<TTarget>()
                );
            }
            else
            {
                if (target is null)
                    throw new ArgumentException("Target instance object is null.", nameof(target));
                
                _referenceTarget = target;
            }
        }
        else
        {
            _targetPointer = null;
        }
    }

    #endregion
    
    #region Create Factory

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, T4, T5, TResult> Create(scoped ref TTarget? target, string methodName, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(IsValueType
                ? TargetTypeHandle
                : Unsafe.As<TTarget, object?>(ref target!)?.GetType().TypeHandle ?? TargetTypeHandle,
            methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        return new LuminFunction<TTarget, T1, T2, T3, T4, T5, TResult>(ref target, method);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, T4, T5, TResult> Create(scoped ref TTarget? target, string methodName, Type targetType, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(targetType.TypeHandle, methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        return new LuminFunction<TTarget, T1, T2, T3, T4, T5, TResult>(ref target, method);
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, T4, T5, TResult> Create(scoped ref TTarget? target, ReadOnlySpan<char> methodName, int methodNameHash = 0) =>
        Create(ref target, methodName.ToString(), methodNameHash);
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, T4, T5, TResult> Create(scoped ref TTarget? target, ReadOnlySpan<char> methodName, Type targetType, int methodNameHash = 0) =>
        Create(ref target, methodName.ToString(), targetType, methodNameHash);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, T4, T5, TResult> Create(Delegate @delegate) => 
        new LuminFunction<TTarget, T1, T2, T3, T4, T5, TResult>(@delegate);
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, T4, T5, TResult> Create(string methodName, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(TargetTypeHandle, methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        if (!method.IsStatic)
            throw new ArgumentException("Method is not static, please pass in instance as parameter.", nameof(methodName));
        
        return new LuminFunction<TTarget, T1, T2, T3, T4, T5, TResult>(method);
    }

    #endregion
    
    #region Interface Implementation

    public void Dispose()
    {
        if (_disposed)
            return;
        
        
        if (IsValueType && !_isStatic && _targetPointer != null)
        {
#if NET8_0_OR_GREATER
            NativeMemory.Free(_targetPointer);
#else
            Marshal.FreeHGlobal(new IntPtr(_targetPointer));
#endif
        }
       
        _targetPointer = null;
        _referenceTarget = null;

        _disposed = true;
    }
    
    public object Clone()
    {
        ThrowIfDisposed();
        var target = _referenceTarget;
        if (target is null)
            throw new NullReferenceException("Target instance cannot be null.");
                
        return new LuminFunction<TTarget, T1, T2, T3, T4, T5, TResult>(ref Unsafe.As<object?, TTarget>(ref target)!, new MethodCache(_isStatic, _methodPtr, _method));
    }

    public void GetObjectData(SerializationInfo info, StreamingContext context)
    {
        throw new NotSupportedException();
    }
    
    public override bool Equals(object? obj)
    {
        return obj is LuminFunction<TTarget, T1, T2, T3, T4, T5, TResult> other && Equals(other);
    }

    public bool Equals(LuminFunction<TTarget, T1, T2, T3, T4, T5, TResult> other)
    {
        ThrowIfDisposed();
        return _methodPtr == other._methodPtr &&
               _isStatic == other._isStatic &&
               _targetPointer == other._targetPointer;
    }

    public override int GetHashCode()
    {
        ThrowIfDisposed();
        unchecked
        {
            int hash = 17;
            hash = hash * 31 + _methodPtr.GetHashCode();
            hash = hash * 31 + _isStatic.GetHashCode();
            hash = hash * 31 + ((IntPtr)_targetPointer).GetHashCode();
            return hash;
        }
    }

    #endregion
    
    #region Implicit
    
    public static implicit operator LuminFunction<TTarget, T1, T2, T3, T4, T5, TResult>(in Delegate func) 
        => Create(func);

    public static implicit operator LuminFunction<TTarget, T1, T2, T3, T4, T5, TResult>(Func<T1, T2, T3, T4, T5, TResult> func) => 
        Create(func);
    
    #endregion

    #region Invoke

    public object? DynamicInvoke(params object?[] args)
    {
        ThrowIfDisposed();
        
        if (_isStatic)
        {
            return _method.Invoke(null, args);
        }
        else
        {
            if (typeof(TTarget).IsByRefLike)
                throw new ArgumentException(
                    "The target type is a by-ref-like type and cannot be converted to a delegate.");

#if !NET9_0_OR_GREATER
            if (IsValueType)
                throw new ArgumentException("The target type is value type and cannot dynamic invoke.");
#endif

#if NET9_0_OR_GREATER
            object? instance = IsValueType
                ? RuntimeHelpers.Box(ref Unsafe.AsRef<byte>(_targetPointer), typeof(TTarget).TypeHandle)
                : _referenceTarget;
#else
            object? instance = _referenceTarget;
#endif

            if (instance is null)
                throw new InvalidOperationException("Target instance is null.");

            return _method.Invoke(instance, args);
        }
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5)
    {
        ThrowIfDisposed();

        if (!_isStatic && !IsValueType)
            return ((delegate* managed<TTarget, T1, T2, T3, T4, T5, TResult>)_methodPtr)(Unsafe.As<object?, TTarget>(ref _referenceTarget), arg1, arg2, arg3, arg4, arg5);
        else if (IsValueType)
            return ((delegate* managed<ref TTarget, T1, T2, T3, T4, T5, TResult>)_methodPtr)(ref Unsafe.AsRef<TTarget>(_targetPointer), arg1, arg2, arg3, arg4, arg5);
        else
            return ((delegate* managed<T1, T2, T3, T4, T5, TResult>)_methodPtr)(arg1, arg2, arg3, arg4, arg5);
    }

    #endregion
    
    #region Auxiliary methods
    
    public TDelegate ToDelegate<TDelegate>()
        where TDelegate : Delegate
    {
        ThrowIfDisposed();
        if (_isStatic)
        {
            return (TDelegate)Delegate.CreateDelegate(typeof(TDelegate), _method);
        }
        else
        {
            if (typeof(TTarget).IsByRefLike)
                throw new ArgumentException("The target type is a by-ref-like type and cannot be converted to a delegate.");
            
#if !NET9_0_OR_GREATER
            if (IsValueType)
                throw new ArgumentException("The target type is value type and cannot be converted to a delegate.");
#endif

#if NET9_0_OR_GREATER
            object? instance = IsValueType 
                ? RuntimeHelpers.Box(ref Unsafe.AsRef<byte>(_targetPointer), typeof(TTarget).TypeHandle)
                : _referenceTarget;
#else
            object? instance = _referenceTarget;
#endif
            
            if (instance is null)
                throw new InvalidOperationException("Target instance is null.");
            
            return (TDelegate)Delegate.CreateDelegate(typeof(TDelegate), instance, _method);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void ThrowIfDisposed()
    {
        if (_disposed)
            throw new ObjectDisposedException(nameof(LuminFunction<TTarget, T1, T2, T3, T4, T5, TResult>));
    }
    
    #endregion
    
    #region Static Type Hash

    private static readonly int TypeHash = ComputeTypeHash();
    private static readonly int TargetTypeHash = TargetTypeHandle.GetHashCode();
    private static readonly RuntimeTypeHandle TargetTypeHandle = typeof(TTarget).TypeHandle;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static int ComputeTypeHash()
    {
        unchecked
        {
            int h = (int)2166136261;
            h = (h * 16777619) ^ typeof(TResult).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T1).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T2).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T3).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T4).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T5).TypeHandle.GetHashCode();
            return h;
        }
    }

    #endregion

    #region Method Caching

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static MethodCache GetCachedMethod(scoped in RuntimeTypeHandle type, string methodName, int nameHash = 0)
    {
        nameHash = nameHash is 0 ? StringComparer.Ordinal.GetHashCode(methodName) : nameHash;
        int key = type.Equals(TargetTypeHandle)
                      ? TypeHash ^ nameHash ^ TargetTypeHash
                      : TypeHash ^ nameHash ^ type.GetHashCode();
       
        if (!Methods.TryGetValue(key, out var result))
        {
            const BindingFlags flags = BindingFlags.Public | BindingFlags.NonPublic |
                                       BindingFlags.Instance | BindingFlags.Static;
    
            Type[] paramTypes = [ typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5) ];

#if NET8_0_OR_GREATER
            var method = Type.GetTypeFromHandle(type)!.GetMethod(methodName, flags, paramTypes)
                         ?? throw new MissingMethodException($"Method {methodName} not found on {Type.GetTypeFromHandle(type)!}");
#else
            var method = Type.GetTypeFromHandle(type)!.GetMethod(methodName, flags, null, paramTypes, null)
                         ?? throw new MissingMethodException($"Method {methodName} not found on {Type.GetTypeFromHandle(type)!}");
#endif
            result = new MethodCache(method.IsStatic, method.MethodHandle.GetFunctionPointer(), method);

            Methods.TryAdd(key, result);
        }

        return result;
    }
    
    #endregion
}

public unsafe struct LuminFunction<
#if NET8_0_OR_GREATER
[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)]
#endif
TTarget, T1, T2, T3, T4, T5, T6, TResult> : IDisposable, ICloneable, ISerializable, IEquatable<LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, TResult>>
#if NET9_0_OR_GREATER
    where TTarget : allows ref struct
    where TResult : allows ref struct
    where T1 : allows ref struct
    where T2 : allows ref struct
    where T3 : allows ref struct
    where T4 : allows ref struct
    where T5 : allows ref struct
    where T6 : allows ref struct
#endif
{
    private void* _targetPointer; 
    private object? _referenceTarget; 
    private readonly IntPtr _methodPtr;
    private readonly bool _isStatic;
    private readonly MethodInfo _method;
    private bool _disposed;

    private static readonly bool IsValueType = typeof(TTarget).IsValueType;
    
    public TTarget? Target
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            ThrowIfDisposed();
            
            if (_isStatic)
                return default;
            
            if (IsValueType)
                return Unsafe.AsRef<TTarget?>(_targetPointer);
            
            var target = _referenceTarget;
            return Unsafe.As<object?, TTarget?>(ref target);
        }
    }
    
    public MethodInfo Method => _method;

    #region Constructors
    
    private LuminFunction(MethodCache method)
    {
        _method = method.MethodBase ?? throw new ArgumentNullException(nameof(method));
        _isStatic = method.IsStatic;
        _methodPtr = method.MethodPtr;

        if (!_isStatic)
            throw new ArgumentException("methods are not static!", method.MethodBase.Name);
        
        _referenceTarget = null;
        _targetPointer = null;
    }
    
    private LuminFunction(scoped ref TTarget? target, MethodCache method)
    {
        _method = method.MethodBase ?? throw new ArgumentNullException(nameof(method));
        _isStatic = method.IsStatic;
        _methodPtr = method.MethodPtr;
        _referenceTarget = null;

        if (!_isStatic)
        {
            if (IsValueType)
            {
#if NET8_0_OR_GREATER
                if (Unsafe.IsNullRef(ref target))
                    throw new ArgumentException("Target value instance cannot be null.", nameof(target));
#endif                

#if NET8_0_OR_GREATER
                _targetPointer = NativeMemory.Alloc((nuint)Unsafe.SizeOf<TTarget>());
#else
                _targetPointer = Marshal.AllocHGlobal(Unsafe.SizeOf<TTarget>()).ToPointer();
#endif
                Unsafe.CopyBlock(
                    _targetPointer,
                    Unsafe.AsPointer(ref target),
                    (uint)Unsafe.SizeOf<TTarget>()
                );
            }
            else
            {
                if (target is null)
                    throw new ArgumentException("Target instance object is null.", nameof(target));
                
                _referenceTarget = Unsafe.As<TTarget, object?>(ref target);
                
            }
        }
        else
        {
            _targetPointer = null;
        }
    }
    
    private LuminFunction(Delegate @delegate)
    {
        _method = @delegate.Method ?? throw new ArgumentNullException(nameof(@delegate.Method));
        _isStatic = @delegate.Method.IsStatic;
        _methodPtr = @delegate.Method.MethodHandle.GetFunctionPointer();
        _referenceTarget = null;
        
        var target = @delegate.Target;
        if (!_isStatic)
        {
            if (target is not TTarget)
                throw new ArgumentException("Target instance object is not type.", typeof(TTarget).Name);
                
            if (IsValueType)
            {
#if NET8_0_OR_GREATER
                if (Unsafe.IsNullRef(ref target))
                    throw new ArgumentException("Target value instance cannot be null.", nameof(target));
#endif
                
                var unboxedTarget = Unsafe.AsRef<TTarget>(Unsafe.AsPointer(ref target));
                
#if NET8_0_OR_GREATER
                _targetPointer = NativeMemory.Alloc((nuint)Unsafe.SizeOf<TTarget>());
#else
                _targetPointer = Marshal.AllocHGlobal(Unsafe.SizeOf<TTarget>()).ToPointer();
#endif
                Unsafe.CopyBlock(
                    _targetPointer,
                    Unsafe.AsPointer(ref unboxedTarget),
                    (uint)Unsafe.SizeOf<TTarget>()
                );
            }
            else
            {
                if (target is null)
                    throw new ArgumentException("Target instance object is null.", nameof(target));
                
                _referenceTarget = target;
            }
        }
        else
        {
            _targetPointer = null;
        }
    }

    #endregion
    
    #region Create Factory

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, TResult> Create(scoped ref TTarget? target, string methodName, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(IsValueType
                ? TargetTypeHandle
                : Unsafe.As<TTarget, object?>(ref target!)?.GetType().TypeHandle ?? TargetTypeHandle,
            methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        return new LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, TResult>(ref target, method);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, TResult> Create(scoped ref TTarget? target, string methodName, Type targetType, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(targetType.TypeHandle, methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        return new LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, TResult>(ref target, method);
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, TResult> Create(scoped ref TTarget? target, ReadOnlySpan<char> methodName, int methodNameHash = 0) =>
        Create(ref target, methodName.ToString(), methodNameHash);
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, TResult> Create(scoped ref TTarget? target, ReadOnlySpan<char> methodName, Type targetType, int methodNameHash = 0) =>
        Create(ref target, methodName.ToString(), targetType, methodNameHash);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, TResult> Create(Delegate @delegate) => 
        new LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, TResult>(@delegate);
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, TResult> Create(string methodName, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(TargetTypeHandle, methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        if (!method.IsStatic)
            throw new ArgumentException("Method is not static, please pass in instance as parameter.", nameof(methodName));
        
        return new LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, TResult>(method);
    }

    #endregion
    
    #region Interface Implementation

    public void Dispose()
    {
        if (_disposed)
            return;
        
        
        if (IsValueType && !_isStatic && _targetPointer != null)
        {
#if NET8_0_OR_GREATER
            NativeMemory.Free(_targetPointer);
#else
            Marshal.FreeHGlobal(new IntPtr(_targetPointer));
#endif
        }
       
        _targetPointer = null;
        _referenceTarget = null;

        _disposed = true;
    }
    
    public object Clone()
    {
        ThrowIfDisposed();
        var target = _referenceTarget;
        if (target is null)
            throw new NullReferenceException("Target instance cannot be null.");
                
        return new LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, TResult>(ref Unsafe.As<object?, TTarget>(ref target)!, new MethodCache(_isStatic, _methodPtr, _method));
    }

    public void GetObjectData(SerializationInfo info, StreamingContext context)
    {
        throw new NotSupportedException();
    }
    
    public override bool Equals(object? obj)
    {
        return obj is LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, TResult> other && Equals(other);
    }

    public bool Equals(LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, TResult> other)
    {
        ThrowIfDisposed();
        return _methodPtr == other._methodPtr &&
               _isStatic == other._isStatic &&
               _targetPointer == other._targetPointer;
    }

    public override int GetHashCode()
    {
        ThrowIfDisposed();
        unchecked
        {
            int hash = 17;
            hash = hash * 31 + _methodPtr.GetHashCode();
            hash = hash * 31 + _isStatic.GetHashCode();
            hash = hash * 31 + ((IntPtr)_targetPointer).GetHashCode();
            return hash;
        }
    }

    #endregion
    
    #region Implicit
    
    public static implicit operator LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, TResult>(in Delegate func) 
        => Create(func);

    public static implicit operator LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, TResult>(Func<T1, T2, T3, T4, T5, T6, TResult> func) => 
        Create(func);
    
    #endregion

    #region Invoke

    public object? DynamicInvoke(params object?[] args)
    {
        ThrowIfDisposed();
        
        if (_isStatic)
        {
            return _method.Invoke(null, args);
        }
        else
        {
            if (typeof(TTarget).IsByRefLike)
                throw new ArgumentException(
                    "The target type is a by-ref-like type and cannot be converted to a delegate.");

#if !NET9_0_OR_GREATER
            if (IsValueType)
                throw new ArgumentException("The target type is value type and cannot dynamic invoke.");
#endif

#if NET9_0_OR_GREATER
            object? instance = IsValueType
                ? RuntimeHelpers.Box(ref Unsafe.AsRef<byte>(_targetPointer), typeof(TTarget).TypeHandle)
                : _referenceTarget;
#else
            object? instance = _referenceTarget;
#endif

            if (instance is null)
                throw new InvalidOperationException("Target instance is null.");

            return _method.Invoke(instance, args);
        }
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6)
    {
        ThrowIfDisposed();

        if (!_isStatic && !IsValueType)
            return ((delegate* managed<TTarget, T1, T2, T3, T4, T5, T6, TResult>)_methodPtr)(Unsafe.As<object?, TTarget>(ref _referenceTarget), arg1, arg2, arg3, arg4, arg5, arg6);
        else if (IsValueType)
            return ((delegate* managed<ref TTarget, T1, T2, T3, T4, T5, T6, TResult>)_methodPtr)(ref Unsafe.AsRef<TTarget>(_targetPointer), arg1, arg2, arg3, arg4, arg5, arg6);
        else
            return ((delegate* managed<T1, T2, T3, T4, T5, T6, TResult>)_methodPtr)(arg1, arg2, arg3, arg4, arg5, arg6);
    }

    #endregion
    
    #region Auxiliary methods
    
    public TDelegate ToDelegate<TDelegate>()
        where TDelegate : Delegate
    {
        ThrowIfDisposed();
        if (_isStatic)
        {
            return (TDelegate)Delegate.CreateDelegate(typeof(TDelegate), _method);
        }
        else
        {
            if (typeof(TTarget).IsByRefLike)
                throw new ArgumentException("The target type is a by-ref-like type and cannot be converted to a delegate.");
            
#if !NET9_0_OR_GREATER
            if (IsValueType)
                throw new ArgumentException("The target type is value type and cannot be converted to a delegate.");
#endif

#if NET9_0_OR_GREATER
            object? instance = IsValueType 
                ? RuntimeHelpers.Box(ref Unsafe.AsRef<byte>(_targetPointer), typeof(TTarget).TypeHandle)
                : _referenceTarget;
#else
            object? instance = _referenceTarget;
#endif
            
            if (instance is null)
                throw new InvalidOperationException("Target instance is null.");
            
            return (TDelegate)Delegate.CreateDelegate(typeof(TDelegate), instance, _method);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void ThrowIfDisposed()
    {
        if (_disposed)
            throw new ObjectDisposedException(nameof(LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, TResult>));
    }
    
    #endregion
    
    #region Static Type Hash

    private static readonly int TypeHash = ComputeTypeHash();
    private static readonly int TargetTypeHash = TargetTypeHandle.GetHashCode();
    private static readonly RuntimeTypeHandle TargetTypeHandle = typeof(TTarget).TypeHandle;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static int ComputeTypeHash()
    {
        unchecked
        {
            int h = (int)2166136261;
            h = (h * 16777619) ^ typeof(TResult).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T1).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T2).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T3).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T4).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T5).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T6).TypeHandle.GetHashCode();
            return h;
        }
    }

    #endregion

    #region Method Caching

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static MethodCache GetCachedMethod(scoped in RuntimeTypeHandle type, string methodName, int nameHash = 0)
    {
        nameHash = nameHash is 0 ? StringComparer.Ordinal.GetHashCode(methodName) : nameHash;
        int key = type.Equals(TargetTypeHandle)
                      ? TypeHash ^ nameHash ^ TargetTypeHash
                      : TypeHash ^ nameHash ^ type.GetHashCode();
       
        if (!Methods.TryGetValue(key, out var result))
        {
            const BindingFlags flags = BindingFlags.Public | BindingFlags.NonPublic |
                                       BindingFlags.Instance | BindingFlags.Static;
    
            Type[] paramTypes = [ typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6) ];

#if NET8_0_OR_GREATER
            var method = Type.GetTypeFromHandle(type)!.GetMethod(methodName, flags, paramTypes)
                         ?? throw new MissingMethodException($"Method {methodName} not found on {Type.GetTypeFromHandle(type)!}");
#else
            var method = Type.GetTypeFromHandle(type)!.GetMethod(methodName, flags, null, paramTypes, null)
                         ?? throw new MissingMethodException($"Method {methodName} not found on {Type.GetTypeFromHandle(type)!}");
#endif
            result = new MethodCache(method.IsStatic, method.MethodHandle.GetFunctionPointer(), method);

            Methods.TryAdd(key, result);
        }

        return result;
    }
    
    #endregion
}

public unsafe struct LuminFunction<
#if NET8_0_OR_GREATER
[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)]
#endif
TTarget, T1, T2, T3, T4, T5, T6, T7, TResult> : IDisposable, ICloneable, ISerializable, IEquatable<LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, TResult>>
#if NET9_0_OR_GREATER
    where TTarget : allows ref struct
    where TResult : allows ref struct
    where T1 : allows ref struct
    where T2 : allows ref struct
    where T3 : allows ref struct
    where T4 : allows ref struct
    where T5 : allows ref struct
    where T6 : allows ref struct
    where T7 : allows ref struct
#endif
{
    private void* _targetPointer; 
    private object? _referenceTarget; 
    private readonly IntPtr _methodPtr;
    private readonly bool _isStatic;
    private readonly MethodInfo _method;
    private bool _disposed;

    private static readonly bool IsValueType = typeof(TTarget).IsValueType;
    
    public TTarget? Target
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            ThrowIfDisposed();
            
            if (_isStatic)
                return default;
            
            if (IsValueType)
                return Unsafe.AsRef<TTarget?>(_targetPointer);
            
            var target = _referenceTarget;
            return Unsafe.As<object?, TTarget?>(ref target);
        }
    }
    
    public MethodInfo Method => _method;

    #region Constructors
    
    private LuminFunction(MethodCache method)
    {
        _method = method.MethodBase ?? throw new ArgumentNullException(nameof(method));
        _isStatic = method.IsStatic;
        _methodPtr = method.MethodPtr;

        if (!_isStatic)
            throw new ArgumentException("methods are not static!", method.MethodBase.Name);
        
        _referenceTarget = null;
        _targetPointer = null;
    }
    
    private LuminFunction(scoped ref TTarget? target, MethodCache method)
    {
        _method = method.MethodBase ?? throw new ArgumentNullException(nameof(method));
        _isStatic = method.IsStatic;
        _methodPtr = method.MethodPtr;
        _referenceTarget = null;

        if (!_isStatic)
        {
            if (IsValueType)
            {
#if NET8_0_OR_GREATER
                if (Unsafe.IsNullRef(ref target))
                    throw new ArgumentException("Target value instance cannot be null.", nameof(target));
#endif                

#if NET8_0_OR_GREATER
                _targetPointer = NativeMemory.Alloc((nuint)Unsafe.SizeOf<TTarget>());
#else
                _targetPointer = Marshal.AllocHGlobal(Unsafe.SizeOf<TTarget>()).ToPointer();
#endif
                Unsafe.CopyBlock(
                    _targetPointer,
                    Unsafe.AsPointer(ref target),
                    (uint)Unsafe.SizeOf<TTarget>()
                );
            }
            else
            {
                if (target is null)
                    throw new ArgumentException("Target instance object is null.", nameof(target));
                
                _referenceTarget = Unsafe.As<TTarget, object?>(ref target);
                
            }
        }
        else
        {
            _targetPointer = null;
        }
    }
    
    private LuminFunction(Delegate @delegate)
    {
        _method = @delegate.Method ?? throw new ArgumentNullException(nameof(@delegate.Method));
        _isStatic = @delegate.Method.IsStatic;
        _methodPtr = @delegate.Method.MethodHandle.GetFunctionPointer();
        _referenceTarget = null;
        
        var target = @delegate.Target;
        if (!_isStatic)
        {
            if (target is not TTarget)
                throw new ArgumentException("Target instance object is not type.", typeof(TTarget).Name);
                
            if (IsValueType)
            {
#if NET8_0_OR_GREATER
                if (Unsafe.IsNullRef(ref target))
                    throw new ArgumentException("Target value instance cannot be null.", nameof(target));
#endif
                
                var unboxedTarget = Unsafe.AsRef<TTarget>(Unsafe.AsPointer(ref target));
                
#if NET8_0_OR_GREATER
                _targetPointer = NativeMemory.Alloc((nuint)Unsafe.SizeOf<TTarget>());
#else
                _targetPointer = Marshal.AllocHGlobal(Unsafe.SizeOf<TTarget>()).ToPointer();
#endif
                Unsafe.CopyBlock(
                    _targetPointer,
                    Unsafe.AsPointer(ref unboxedTarget),
                    (uint)Unsafe.SizeOf<TTarget>()
                );
            }
            else
            {
                if (target is null)
                    throw new ArgumentException("Target instance object is null.", nameof(target));
                
                _referenceTarget = target;
            }
        }
        else
        {
            _targetPointer = null;
        }
    }

    #endregion
    
    #region Create Factory

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, TResult> Create(scoped ref TTarget? target, string methodName, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(IsValueType
                ? TargetTypeHandle
                : Unsafe.As<TTarget, object?>(ref target!)?.GetType().TypeHandle ?? TargetTypeHandle,
            methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        return new LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, TResult>(ref target, method);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, TResult> Create(scoped ref TTarget? target, string methodName, Type targetType, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(targetType.TypeHandle, methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        return new LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, TResult>(ref target, method);
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, TResult> Create(scoped ref TTarget? target, ReadOnlySpan<char> methodName, int methodNameHash = 0) =>
        Create(ref target, methodName.ToString(), methodNameHash);
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, TResult> Create(scoped ref TTarget? target, ReadOnlySpan<char> methodName, Type targetType, int methodNameHash = 0) =>
        Create(ref target, methodName.ToString(), targetType, methodNameHash);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, TResult> Create(Delegate @delegate) => 
        new LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, TResult>(@delegate);
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, TResult> Create(string methodName, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(TargetTypeHandle, methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        if (!method.IsStatic)
            throw new ArgumentException("Method is not static, please pass in instance as parameter.", nameof(methodName));
        
        return new LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, TResult>(method);
    }

    #endregion
    
    #region Interface Implementation

    public void Dispose()
    {
        if (_disposed)
            return;
        
        
        if (IsValueType && !_isStatic && _targetPointer != null)
        {
#if NET8_0_OR_GREATER
            NativeMemory.Free(_targetPointer);
#else
            Marshal.FreeHGlobal(new IntPtr(_targetPointer));
#endif
        }
       
        _targetPointer = null;
        _referenceTarget = null;

        _disposed = true;
    }
    
    public object Clone()
    {
        ThrowIfDisposed();
        var target = _referenceTarget;
        if (target is null)
            throw new NullReferenceException("Target instance cannot be null.");
                
        return new LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, TResult>(ref Unsafe.As<object?, TTarget>(ref target)!, new MethodCache(_isStatic, _methodPtr, _method));
    }

    public void GetObjectData(SerializationInfo info, StreamingContext context)
    {
        throw new NotSupportedException();
    }
    
    public override bool Equals(object? obj)
    {
        return obj is LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, TResult> other && Equals(other);
    }

    public bool Equals(LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, TResult> other)
    {
        ThrowIfDisposed();
        return _methodPtr == other._methodPtr &&
               _isStatic == other._isStatic &&
               _targetPointer == other._targetPointer;
    }

    public override int GetHashCode()
    {
        ThrowIfDisposed();
        unchecked
        {
            int hash = 17;
            hash = hash * 31 + _methodPtr.GetHashCode();
            hash = hash * 31 + _isStatic.GetHashCode();
            hash = hash * 31 + ((IntPtr)_targetPointer).GetHashCode();
            return hash;
        }
    }

    #endregion
    
    #region Implicit
    
    public static implicit operator LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, TResult>(in Delegate func) 
        => Create(func);

    public static implicit operator LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, TResult>(Func<T1, T2, T3, T4, T5, T6, T7, TResult> func) => 
        Create(func);
    
    #endregion

    #region Invoke

    public object? DynamicInvoke(params object?[] args)
    {
        ThrowIfDisposed();
        
        if (_isStatic)
        {
            return _method.Invoke(null, args);
        }
        else
        {
            if (typeof(TTarget).IsByRefLike)
                throw new ArgumentException(
                    "The target type is a by-ref-like type and cannot be converted to a delegate.");

#if !NET9_0_OR_GREATER
            if (IsValueType)
                throw new ArgumentException("The target type is value type and cannot dynamic invoke.");
#endif

#if NET9_0_OR_GREATER
            object? instance = IsValueType
                ? RuntimeHelpers.Box(ref Unsafe.AsRef<byte>(_targetPointer), typeof(TTarget).TypeHandle)
                : _referenceTarget;
#else
            object? instance = _referenceTarget;
#endif

            if (instance is null)
                throw new InvalidOperationException("Target instance is null.");

            return _method.Invoke(instance, args);
        }
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7)
    {
        ThrowIfDisposed();

        if (!_isStatic && !IsValueType)
            return ((delegate* managed<TTarget, T1, T2, T3, T4, T5, T6, T7, TResult>)_methodPtr)(Unsafe.As<object?, TTarget>(ref _referenceTarget), arg1, arg2, arg3, arg4, arg5, arg6, arg7);
        else if (IsValueType)
            return ((delegate* managed<ref TTarget, T1, T2, T3, T4, T5, T6, T7, TResult>)_methodPtr)(ref Unsafe.AsRef<TTarget>(_targetPointer), arg1, arg2, arg3, arg4, arg5, arg6, arg7);
        else
            return ((delegate* managed<T1, T2, T3, T4, T5, T6, T7, TResult>)_methodPtr)(arg1, arg2, arg3, arg4, arg5, arg6, arg7);
    }

    #endregion
    
    #region Auxiliary methods
    
    public TDelegate ToDelegate<TDelegate>()
        where TDelegate : Delegate
    {
        ThrowIfDisposed();
        if (_isStatic)
        {
            return (TDelegate)Delegate.CreateDelegate(typeof(TDelegate), _method);
        }
        else
        {
            if (typeof(TTarget).IsByRefLike)
                throw new ArgumentException("The target type is a by-ref-like type and cannot be converted to a delegate.");
            
#if !NET9_0_OR_GREATER
            if (IsValueType)
                throw new ArgumentException("The target type is value type and cannot be converted to a delegate.");
#endif

#if NET9_0_OR_GREATER
            object? instance = IsValueType 
                ? RuntimeHelpers.Box(ref Unsafe.AsRef<byte>(_targetPointer), typeof(TTarget).TypeHandle)
                : _referenceTarget;
#else
            object? instance = _referenceTarget;
#endif
            
            if (instance is null)
                throw new InvalidOperationException("Target instance is null.");
            
            return (TDelegate)Delegate.CreateDelegate(typeof(TDelegate), instance, _method);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void ThrowIfDisposed()
    {
        if (_disposed)
            throw new ObjectDisposedException(nameof(LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, TResult>));
    }
    
    #endregion
    
    #region Static Type Hash

    private static readonly int TypeHash = ComputeTypeHash();
    private static readonly int TargetTypeHash = TargetTypeHandle.GetHashCode();
    private static readonly RuntimeTypeHandle TargetTypeHandle = typeof(TTarget).TypeHandle;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static int ComputeTypeHash()
    {
        unchecked
        {
            int h = (int)2166136261;
            h = (h * 16777619) ^ typeof(TResult).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T1).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T2).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T3).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T4).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T5).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T6).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T7).TypeHandle.GetHashCode();
            return h;
        }
    }

    #endregion

    #region Method Caching

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static MethodCache GetCachedMethod(scoped in RuntimeTypeHandle type, string methodName, int nameHash = 0)
    {
        nameHash = nameHash is 0 ? StringComparer.Ordinal.GetHashCode(methodName) : nameHash;
        int key = type.Equals(TargetTypeHandle)
                      ? TypeHash ^ nameHash ^ TargetTypeHash
                      : TypeHash ^ nameHash ^ type.GetHashCode();
       
        if (!Methods.TryGetValue(key, out var result))
        {
            const BindingFlags flags = BindingFlags.Public | BindingFlags.NonPublic |
                                       BindingFlags.Instance | BindingFlags.Static;
    
            Type[] paramTypes = [ typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7) ];

#if NET8_0_OR_GREATER
            var method = Type.GetTypeFromHandle(type)!.GetMethod(methodName, flags, paramTypes)
                         ?? throw new MissingMethodException($"Method {methodName} not found on {Type.GetTypeFromHandle(type)!}");
#else
            var method = Type.GetTypeFromHandle(type)!.GetMethod(methodName, flags, null, paramTypes, null)
                         ?? throw new MissingMethodException($"Method {methodName} not found on {Type.GetTypeFromHandle(type)!}");
#endif
            result = new MethodCache(method.IsStatic, method.MethodHandle.GetFunctionPointer(), method);

            Methods.TryAdd(key, result);
        }

        return result;
    }
    
    #endregion
}

public unsafe struct LuminFunction<
#if NET8_0_OR_GREATER
[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)]
#endif
TTarget, T1, T2, T3, T4, T5, T6, T7, T8, TResult> : IDisposable, ICloneable, ISerializable, IEquatable<LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, TResult>>
#if NET9_0_OR_GREATER
    where TTarget : allows ref struct
    where TResult : allows ref struct
    where T1 : allows ref struct
    where T2 : allows ref struct
    where T3 : allows ref struct
    where T4 : allows ref struct
    where T5 : allows ref struct
    where T6 : allows ref struct
    where T7 : allows ref struct
    where T8 : allows ref struct
#endif
{
    private void* _targetPointer; 
    private object? _referenceTarget; 
    private readonly IntPtr _methodPtr;
    private readonly bool _isStatic;
    private readonly MethodInfo _method;
    private bool _disposed;

    private static readonly bool IsValueType = typeof(TTarget).IsValueType;
    
    public TTarget? Target
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            ThrowIfDisposed();
            
            if (_isStatic)
                return default;
            
            if (IsValueType)
                return Unsafe.AsRef<TTarget?>(_targetPointer);
            
            var target = _referenceTarget;
            return Unsafe.As<object?, TTarget?>(ref target);
        }
    }
    
    public MethodInfo Method => _method;

    #region Constructors
    
    private LuminFunction(MethodCache method)
    {
        _method = method.MethodBase ?? throw new ArgumentNullException(nameof(method));
        _isStatic = method.IsStatic;
        _methodPtr = method.MethodPtr;

        if (!_isStatic)
            throw new ArgumentException("methods are not static!", method.MethodBase.Name);
        
        _referenceTarget = null;
        _targetPointer = null;
    }
    
    private LuminFunction(scoped ref TTarget? target, MethodCache method)
    {
        _method = method.MethodBase ?? throw new ArgumentNullException(nameof(method));
        _isStatic = method.IsStatic;
        _methodPtr = method.MethodPtr;
        _referenceTarget = null;

        if (!_isStatic)
        {
            if (IsValueType)
            {
#if NET8_0_OR_GREATER
                if (Unsafe.IsNullRef(ref target))
                    throw new ArgumentException("Target value instance cannot be null.", nameof(target));
#endif                

#if NET8_0_OR_GREATER
                _targetPointer = NativeMemory.Alloc((nuint)Unsafe.SizeOf<TTarget>());
#else
                _targetPointer = Marshal.AllocHGlobal(Unsafe.SizeOf<TTarget>()).ToPointer();
#endif
                Unsafe.CopyBlock(
                    _targetPointer,
                    Unsafe.AsPointer(ref target),
                    (uint)Unsafe.SizeOf<TTarget>()
                );
            }
            else
            {
                if (target is null)
                    throw new ArgumentException("Target instance object is null.", nameof(target));
                
                _referenceTarget = Unsafe.As<TTarget, object?>(ref target);
                
            }
        }
        else
        {
            _targetPointer = null;
        }
    }
    
    private LuminFunction(Delegate @delegate)
    {
        _method = @delegate.Method ?? throw new ArgumentNullException(nameof(@delegate.Method));
        _isStatic = @delegate.Method.IsStatic;
        _methodPtr = @delegate.Method.MethodHandle.GetFunctionPointer();
        _referenceTarget = null;
        
        var target = @delegate.Target;
        if (!_isStatic)
        {
            if (target is not TTarget)
                throw new ArgumentException("Target instance object is not type.", typeof(TTarget).Name);
                
            if (IsValueType)
            {
#if NET8_0_OR_GREATER
                if (Unsafe.IsNullRef(ref target))
                    throw new ArgumentException("Target value instance cannot be null.", nameof(target));
#endif
                
                var unboxedTarget = Unsafe.AsRef<TTarget>(Unsafe.AsPointer(ref target));
                
#if NET8_0_OR_GREATER
                _targetPointer = NativeMemory.Alloc((nuint)Unsafe.SizeOf<TTarget>());
#else
                _targetPointer = Marshal.AllocHGlobal(Unsafe.SizeOf<TTarget>()).ToPointer();
#endif
                Unsafe.CopyBlock(
                    _targetPointer,
                    Unsafe.AsPointer(ref unboxedTarget),
                    (uint)Unsafe.SizeOf<TTarget>()
                );
            }
            else
            {
                if (target is null)
                    throw new ArgumentException("Target instance object is null.", nameof(target));
                
                _referenceTarget = target;
            }
        }
        else
        {
            _targetPointer = null;
        }
    }

    #endregion
    
    #region Create Factory

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, TResult> Create(scoped ref TTarget? target, string methodName, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(IsValueType
                ? TargetTypeHandle
                : Unsafe.As<TTarget, object?>(ref target!)?.GetType().TypeHandle ?? TargetTypeHandle,
            methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        return new LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, TResult>(ref target, method);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, TResult> Create(scoped ref TTarget? target, string methodName, Type targetType, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(targetType.TypeHandle, methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        return new LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, TResult>(ref target, method);
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, TResult> Create(scoped ref TTarget? target, ReadOnlySpan<char> methodName, int methodNameHash = 0) =>
        Create(ref target, methodName.ToString(), methodNameHash);
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, TResult> Create(scoped ref TTarget? target, ReadOnlySpan<char> methodName, Type targetType, int methodNameHash = 0) =>
        Create(ref target, methodName.ToString(), targetType, methodNameHash);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, TResult> Create(Delegate @delegate) => 
        new LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, TResult>(@delegate);
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, TResult> Create(string methodName, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(TargetTypeHandle, methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        if (!method.IsStatic)
            throw new ArgumentException("Method is not static, please pass in instance as parameter.", nameof(methodName));
        
        return new LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, TResult>(method);
    }

    #endregion
    
    #region Interface Implementation

    public void Dispose()
    {
        if (_disposed)
            return;
        
        
        if (IsValueType && !_isStatic && _targetPointer != null)
        {
#if NET8_0_OR_GREATER
            NativeMemory.Free(_targetPointer);
#else
            Marshal.FreeHGlobal(new IntPtr(_targetPointer));
#endif
        }
       
        _targetPointer = null;
        _referenceTarget = null;

        _disposed = true;
    }
    
    public object Clone()
    {
        ThrowIfDisposed();
        var target = _referenceTarget;
        if (target is null)
            throw new NullReferenceException("Target instance cannot be null.");
                
        return new LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, TResult>(ref Unsafe.As<object?, TTarget>(ref target)!, new MethodCache(_isStatic, _methodPtr, _method));
    }

    public void GetObjectData(SerializationInfo info, StreamingContext context)
    {
        throw new NotSupportedException();
    }
    
    public override bool Equals(object? obj)
    {
        return obj is LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, TResult> other && Equals(other);
    }

    public bool Equals(LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, TResult> other)
    {
        ThrowIfDisposed();
        return _methodPtr == other._methodPtr &&
               _isStatic == other._isStatic &&
               _targetPointer == other._targetPointer;
    }

    public override int GetHashCode()
    {
        ThrowIfDisposed();
        unchecked
        {
            int hash = 17;
            hash = hash * 31 + _methodPtr.GetHashCode();
            hash = hash * 31 + _isStatic.GetHashCode();
            hash = hash * 31 + ((IntPtr)_targetPointer).GetHashCode();
            return hash;
        }
    }

    #endregion
    
    #region Implicit
    
    public static implicit operator LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, TResult>(in Delegate func) 
        => Create(func);

    public static implicit operator LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, TResult>(Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult> func) => 
        Create(func);
    
    #endregion

    #region Invoke

    public object? DynamicInvoke(params object?[] args)
    {
        ThrowIfDisposed();
        
        if (_isStatic)
        {
            return _method.Invoke(null, args);
        }
        else
        {
            if (typeof(TTarget).IsByRefLike)
                throw new ArgumentException(
                    "The target type is a by-ref-like type and cannot be converted to a delegate.");

#if !NET9_0_OR_GREATER
            if (IsValueType)
                throw new ArgumentException("The target type is value type and cannot dynamic invoke.");
#endif

#if NET9_0_OR_GREATER
            object? instance = IsValueType
                ? RuntimeHelpers.Box(ref Unsafe.AsRef<byte>(_targetPointer), typeof(TTarget).TypeHandle)
                : _referenceTarget;
#else
            object? instance = _referenceTarget;
#endif

            if (instance is null)
                throw new InvalidOperationException("Target instance is null.");

            return _method.Invoke(instance, args);
        }
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8)
    {
        ThrowIfDisposed();

        if (!_isStatic && !IsValueType)
            return ((delegate* managed<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, TResult>)_methodPtr)(Unsafe.As<object?, TTarget>(ref _referenceTarget), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
        else if (IsValueType)
            return ((delegate* managed<ref TTarget, T1, T2, T3, T4, T5, T6, T7, T8, TResult>)_methodPtr)(ref Unsafe.AsRef<TTarget>(_targetPointer), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
        else
            return ((delegate* managed<T1, T2, T3, T4, T5, T6, T7, T8, TResult>)_methodPtr)(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
    }

    #endregion
    
    #region Auxiliary methods
    
    public TDelegate ToDelegate<TDelegate>()
        where TDelegate : Delegate
    {
        ThrowIfDisposed();
        if (_isStatic)
        {
            return (TDelegate)Delegate.CreateDelegate(typeof(TDelegate), _method);
        }
        else
        {
            if (typeof(TTarget).IsByRefLike)
                throw new ArgumentException("The target type is a by-ref-like type and cannot be converted to a delegate.");
            
#if !NET9_0_OR_GREATER
            if (IsValueType)
                throw new ArgumentException("The target type is value type and cannot be converted to a delegate.");
#endif

#if NET9_0_OR_GREATER
            object? instance = IsValueType 
                ? RuntimeHelpers.Box(ref Unsafe.AsRef<byte>(_targetPointer), typeof(TTarget).TypeHandle)
                : _referenceTarget;
#else
            object? instance = _referenceTarget;
#endif
            
            if (instance is null)
                throw new InvalidOperationException("Target instance is null.");
            
            return (TDelegate)Delegate.CreateDelegate(typeof(TDelegate), instance, _method);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void ThrowIfDisposed()
    {
        if (_disposed)
            throw new ObjectDisposedException(nameof(LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, TResult>));
    }
    
    #endregion
    
    #region Static Type Hash

    private static readonly int TypeHash = ComputeTypeHash();
    private static readonly int TargetTypeHash = TargetTypeHandle.GetHashCode();
    private static readonly RuntimeTypeHandle TargetTypeHandle = typeof(TTarget).TypeHandle;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static int ComputeTypeHash()
    {
        unchecked
        {
            int h = (int)2166136261;
            h = (h * 16777619) ^ typeof(TResult).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T1).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T2).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T3).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T4).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T5).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T6).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T7).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T8).TypeHandle.GetHashCode();
            return h;
        }
    }

    #endregion

    #region Method Caching

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static MethodCache GetCachedMethod(scoped in RuntimeTypeHandle type, string methodName, int nameHash = 0)
    {
        nameHash = nameHash is 0 ? StringComparer.Ordinal.GetHashCode(methodName) : nameHash;
        int key = type.Equals(TargetTypeHandle)
                      ? TypeHash ^ nameHash ^ TargetTypeHash
                      : TypeHash ^ nameHash ^ type.GetHashCode();
       
        if (!Methods.TryGetValue(key, out var result))
        {
            const BindingFlags flags = BindingFlags.Public | BindingFlags.NonPublic |
                                       BindingFlags.Instance | BindingFlags.Static;
    
            Type[] paramTypes = [ typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8) ];

#if NET8_0_OR_GREATER
            var method = Type.GetTypeFromHandle(type)!.GetMethod(methodName, flags, paramTypes)
                         ?? throw new MissingMethodException($"Method {methodName} not found on {Type.GetTypeFromHandle(type)!}");
#else
            var method = Type.GetTypeFromHandle(type)!.GetMethod(methodName, flags, null, paramTypes, null)
                         ?? throw new MissingMethodException($"Method {methodName} not found on {Type.GetTypeFromHandle(type)!}");
#endif
            result = new MethodCache(method.IsStatic, method.MethodHandle.GetFunctionPointer(), method);

            Methods.TryAdd(key, result);
        }

        return result;
    }
    
    #endregion
}

public unsafe struct LuminFunction<
#if NET8_0_OR_GREATER
[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)]
#endif
TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> : IDisposable, ICloneable, ISerializable, IEquatable<LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>>
#if NET9_0_OR_GREATER
    where TTarget : allows ref struct
    where TResult : allows ref struct
    where T1 : allows ref struct
    where T2 : allows ref struct
    where T3 : allows ref struct
    where T4 : allows ref struct
    where T5 : allows ref struct
    where T6 : allows ref struct
    where T7 : allows ref struct
    where T8 : allows ref struct
    where T9 : allows ref struct
#endif
{
    private void* _targetPointer; 
    private object? _referenceTarget; 
    private readonly IntPtr _methodPtr;
    private readonly bool _isStatic;
    private readonly MethodInfo _method;
    private bool _disposed;

    private static readonly bool IsValueType = typeof(TTarget).IsValueType;
    
    public TTarget? Target
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            ThrowIfDisposed();
            
            if (_isStatic)
                return default;
            
            if (IsValueType)
                return Unsafe.AsRef<TTarget?>(_targetPointer);
            
            var target = _referenceTarget;
            return Unsafe.As<object?, TTarget?>(ref target);
        }
    }
    
    public MethodInfo Method => _method;

    #region Constructors
    
    private LuminFunction(MethodCache method)
    {
        _method = method.MethodBase ?? throw new ArgumentNullException(nameof(method));
        _isStatic = method.IsStatic;
        _methodPtr = method.MethodPtr;

        if (!_isStatic)
            throw new ArgumentException("methods are not static!", method.MethodBase.Name);
        
        _referenceTarget = null;
        _targetPointer = null;
    }
    
    private LuminFunction(scoped ref TTarget? target, MethodCache method)
    {
        _method = method.MethodBase ?? throw new ArgumentNullException(nameof(method));
        _isStatic = method.IsStatic;
        _methodPtr = method.MethodPtr;
        _referenceTarget = null;

        if (!_isStatic)
        {
            if (IsValueType)
            {
#if NET8_0_OR_GREATER
                if (Unsafe.IsNullRef(ref target))
                    throw new ArgumentException("Target value instance cannot be null.", nameof(target));
#endif                

#if NET8_0_OR_GREATER
                _targetPointer = NativeMemory.Alloc((nuint)Unsafe.SizeOf<TTarget>());
#else
                _targetPointer = Marshal.AllocHGlobal(Unsafe.SizeOf<TTarget>()).ToPointer();
#endif
                Unsafe.CopyBlock(
                    _targetPointer,
                    Unsafe.AsPointer(ref target),
                    (uint)Unsafe.SizeOf<TTarget>()
                );
            }
            else
            {
                if (target is null)
                    throw new ArgumentException("Target instance object is null.", nameof(target));
                
                _referenceTarget = Unsafe.As<TTarget, object?>(ref target);
                
            }
        }
        else
        {
            _targetPointer = null;
        }
    }
    
    private LuminFunction(Delegate @delegate)
    {
        _method = @delegate.Method ?? throw new ArgumentNullException(nameof(@delegate.Method));
        _isStatic = @delegate.Method.IsStatic;
        _methodPtr = @delegate.Method.MethodHandle.GetFunctionPointer();
        _referenceTarget = null;
        
        var target = @delegate.Target;
        if (!_isStatic)
        {
            if (target is not TTarget)
                throw new ArgumentException("Target instance object is not type.", typeof(TTarget).Name);
                
            if (IsValueType)
            {
#if NET8_0_OR_GREATER
                if (Unsafe.IsNullRef(ref target))
                    throw new ArgumentException("Target value instance cannot be null.", nameof(target));
#endif
                
                var unboxedTarget = Unsafe.AsRef<TTarget>(Unsafe.AsPointer(ref target));
                
#if NET8_0_OR_GREATER
                _targetPointer = NativeMemory.Alloc((nuint)Unsafe.SizeOf<TTarget>());
#else
                _targetPointer = Marshal.AllocHGlobal(Unsafe.SizeOf<TTarget>()).ToPointer();
#endif
                Unsafe.CopyBlock(
                    _targetPointer,
                    Unsafe.AsPointer(ref unboxedTarget),
                    (uint)Unsafe.SizeOf<TTarget>()
                );
            }
            else
            {
                if (target is null)
                    throw new ArgumentException("Target instance object is null.", nameof(target));
                
                _referenceTarget = target;
            }
        }
        else
        {
            _targetPointer = null;
        }
    }

    #endregion
    
    #region Create Factory

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> Create(scoped ref TTarget? target, string methodName, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(IsValueType
                ? TargetTypeHandle
                : Unsafe.As<TTarget, object?>(ref target!)?.GetType().TypeHandle ?? TargetTypeHandle,
            methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        return new LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(ref target, method);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> Create(scoped ref TTarget? target, string methodName, Type targetType, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(targetType.TypeHandle, methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        return new LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(ref target, method);
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> Create(scoped ref TTarget? target, ReadOnlySpan<char> methodName, int methodNameHash = 0) =>
        Create(ref target, methodName.ToString(), methodNameHash);
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> Create(scoped ref TTarget? target, ReadOnlySpan<char> methodName, Type targetType, int methodNameHash = 0) =>
        Create(ref target, methodName.ToString(), targetType, methodNameHash);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> Create(Delegate @delegate) => 
        new LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(@delegate);
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> Create(string methodName, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(TargetTypeHandle, methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        if (!method.IsStatic)
            throw new ArgumentException("Method is not static, please pass in instance as parameter.", nameof(methodName));
        
        return new LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(method);
    }

    #endregion
    
    #region Interface Implementation

    public void Dispose()
    {
        if (_disposed)
            return;
        
        
        if (IsValueType && !_isStatic && _targetPointer != null)
        {
#if NET8_0_OR_GREATER
            NativeMemory.Free(_targetPointer);
#else
            Marshal.FreeHGlobal(new IntPtr(_targetPointer));
#endif
        }
       
        _targetPointer = null;
        _referenceTarget = null;

        _disposed = true;
    }
    
    public object Clone()
    {
        ThrowIfDisposed();
        var target = _referenceTarget;
        if (target is null)
            throw new NullReferenceException("Target instance cannot be null.");
                
        return new LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(ref Unsafe.As<object?, TTarget>(ref target)!, new MethodCache(_isStatic, _methodPtr, _method));
    }

    public void GetObjectData(SerializationInfo info, StreamingContext context)
    {
        throw new NotSupportedException();
    }
    
    public override bool Equals(object? obj)
    {
        return obj is LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> other && Equals(other);
    }

    public bool Equals(LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> other)
    {
        ThrowIfDisposed();
        return _methodPtr == other._methodPtr &&
               _isStatic == other._isStatic &&
               _targetPointer == other._targetPointer;
    }

    public override int GetHashCode()
    {
        ThrowIfDisposed();
        unchecked
        {
            int hash = 17;
            hash = hash * 31 + _methodPtr.GetHashCode();
            hash = hash * 31 + _isStatic.GetHashCode();
            hash = hash * 31 + ((IntPtr)_targetPointer).GetHashCode();
            return hash;
        }
    }

    #endregion
    
    #region Implicit
    
    public static implicit operator LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(in Delegate func) 
        => Create(func);

    public static implicit operator LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> func) => 
        Create(func);
    
    #endregion

    #region Invoke

    public object? DynamicInvoke(params object?[] args)
    {
        ThrowIfDisposed();
        
        if (_isStatic)
        {
            return _method.Invoke(null, args);
        }
        else
        {
            if (typeof(TTarget).IsByRefLike)
                throw new ArgumentException(
                    "The target type is a by-ref-like type and cannot be converted to a delegate.");

#if !NET9_0_OR_GREATER
            if (IsValueType)
                throw new ArgumentException("The target type is value type and cannot dynamic invoke.");
#endif

#if NET9_0_OR_GREATER
            object? instance = IsValueType
                ? RuntimeHelpers.Box(ref Unsafe.AsRef<byte>(_targetPointer), typeof(TTarget).TypeHandle)
                : _referenceTarget;
#else
            object? instance = _referenceTarget;
#endif

            if (instance is null)
                throw new InvalidOperationException("Target instance is null.");

            return _method.Invoke(instance, args);
        }
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9)
    {
        ThrowIfDisposed();

        if (!_isStatic && !IsValueType)
            return ((delegate* managed<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>)_methodPtr)(Unsafe.As<object?, TTarget>(ref _referenceTarget), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
        else if (IsValueType)
            return ((delegate* managed<ref TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>)_methodPtr)(ref Unsafe.AsRef<TTarget>(_targetPointer), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
        else
            return ((delegate* managed<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>)_methodPtr)(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
    }

    #endregion
    
    #region Auxiliary methods
    
    public TDelegate ToDelegate<TDelegate>()
        where TDelegate : Delegate
    {
        ThrowIfDisposed();
        if (_isStatic)
        {
            return (TDelegate)Delegate.CreateDelegate(typeof(TDelegate), _method);
        }
        else
        {
            if (typeof(TTarget).IsByRefLike)
                throw new ArgumentException("The target type is a by-ref-like type and cannot be converted to a delegate.");
            
#if !NET9_0_OR_GREATER
            if (IsValueType)
                throw new ArgumentException("The target type is value type and cannot be converted to a delegate.");
#endif

#if NET9_0_OR_GREATER
            object? instance = IsValueType 
                ? RuntimeHelpers.Box(ref Unsafe.AsRef<byte>(_targetPointer), typeof(TTarget).TypeHandle)
                : _referenceTarget;
#else
            object? instance = _referenceTarget;
#endif
            
            if (instance is null)
                throw new InvalidOperationException("Target instance is null.");
            
            return (TDelegate)Delegate.CreateDelegate(typeof(TDelegate), instance, _method);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void ThrowIfDisposed()
    {
        if (_disposed)
            throw new ObjectDisposedException(nameof(LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>));
    }
    
    #endregion
    
    #region Static Type Hash

    private static readonly int TypeHash = ComputeTypeHash();
    private static readonly int TargetTypeHash = TargetTypeHandle.GetHashCode();
    private static readonly RuntimeTypeHandle TargetTypeHandle = typeof(TTarget).TypeHandle;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static int ComputeTypeHash()
    {
        unchecked
        {
            int h = (int)2166136261;
            h = (h * 16777619) ^ typeof(TResult).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T1).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T2).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T3).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T4).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T5).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T6).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T7).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T8).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T9).TypeHandle.GetHashCode();
            return h;
        }
    }

    #endregion

    #region Method Caching

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static MethodCache GetCachedMethod(scoped in RuntimeTypeHandle type, string methodName, int nameHash = 0)
    {
        nameHash = nameHash is 0 ? StringComparer.Ordinal.GetHashCode(methodName) : nameHash;
        int key = type.Equals(TargetTypeHandle)
                      ? TypeHash ^ nameHash ^ TargetTypeHash
                      : TypeHash ^ nameHash ^ type.GetHashCode();
       
        if (!Methods.TryGetValue(key, out var result))
        {
            const BindingFlags flags = BindingFlags.Public | BindingFlags.NonPublic |
                                       BindingFlags.Instance | BindingFlags.Static;
    
            Type[] paramTypes = [ typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9) ];

#if NET8_0_OR_GREATER
            var method = Type.GetTypeFromHandle(type)!.GetMethod(methodName, flags, paramTypes)
                         ?? throw new MissingMethodException($"Method {methodName} not found on {Type.GetTypeFromHandle(type)!}");
#else
            var method = Type.GetTypeFromHandle(type)!.GetMethod(methodName, flags, null, paramTypes, null)
                         ?? throw new MissingMethodException($"Method {methodName} not found on {Type.GetTypeFromHandle(type)!}");
#endif
            result = new MethodCache(method.IsStatic, method.MethodHandle.GetFunctionPointer(), method);

            Methods.TryAdd(key, result);
        }

        return result;
    }
    
    #endregion
}

public unsafe struct LuminFunction<
#if NET8_0_OR_GREATER
[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)]
#endif
TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> : IDisposable, ICloneable, ISerializable, IEquatable<LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>>
#if NET9_0_OR_GREATER
    where TTarget : allows ref struct
    where TResult : allows ref struct
    where T1 : allows ref struct
    where T2 : allows ref struct
    where T3 : allows ref struct
    where T4 : allows ref struct
    where T5 : allows ref struct
    where T6 : allows ref struct
    where T7 : allows ref struct
    where T8 : allows ref struct
    where T9 : allows ref struct
    where T10 : allows ref struct
#endif
{
    private void* _targetPointer; 
    private object? _referenceTarget; 
    private readonly IntPtr _methodPtr;
    private readonly bool _isStatic;
    private readonly MethodInfo _method;
    private bool _disposed;

    private static readonly bool IsValueType = typeof(TTarget).IsValueType;
    
    public TTarget? Target
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            ThrowIfDisposed();
            
            if (_isStatic)
                return default;
            
            if (IsValueType)
                return Unsafe.AsRef<TTarget?>(_targetPointer);
            
            var target = _referenceTarget;
            return Unsafe.As<object?, TTarget?>(ref target);
        }
    }
    
    public MethodInfo Method => _method;

    #region Constructors
    
    private LuminFunction(MethodCache method)
    {
        _method = method.MethodBase ?? throw new ArgumentNullException(nameof(method));
        _isStatic = method.IsStatic;
        _methodPtr = method.MethodPtr;

        if (!_isStatic)
            throw new ArgumentException("methods are not static!", method.MethodBase.Name);
        
        _referenceTarget = null;
        _targetPointer = null;
    }
    
    private LuminFunction(scoped ref TTarget? target, MethodCache method)
    {
        _method = method.MethodBase ?? throw new ArgumentNullException(nameof(method));
        _isStatic = method.IsStatic;
        _methodPtr = method.MethodPtr;
        _referenceTarget = null;

        if (!_isStatic)
        {
            if (IsValueType)
            {
#if NET8_0_OR_GREATER
                if (Unsafe.IsNullRef(ref target))
                    throw new ArgumentException("Target value instance cannot be null.", nameof(target));
#endif                

#if NET8_0_OR_GREATER
                _targetPointer = NativeMemory.Alloc((nuint)Unsafe.SizeOf<TTarget>());
#else
                _targetPointer = Marshal.AllocHGlobal(Unsafe.SizeOf<TTarget>()).ToPointer();
#endif
                Unsafe.CopyBlock(
                    _targetPointer,
                    Unsafe.AsPointer(ref target),
                    (uint)Unsafe.SizeOf<TTarget>()
                );
            }
            else
            {
                if (target is null)
                    throw new ArgumentException("Target instance object is null.", nameof(target));
                
                _referenceTarget = Unsafe.As<TTarget, object?>(ref target);
                
            }
        }
        else
        {
            _targetPointer = null;
        }
    }
    
    private LuminFunction(Delegate @delegate)
    {
        _method = @delegate.Method ?? throw new ArgumentNullException(nameof(@delegate.Method));
        _isStatic = @delegate.Method.IsStatic;
        _methodPtr = @delegate.Method.MethodHandle.GetFunctionPointer();
        _referenceTarget = null;
        
        var target = @delegate.Target;
        if (!_isStatic)
        {
            if (target is not TTarget)
                throw new ArgumentException("Target instance object is not type.", typeof(TTarget).Name);
                
            if (IsValueType)
            {
#if NET8_0_OR_GREATER
                if (Unsafe.IsNullRef(ref target))
                    throw new ArgumentException("Target value instance cannot be null.", nameof(target));
#endif
                
                var unboxedTarget = Unsafe.AsRef<TTarget>(Unsafe.AsPointer(ref target));
                
#if NET8_0_OR_GREATER
                _targetPointer = NativeMemory.Alloc((nuint)Unsafe.SizeOf<TTarget>());
#else
                _targetPointer = Marshal.AllocHGlobal(Unsafe.SizeOf<TTarget>()).ToPointer();
#endif
                Unsafe.CopyBlock(
                    _targetPointer,
                    Unsafe.AsPointer(ref unboxedTarget),
                    (uint)Unsafe.SizeOf<TTarget>()
                );
            }
            else
            {
                if (target is null)
                    throw new ArgumentException("Target instance object is null.", nameof(target));
                
                _referenceTarget = target;
            }
        }
        else
        {
            _targetPointer = null;
        }
    }

    #endregion
    
    #region Create Factory

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> Create(scoped ref TTarget? target, string methodName, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(IsValueType
                ? TargetTypeHandle
                : Unsafe.As<TTarget, object?>(ref target!)?.GetType().TypeHandle ?? TargetTypeHandle,
            methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        return new LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(ref target, method);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> Create(scoped ref TTarget? target, string methodName, Type targetType, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(targetType.TypeHandle, methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        return new LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(ref target, method);
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> Create(scoped ref TTarget? target, ReadOnlySpan<char> methodName, int methodNameHash = 0) =>
        Create(ref target, methodName.ToString(), methodNameHash);
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> Create(scoped ref TTarget? target, ReadOnlySpan<char> methodName, Type targetType, int methodNameHash = 0) =>
        Create(ref target, methodName.ToString(), targetType, methodNameHash);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> Create(Delegate @delegate) => 
        new LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(@delegate);
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> Create(string methodName, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(TargetTypeHandle, methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        if (!method.IsStatic)
            throw new ArgumentException("Method is not static, please pass in instance as parameter.", nameof(methodName));
        
        return new LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(method);
    }

    #endregion
    
    #region Interface Implementation

    public void Dispose()
    {
        if (_disposed)
            return;
        
        
        if (IsValueType && !_isStatic && _targetPointer != null)
        {
#if NET8_0_OR_GREATER
            NativeMemory.Free(_targetPointer);
#else
            Marshal.FreeHGlobal(new IntPtr(_targetPointer));
#endif
        }
       
        _targetPointer = null;
        _referenceTarget = null;

        _disposed = true;
    }
    
    public object Clone()
    {
        ThrowIfDisposed();
        var target = _referenceTarget;
        if (target is null)
            throw new NullReferenceException("Target instance cannot be null.");
                
        return new LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(ref Unsafe.As<object?, TTarget>(ref target)!, new MethodCache(_isStatic, _methodPtr, _method));
    }

    public void GetObjectData(SerializationInfo info, StreamingContext context)
    {
        throw new NotSupportedException();
    }
    
    public override bool Equals(object? obj)
    {
        return obj is LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> other && Equals(other);
    }

    public bool Equals(LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> other)
    {
        ThrowIfDisposed();
        return _methodPtr == other._methodPtr &&
               _isStatic == other._isStatic &&
               _targetPointer == other._targetPointer;
    }

    public override int GetHashCode()
    {
        ThrowIfDisposed();
        unchecked
        {
            int hash = 17;
            hash = hash * 31 + _methodPtr.GetHashCode();
            hash = hash * 31 + _isStatic.GetHashCode();
            hash = hash * 31 + ((IntPtr)_targetPointer).GetHashCode();
            return hash;
        }
    }

    #endregion
    
    #region Implicit
    
    public static implicit operator LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(in Delegate func) 
        => Create(func);

    public static implicit operator LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> func) => 
        Create(func);
    
    #endregion

    #region Invoke

    public object? DynamicInvoke(params object?[] args)
    {
        ThrowIfDisposed();
        
        if (_isStatic)
        {
            return _method.Invoke(null, args);
        }
        else
        {
            if (typeof(TTarget).IsByRefLike)
                throw new ArgumentException(
                    "The target type is a by-ref-like type and cannot be converted to a delegate.");

#if !NET9_0_OR_GREATER
            if (IsValueType)
                throw new ArgumentException("The target type is value type and cannot dynamic invoke.");
#endif

#if NET9_0_OR_GREATER
            object? instance = IsValueType
                ? RuntimeHelpers.Box(ref Unsafe.AsRef<byte>(_targetPointer), typeof(TTarget).TypeHandle)
                : _referenceTarget;
#else
            object? instance = _referenceTarget;
#endif

            if (instance is null)
                throw new InvalidOperationException("Target instance is null.");

            return _method.Invoke(instance, args);
        }
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10)
    {
        ThrowIfDisposed();

        if (!_isStatic && !IsValueType)
            return ((delegate* managed<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>)_methodPtr)(Unsafe.As<object?, TTarget>(ref _referenceTarget), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
        else if (IsValueType)
            return ((delegate* managed<ref TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>)_methodPtr)(ref Unsafe.AsRef<TTarget>(_targetPointer), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
        else
            return ((delegate* managed<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>)_methodPtr)(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
    }

    #endregion
    
    #region Auxiliary methods
    
    public TDelegate ToDelegate<TDelegate>()
        where TDelegate : Delegate
    {
        ThrowIfDisposed();
        if (_isStatic)
        {
            return (TDelegate)Delegate.CreateDelegate(typeof(TDelegate), _method);
        }
        else
        {
            if (typeof(TTarget).IsByRefLike)
                throw new ArgumentException("The target type is a by-ref-like type and cannot be converted to a delegate.");
            
#if !NET9_0_OR_GREATER
            if (IsValueType)
                throw new ArgumentException("The target type is value type and cannot be converted to a delegate.");
#endif

#if NET9_0_OR_GREATER
            object? instance = IsValueType 
                ? RuntimeHelpers.Box(ref Unsafe.AsRef<byte>(_targetPointer), typeof(TTarget).TypeHandle)
                : _referenceTarget;
#else
            object? instance = _referenceTarget;
#endif
            
            if (instance is null)
                throw new InvalidOperationException("Target instance is null.");
            
            return (TDelegate)Delegate.CreateDelegate(typeof(TDelegate), instance, _method);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void ThrowIfDisposed()
    {
        if (_disposed)
            throw new ObjectDisposedException(nameof(LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>));
    }
    
    #endregion
    
    #region Static Type Hash

    private static readonly int TypeHash = ComputeTypeHash();
    private static readonly int TargetTypeHash = TargetTypeHandle.GetHashCode();
    private static readonly RuntimeTypeHandle TargetTypeHandle = typeof(TTarget).TypeHandle;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static int ComputeTypeHash()
    {
        unchecked
        {
            int h = (int)2166136261;
            h = (h * 16777619) ^ typeof(TResult).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T1).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T2).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T3).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T4).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T5).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T6).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T7).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T8).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T9).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T10).TypeHandle.GetHashCode();
            return h;
        }
    }

    #endregion

    #region Method Caching

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static MethodCache GetCachedMethod(scoped in RuntimeTypeHandle type, string methodName, int nameHash = 0)
    {
        nameHash = nameHash is 0 ? StringComparer.Ordinal.GetHashCode(methodName) : nameHash;
        int key = type.Equals(TargetTypeHandle)
                      ? TypeHash ^ nameHash ^ TargetTypeHash
                      : TypeHash ^ nameHash ^ type.GetHashCode();
       
        if (!Methods.TryGetValue(key, out var result))
        {
            const BindingFlags flags = BindingFlags.Public | BindingFlags.NonPublic |
                                       BindingFlags.Instance | BindingFlags.Static;
    
            Type[] paramTypes = [ typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10) ];

#if NET8_0_OR_GREATER
            var method = Type.GetTypeFromHandle(type)!.GetMethod(methodName, flags, paramTypes)
                         ?? throw new MissingMethodException($"Method {methodName} not found on {Type.GetTypeFromHandle(type)!}");
#else
            var method = Type.GetTypeFromHandle(type)!.GetMethod(methodName, flags, null, paramTypes, null)
                         ?? throw new MissingMethodException($"Method {methodName} not found on {Type.GetTypeFromHandle(type)!}");
#endif
            result = new MethodCache(method.IsStatic, method.MethodHandle.GetFunctionPointer(), method);

            Methods.TryAdd(key, result);
        }

        return result;
    }
    
    #endregion
}

public unsafe struct LuminFunction<
#if NET8_0_OR_GREATER
[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)]
#endif
TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> : IDisposable, ICloneable, ISerializable, IEquatable<LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>>
#if NET9_0_OR_GREATER
    where TTarget : allows ref struct
    where TResult : allows ref struct
    where T1 : allows ref struct
    where T2 : allows ref struct
    where T3 : allows ref struct
    where T4 : allows ref struct
    where T5 : allows ref struct
    where T6 : allows ref struct
    where T7 : allows ref struct
    where T8 : allows ref struct
    where T9 : allows ref struct
    where T10 : allows ref struct
    where T11 : allows ref struct
#endif
{
    private void* _targetPointer; 
    private object? _referenceTarget; 
    private readonly IntPtr _methodPtr;
    private readonly bool _isStatic;
    private readonly MethodInfo _method;
    private bool _disposed;

    private static readonly bool IsValueType = typeof(TTarget).IsValueType;
    
    public TTarget? Target
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            ThrowIfDisposed();
            
            if (_isStatic)
                return default;
            
            if (IsValueType)
                return Unsafe.AsRef<TTarget?>(_targetPointer);
            
            var target = _referenceTarget;
            return Unsafe.As<object?, TTarget?>(ref target);
        }
    }
    
    public MethodInfo Method => _method;

    #region Constructors
    
    private LuminFunction(MethodCache method)
    {
        _method = method.MethodBase ?? throw new ArgumentNullException(nameof(method));
        _isStatic = method.IsStatic;
        _methodPtr = method.MethodPtr;

        if (!_isStatic)
            throw new ArgumentException("methods are not static!", method.MethodBase.Name);
        
        _referenceTarget = null;
        _targetPointer = null;
    }
    
    private LuminFunction(scoped ref TTarget? target, MethodCache method)
    {
        _method = method.MethodBase ?? throw new ArgumentNullException(nameof(method));
        _isStatic = method.IsStatic;
        _methodPtr = method.MethodPtr;
        _referenceTarget = null;

        if (!_isStatic)
        {
            if (IsValueType)
            {
#if NET8_0_OR_GREATER
                if (Unsafe.IsNullRef(ref target))
                    throw new ArgumentException("Target value instance cannot be null.", nameof(target));
#endif                

#if NET8_0_OR_GREATER
                _targetPointer = NativeMemory.Alloc((nuint)Unsafe.SizeOf<TTarget>());
#else
                _targetPointer = Marshal.AllocHGlobal(Unsafe.SizeOf<TTarget>()).ToPointer();
#endif
                Unsafe.CopyBlock(
                    _targetPointer,
                    Unsafe.AsPointer(ref target),
                    (uint)Unsafe.SizeOf<TTarget>()
                );
            }
            else
            {
                if (target is null)
                    throw new ArgumentException("Target instance object is null.", nameof(target));
                
                _referenceTarget = Unsafe.As<TTarget, object?>(ref target);
                
            }
        }
        else
        {
            _targetPointer = null;
        }
    }
    
    private LuminFunction(Delegate @delegate)
    {
        _method = @delegate.Method ?? throw new ArgumentNullException(nameof(@delegate.Method));
        _isStatic = @delegate.Method.IsStatic;
        _methodPtr = @delegate.Method.MethodHandle.GetFunctionPointer();
        _referenceTarget = null;
        
        var target = @delegate.Target;
        if (!_isStatic)
        {
            if (target is not TTarget)
                throw new ArgumentException("Target instance object is not type.", typeof(TTarget).Name);
                
            if (IsValueType)
            {
#if NET8_0_OR_GREATER
                if (Unsafe.IsNullRef(ref target))
                    throw new ArgumentException("Target value instance cannot be null.", nameof(target));
#endif
                
                var unboxedTarget = Unsafe.AsRef<TTarget>(Unsafe.AsPointer(ref target));
                
#if NET8_0_OR_GREATER
                _targetPointer = NativeMemory.Alloc((nuint)Unsafe.SizeOf<TTarget>());
#else
                _targetPointer = Marshal.AllocHGlobal(Unsafe.SizeOf<TTarget>()).ToPointer();
#endif
                Unsafe.CopyBlock(
                    _targetPointer,
                    Unsafe.AsPointer(ref unboxedTarget),
                    (uint)Unsafe.SizeOf<TTarget>()
                );
            }
            else
            {
                if (target is null)
                    throw new ArgumentException("Target instance object is null.", nameof(target));
                
                _referenceTarget = target;
            }
        }
        else
        {
            _targetPointer = null;
        }
    }

    #endregion
    
    #region Create Factory

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> Create(scoped ref TTarget? target, string methodName, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(IsValueType
                ? TargetTypeHandle
                : Unsafe.As<TTarget, object?>(ref target!)?.GetType().TypeHandle ?? TargetTypeHandle,
            methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        return new LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(ref target, method);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> Create(scoped ref TTarget? target, string methodName, Type targetType, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(targetType.TypeHandle, methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        return new LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(ref target, method);
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> Create(scoped ref TTarget? target, ReadOnlySpan<char> methodName, int methodNameHash = 0) =>
        Create(ref target, methodName.ToString(), methodNameHash);
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> Create(scoped ref TTarget? target, ReadOnlySpan<char> methodName, Type targetType, int methodNameHash = 0) =>
        Create(ref target, methodName.ToString(), targetType, methodNameHash);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> Create(Delegate @delegate) => 
        new LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(@delegate);
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> Create(string methodName, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(TargetTypeHandle, methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        if (!method.IsStatic)
            throw new ArgumentException("Method is not static, please pass in instance as parameter.", nameof(methodName));
        
        return new LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(method);
    }

    #endregion
    
    #region Interface Implementation

    public void Dispose()
    {
        if (_disposed)
            return;
        
        
        if (IsValueType && !_isStatic && _targetPointer != null)
        {
#if NET8_0_OR_GREATER
            NativeMemory.Free(_targetPointer);
#else
            Marshal.FreeHGlobal(new IntPtr(_targetPointer));
#endif
        }
       
        _targetPointer = null;
        _referenceTarget = null;

        _disposed = true;
    }
    
    public object Clone()
    {
        ThrowIfDisposed();
        var target = _referenceTarget;
        if (target is null)
            throw new NullReferenceException("Target instance cannot be null.");
                
        return new LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(ref Unsafe.As<object?, TTarget>(ref target)!, new MethodCache(_isStatic, _methodPtr, _method));
    }

    public void GetObjectData(SerializationInfo info, StreamingContext context)
    {
        throw new NotSupportedException();
    }
    
    public override bool Equals(object? obj)
    {
        return obj is LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> other && Equals(other);
    }

    public bool Equals(LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> other)
    {
        ThrowIfDisposed();
        return _methodPtr == other._methodPtr &&
               _isStatic == other._isStatic &&
               _targetPointer == other._targetPointer;
    }

    public override int GetHashCode()
    {
        ThrowIfDisposed();
        unchecked
        {
            int hash = 17;
            hash = hash * 31 + _methodPtr.GetHashCode();
            hash = hash * 31 + _isStatic.GetHashCode();
            hash = hash * 31 + ((IntPtr)_targetPointer).GetHashCode();
            return hash;
        }
    }

    #endregion
    
    #region Implicit
    
    public static implicit operator LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(in Delegate func) 
        => Create(func);

    public static implicit operator LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> func) => 
        Create(func);
    
    #endregion

    #region Invoke

    public object? DynamicInvoke(params object?[] args)
    {
        ThrowIfDisposed();
        
        if (_isStatic)
        {
            return _method.Invoke(null, args);
        }
        else
        {
            if (typeof(TTarget).IsByRefLike)
                throw new ArgumentException(
                    "The target type is a by-ref-like type and cannot be converted to a delegate.");

#if !NET9_0_OR_GREATER
            if (IsValueType)
                throw new ArgumentException("The target type is value type and cannot dynamic invoke.");
#endif

#if NET9_0_OR_GREATER
            object? instance = IsValueType
                ? RuntimeHelpers.Box(ref Unsafe.AsRef<byte>(_targetPointer), typeof(TTarget).TypeHandle)
                : _referenceTarget;
#else
            object? instance = _referenceTarget;
#endif

            if (instance is null)
                throw new InvalidOperationException("Target instance is null.");

            return _method.Invoke(instance, args);
        }
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11)
    {
        ThrowIfDisposed();

        if (!_isStatic && !IsValueType)
            return ((delegate* managed<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>)_methodPtr)(Unsafe.As<object?, TTarget>(ref _referenceTarget), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11);
        else if (IsValueType)
            return ((delegate* managed<ref TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>)_methodPtr)(ref Unsafe.AsRef<TTarget>(_targetPointer), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11);
        else
            return ((delegate* managed<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>)_methodPtr)(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11);
    }

    #endregion
    
    #region Auxiliary methods
    
    public TDelegate ToDelegate<TDelegate>()
        where TDelegate : Delegate
    {
        ThrowIfDisposed();
        if (_isStatic)
        {
            return (TDelegate)Delegate.CreateDelegate(typeof(TDelegate), _method);
        }
        else
        {
            if (typeof(TTarget).IsByRefLike)
                throw new ArgumentException("The target type is a by-ref-like type and cannot be converted to a delegate.");
            
#if !NET9_0_OR_GREATER
            if (IsValueType)
                throw new ArgumentException("The target type is value type and cannot be converted to a delegate.");
#endif

#if NET9_0_OR_GREATER
            object? instance = IsValueType 
                ? RuntimeHelpers.Box(ref Unsafe.AsRef<byte>(_targetPointer), typeof(TTarget).TypeHandle)
                : _referenceTarget;
#else
            object? instance = _referenceTarget;
#endif
            
            if (instance is null)
                throw new InvalidOperationException("Target instance is null.");
            
            return (TDelegate)Delegate.CreateDelegate(typeof(TDelegate), instance, _method);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void ThrowIfDisposed()
    {
        if (_disposed)
            throw new ObjectDisposedException(nameof(LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>));
    }
    
    #endregion
    
    #region Static Type Hash

    private static readonly int TypeHash = ComputeTypeHash();
    private static readonly int TargetTypeHash = TargetTypeHandle.GetHashCode();
    private static readonly RuntimeTypeHandle TargetTypeHandle = typeof(TTarget).TypeHandle;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static int ComputeTypeHash()
    {
        unchecked
        {
            int h = (int)2166136261;
            h = (h * 16777619) ^ typeof(TResult).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T1).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T2).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T3).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T4).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T5).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T6).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T7).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T8).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T9).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T10).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T11).TypeHandle.GetHashCode();
            return h;
        }
    }

    #endregion

    #region Method Caching

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static MethodCache GetCachedMethod(scoped in RuntimeTypeHandle type, string methodName, int nameHash = 0)
    {
        nameHash = nameHash is 0 ? StringComparer.Ordinal.GetHashCode(methodName) : nameHash;
        int key = type.Equals(TargetTypeHandle)
                      ? TypeHash ^ nameHash ^ TargetTypeHash
                      : TypeHash ^ nameHash ^ type.GetHashCode();
       
        if (!Methods.TryGetValue(key, out var result))
        {
            const BindingFlags flags = BindingFlags.Public | BindingFlags.NonPublic |
                                       BindingFlags.Instance | BindingFlags.Static;
    
            Type[] paramTypes = [ typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11) ];

#if NET8_0_OR_GREATER
            var method = Type.GetTypeFromHandle(type)!.GetMethod(methodName, flags, paramTypes)
                         ?? throw new MissingMethodException($"Method {methodName} not found on {Type.GetTypeFromHandle(type)!}");
#else
            var method = Type.GetTypeFromHandle(type)!.GetMethod(methodName, flags, null, paramTypes, null)
                         ?? throw new MissingMethodException($"Method {methodName} not found on {Type.GetTypeFromHandle(type)!}");
#endif
            result = new MethodCache(method.IsStatic, method.MethodHandle.GetFunctionPointer(), method);

            Methods.TryAdd(key, result);
        }

        return result;
    }
    
    #endregion
}

public unsafe struct LuminFunction<
#if NET8_0_OR_GREATER
[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)]
#endif
TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> : IDisposable, ICloneable, ISerializable, IEquatable<LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>>
#if NET9_0_OR_GREATER
    where TTarget : allows ref struct
    where TResult : allows ref struct
    where T1 : allows ref struct
    where T2 : allows ref struct
    where T3 : allows ref struct
    where T4 : allows ref struct
    where T5 : allows ref struct
    where T6 : allows ref struct
    where T7 : allows ref struct
    where T8 : allows ref struct
    where T9 : allows ref struct
    where T10 : allows ref struct
    where T11 : allows ref struct
    where T12 : allows ref struct
#endif
{
    private void* _targetPointer; 
    private object? _referenceTarget; 
    private readonly IntPtr _methodPtr;
    private readonly bool _isStatic;
    private readonly MethodInfo _method;
    private bool _disposed;

    private static readonly bool IsValueType = typeof(TTarget).IsValueType;
    
    public TTarget? Target
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            ThrowIfDisposed();
            
            if (_isStatic)
                return default;
            
            if (IsValueType)
                return Unsafe.AsRef<TTarget?>(_targetPointer);
            
            var target = _referenceTarget;
            return Unsafe.As<object?, TTarget?>(ref target);
        }
    }
    
    public MethodInfo Method => _method;

    #region Constructors
    
    private LuminFunction(MethodCache method)
    {
        _method = method.MethodBase ?? throw new ArgumentNullException(nameof(method));
        _isStatic = method.IsStatic;
        _methodPtr = method.MethodPtr;

        if (!_isStatic)
            throw new ArgumentException("methods are not static!", method.MethodBase.Name);
        
        _referenceTarget = null;
        _targetPointer = null;
    }
    
    private LuminFunction(scoped ref TTarget? target, MethodCache method)
    {
        _method = method.MethodBase ?? throw new ArgumentNullException(nameof(method));
        _isStatic = method.IsStatic;
        _methodPtr = method.MethodPtr;
        _referenceTarget = null;

        if (!_isStatic)
        {
            if (IsValueType)
            {
#if NET8_0_OR_GREATER
                if (Unsafe.IsNullRef(ref target))
                    throw new ArgumentException("Target value instance cannot be null.", nameof(target));
#endif                

#if NET8_0_OR_GREATER
                _targetPointer = NativeMemory.Alloc((nuint)Unsafe.SizeOf<TTarget>());
#else
                _targetPointer = Marshal.AllocHGlobal(Unsafe.SizeOf<TTarget>()).ToPointer();
#endif
                Unsafe.CopyBlock(
                    _targetPointer,
                    Unsafe.AsPointer(ref target),
                    (uint)Unsafe.SizeOf<TTarget>()
                );
            }
            else
            {
                if (target is null)
                    throw new ArgumentException("Target instance object is null.", nameof(target));
                
                _referenceTarget = Unsafe.As<TTarget, object?>(ref target);
                
            }
        }
        else
        {
            _targetPointer = null;
        }
    }
    
    private LuminFunction(Delegate @delegate)
    {
        _method = @delegate.Method ?? throw new ArgumentNullException(nameof(@delegate.Method));
        _isStatic = @delegate.Method.IsStatic;
        _methodPtr = @delegate.Method.MethodHandle.GetFunctionPointer();
        _referenceTarget = null;
        
        var target = @delegate.Target;
        if (!_isStatic)
        {
            if (target is not TTarget)
                throw new ArgumentException("Target instance object is not type.", typeof(TTarget).Name);
                
            if (IsValueType)
            {
#if NET8_0_OR_GREATER
                if (Unsafe.IsNullRef(ref target))
                    throw new ArgumentException("Target value instance cannot be null.", nameof(target));
#endif
                
                var unboxedTarget = Unsafe.AsRef<TTarget>(Unsafe.AsPointer(ref target));
                
#if NET8_0_OR_GREATER
                _targetPointer = NativeMemory.Alloc((nuint)Unsafe.SizeOf<TTarget>());
#else
                _targetPointer = Marshal.AllocHGlobal(Unsafe.SizeOf<TTarget>()).ToPointer();
#endif
                Unsafe.CopyBlock(
                    _targetPointer,
                    Unsafe.AsPointer(ref unboxedTarget),
                    (uint)Unsafe.SizeOf<TTarget>()
                );
            }
            else
            {
                if (target is null)
                    throw new ArgumentException("Target instance object is null.", nameof(target));
                
                _referenceTarget = target;
            }
        }
        else
        {
            _targetPointer = null;
        }
    }

    #endregion
    
    #region Create Factory

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> Create(scoped ref TTarget? target, string methodName, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(IsValueType
                ? TargetTypeHandle
                : Unsafe.As<TTarget, object?>(ref target!)?.GetType().TypeHandle ?? TargetTypeHandle,
            methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        return new LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(ref target, method);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> Create(scoped ref TTarget? target, string methodName, Type targetType, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(targetType.TypeHandle, methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        return new LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(ref target, method);
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> Create(scoped ref TTarget? target, ReadOnlySpan<char> methodName, int methodNameHash = 0) =>
        Create(ref target, methodName.ToString(), methodNameHash);
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> Create(scoped ref TTarget? target, ReadOnlySpan<char> methodName, Type targetType, int methodNameHash = 0) =>
        Create(ref target, methodName.ToString(), targetType, methodNameHash);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> Create(Delegate @delegate) => 
        new LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(@delegate);
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> Create(string methodName, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(TargetTypeHandle, methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        if (!method.IsStatic)
            throw new ArgumentException("Method is not static, please pass in instance as parameter.", nameof(methodName));
        
        return new LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(method);
    }

    #endregion
    
    #region Interface Implementation

    public void Dispose()
    {
        if (_disposed)
            return;
        
        
        if (IsValueType && !_isStatic && _targetPointer != null)
        {
#if NET8_0_OR_GREATER
            NativeMemory.Free(_targetPointer);
#else
            Marshal.FreeHGlobal(new IntPtr(_targetPointer));
#endif
        }
       
        _targetPointer = null;
        _referenceTarget = null;

        _disposed = true;
    }
    
    public object Clone()
    {
        ThrowIfDisposed();
        var target = _referenceTarget;
        if (target is null)
            throw new NullReferenceException("Target instance cannot be null.");
                
        return new LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(ref Unsafe.As<object?, TTarget>(ref target)!, new MethodCache(_isStatic, _methodPtr, _method));
    }

    public void GetObjectData(SerializationInfo info, StreamingContext context)
    {
        throw new NotSupportedException();
    }
    
    public override bool Equals(object? obj)
    {
        return obj is LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> other && Equals(other);
    }

    public bool Equals(LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> other)
    {
        ThrowIfDisposed();
        return _methodPtr == other._methodPtr &&
               _isStatic == other._isStatic &&
               _targetPointer == other._targetPointer;
    }

    public override int GetHashCode()
    {
        ThrowIfDisposed();
        unchecked
        {
            int hash = 17;
            hash = hash * 31 + _methodPtr.GetHashCode();
            hash = hash * 31 + _isStatic.GetHashCode();
            hash = hash * 31 + ((IntPtr)_targetPointer).GetHashCode();
            return hash;
        }
    }

    #endregion
    
    #region Implicit
    
    public static implicit operator LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(in Delegate func) 
        => Create(func);

    public static implicit operator LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> func) => 
        Create(func);
    
    #endregion

    #region Invoke

    public object? DynamicInvoke(params object?[] args)
    {
        ThrowIfDisposed();
        
        if (_isStatic)
        {
            return _method.Invoke(null, args);
        }
        else
        {
            if (typeof(TTarget).IsByRefLike)
                throw new ArgumentException(
                    "The target type is a by-ref-like type and cannot be converted to a delegate.");

#if !NET9_0_OR_GREATER
            if (IsValueType)
                throw new ArgumentException("The target type is value type and cannot dynamic invoke.");
#endif

#if NET9_0_OR_GREATER
            object? instance = IsValueType
                ? RuntimeHelpers.Box(ref Unsafe.AsRef<byte>(_targetPointer), typeof(TTarget).TypeHandle)
                : _referenceTarget;
#else
            object? instance = _referenceTarget;
#endif

            if (instance is null)
                throw new InvalidOperationException("Target instance is null.");

            return _method.Invoke(instance, args);
        }
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12)
    {
        ThrowIfDisposed();

        if (!_isStatic && !IsValueType)
            return ((delegate* managed<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>)_methodPtr)(Unsafe.As<object?, TTarget>(ref _referenceTarget), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12);
        else if (IsValueType)
            return ((delegate* managed<ref TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>)_methodPtr)(ref Unsafe.AsRef<TTarget>(_targetPointer), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12);
        else
            return ((delegate* managed<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>)_methodPtr)(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12);
    }

    #endregion
    
    #region Auxiliary methods
    
    public TDelegate ToDelegate<TDelegate>()
        where TDelegate : Delegate
    {
        ThrowIfDisposed();
        if (_isStatic)
        {
            return (TDelegate)Delegate.CreateDelegate(typeof(TDelegate), _method);
        }
        else
        {
            if (typeof(TTarget).IsByRefLike)
                throw new ArgumentException("The target type is a by-ref-like type and cannot be converted to a delegate.");
            
#if !NET9_0_OR_GREATER
            if (IsValueType)
                throw new ArgumentException("The target type is value type and cannot be converted to a delegate.");
#endif

#if NET9_0_OR_GREATER
            object? instance = IsValueType 
                ? RuntimeHelpers.Box(ref Unsafe.AsRef<byte>(_targetPointer), typeof(TTarget).TypeHandle)
                : _referenceTarget;
#else
            object? instance = _referenceTarget;
#endif
            
            if (instance is null)
                throw new InvalidOperationException("Target instance is null.");
            
            return (TDelegate)Delegate.CreateDelegate(typeof(TDelegate), instance, _method);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void ThrowIfDisposed()
    {
        if (_disposed)
            throw new ObjectDisposedException(nameof(LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>));
    }
    
    #endregion
    
    #region Static Type Hash

    private static readonly int TypeHash = ComputeTypeHash();
    private static readonly int TargetTypeHash = TargetTypeHandle.GetHashCode();
    private static readonly RuntimeTypeHandle TargetTypeHandle = typeof(TTarget).TypeHandle;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static int ComputeTypeHash()
    {
        unchecked
        {
            int h = (int)2166136261;
            h = (h * 16777619) ^ typeof(TResult).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T1).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T2).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T3).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T4).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T5).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T6).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T7).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T8).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T9).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T10).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T11).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T12).TypeHandle.GetHashCode();
            return h;
        }
    }

    #endregion

    #region Method Caching

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static MethodCache GetCachedMethod(scoped in RuntimeTypeHandle type, string methodName, int nameHash = 0)
    {
        nameHash = nameHash is 0 ? StringComparer.Ordinal.GetHashCode(methodName) : nameHash;
        int key = type.Equals(TargetTypeHandle)
                      ? TypeHash ^ nameHash ^ TargetTypeHash
                      : TypeHash ^ nameHash ^ type.GetHashCode();
       
        if (!Methods.TryGetValue(key, out var result))
        {
            const BindingFlags flags = BindingFlags.Public | BindingFlags.NonPublic |
                                       BindingFlags.Instance | BindingFlags.Static;
    
            Type[] paramTypes = [ typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), typeof(T12) ];

#if NET8_0_OR_GREATER
            var method = Type.GetTypeFromHandle(type)!.GetMethod(methodName, flags, paramTypes)
                         ?? throw new MissingMethodException($"Method {methodName} not found on {Type.GetTypeFromHandle(type)!}");
#else
            var method = Type.GetTypeFromHandle(type)!.GetMethod(methodName, flags, null, paramTypes, null)
                         ?? throw new MissingMethodException($"Method {methodName} not found on {Type.GetTypeFromHandle(type)!}");
#endif
            result = new MethodCache(method.IsStatic, method.MethodHandle.GetFunctionPointer(), method);

            Methods.TryAdd(key, result);
        }

        return result;
    }
    
    #endregion
}

public unsafe struct LuminFunction<
#if NET8_0_OR_GREATER
[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)]
#endif
TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> : IDisposable, ICloneable, ISerializable, IEquatable<LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>>
#if NET9_0_OR_GREATER
    where TTarget : allows ref struct
    where TResult : allows ref struct
    where T1 : allows ref struct
    where T2 : allows ref struct
    where T3 : allows ref struct
    where T4 : allows ref struct
    where T5 : allows ref struct
    where T6 : allows ref struct
    where T7 : allows ref struct
    where T8 : allows ref struct
    where T9 : allows ref struct
    where T10 : allows ref struct
    where T11 : allows ref struct
    where T12 : allows ref struct
    where T13 : allows ref struct
#endif
{
    private void* _targetPointer; 
    private object? _referenceTarget; 
    private readonly IntPtr _methodPtr;
    private readonly bool _isStatic;
    private readonly MethodInfo _method;
    private bool _disposed;

    private static readonly bool IsValueType = typeof(TTarget).IsValueType;
    
    public TTarget? Target
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            ThrowIfDisposed();
            
            if (_isStatic)
                return default;
            
            if (IsValueType)
                return Unsafe.AsRef<TTarget?>(_targetPointer);
            
            var target = _referenceTarget;
            return Unsafe.As<object?, TTarget?>(ref target);
        }
    }
    
    public MethodInfo Method => _method;

    #region Constructors
    
    private LuminFunction(MethodCache method)
    {
        _method = method.MethodBase ?? throw new ArgumentNullException(nameof(method));
        _isStatic = method.IsStatic;
        _methodPtr = method.MethodPtr;

        if (!_isStatic)
            throw new ArgumentException("methods are not static!", method.MethodBase.Name);
        
        _referenceTarget = null;
        _targetPointer = null;
    }
    
    private LuminFunction(scoped ref TTarget? target, MethodCache method)
    {
        _method = method.MethodBase ?? throw new ArgumentNullException(nameof(method));
        _isStatic = method.IsStatic;
        _methodPtr = method.MethodPtr;
        _referenceTarget = null;

        if (!_isStatic)
        {
            if (IsValueType)
            {
#if NET8_0_OR_GREATER
                if (Unsafe.IsNullRef(ref target))
                    throw new ArgumentException("Target value instance cannot be null.", nameof(target));
#endif                

#if NET8_0_OR_GREATER
                _targetPointer = NativeMemory.Alloc((nuint)Unsafe.SizeOf<TTarget>());
#else
                _targetPointer = Marshal.AllocHGlobal(Unsafe.SizeOf<TTarget>()).ToPointer();
#endif
                Unsafe.CopyBlock(
                    _targetPointer,
                    Unsafe.AsPointer(ref target),
                    (uint)Unsafe.SizeOf<TTarget>()
                );
            }
            else
            {
                if (target is null)
                    throw new ArgumentException("Target instance object is null.", nameof(target));
                
                _referenceTarget = Unsafe.As<TTarget, object?>(ref target);
                
            }
        }
        else
        {
            _targetPointer = null;
        }
    }
    
    private LuminFunction(Delegate @delegate)
    {
        _method = @delegate.Method ?? throw new ArgumentNullException(nameof(@delegate.Method));
        _isStatic = @delegate.Method.IsStatic;
        _methodPtr = @delegate.Method.MethodHandle.GetFunctionPointer();
        _referenceTarget = null;
        
        var target = @delegate.Target;
        if (!_isStatic)
        {
            if (target is not TTarget)
                throw new ArgumentException("Target instance object is not type.", typeof(TTarget).Name);
                
            if (IsValueType)
            {
#if NET8_0_OR_GREATER
                if (Unsafe.IsNullRef(ref target))
                    throw new ArgumentException("Target value instance cannot be null.", nameof(target));
#endif
                
                var unboxedTarget = Unsafe.AsRef<TTarget>(Unsafe.AsPointer(ref target));
                
#if NET8_0_OR_GREATER
                _targetPointer = NativeMemory.Alloc((nuint)Unsafe.SizeOf<TTarget>());
#else
                _targetPointer = Marshal.AllocHGlobal(Unsafe.SizeOf<TTarget>()).ToPointer();
#endif
                Unsafe.CopyBlock(
                    _targetPointer,
                    Unsafe.AsPointer(ref unboxedTarget),
                    (uint)Unsafe.SizeOf<TTarget>()
                );
            }
            else
            {
                if (target is null)
                    throw new ArgumentException("Target instance object is null.", nameof(target));
                
                _referenceTarget = target;
            }
        }
        else
        {
            _targetPointer = null;
        }
    }

    #endregion
    
    #region Create Factory

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> Create(scoped ref TTarget? target, string methodName, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(IsValueType
                ? TargetTypeHandle
                : Unsafe.As<TTarget, object?>(ref target!)?.GetType().TypeHandle ?? TargetTypeHandle,
            methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        return new LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(ref target, method);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> Create(scoped ref TTarget? target, string methodName, Type targetType, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(targetType.TypeHandle, methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        return new LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(ref target, method);
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> Create(scoped ref TTarget? target, ReadOnlySpan<char> methodName, int methodNameHash = 0) =>
        Create(ref target, methodName.ToString(), methodNameHash);
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> Create(scoped ref TTarget? target, ReadOnlySpan<char> methodName, Type targetType, int methodNameHash = 0) =>
        Create(ref target, methodName.ToString(), targetType, methodNameHash);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> Create(Delegate @delegate) => 
        new LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(@delegate);
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> Create(string methodName, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(TargetTypeHandle, methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        if (!method.IsStatic)
            throw new ArgumentException("Method is not static, please pass in instance as parameter.", nameof(methodName));
        
        return new LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(method);
    }

    #endregion
    
    #region Interface Implementation

    public void Dispose()
    {
        if (_disposed)
            return;
        
        
        if (IsValueType && !_isStatic && _targetPointer != null)
        {
#if NET8_0_OR_GREATER
            NativeMemory.Free(_targetPointer);
#else
            Marshal.FreeHGlobal(new IntPtr(_targetPointer));
#endif
        }
       
        _targetPointer = null;
        _referenceTarget = null;

        _disposed = true;
    }
    
    public object Clone()
    {
        ThrowIfDisposed();
        var target = _referenceTarget;
        if (target is null)
            throw new NullReferenceException("Target instance cannot be null.");
                
        return new LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(ref Unsafe.As<object?, TTarget>(ref target)!, new MethodCache(_isStatic, _methodPtr, _method));
    }

    public void GetObjectData(SerializationInfo info, StreamingContext context)
    {
        throw new NotSupportedException();
    }
    
    public override bool Equals(object? obj)
    {
        return obj is LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> other && Equals(other);
    }

    public bool Equals(LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> other)
    {
        ThrowIfDisposed();
        return _methodPtr == other._methodPtr &&
               _isStatic == other._isStatic &&
               _targetPointer == other._targetPointer;
    }

    public override int GetHashCode()
    {
        ThrowIfDisposed();
        unchecked
        {
            int hash = 17;
            hash = hash * 31 + _methodPtr.GetHashCode();
            hash = hash * 31 + _isStatic.GetHashCode();
            hash = hash * 31 + ((IntPtr)_targetPointer).GetHashCode();
            return hash;
        }
    }

    #endregion
    
    #region Implicit
    
    public static implicit operator LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(in Delegate func) 
        => Create(func);

    public static implicit operator LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> func) => 
        Create(func);
    
    #endregion

    #region Invoke

    public object? DynamicInvoke(params object?[] args)
    {
        ThrowIfDisposed();
        
        if (_isStatic)
        {
            return _method.Invoke(null, args);
        }
        else
        {
            if (typeof(TTarget).IsByRefLike)
                throw new ArgumentException(
                    "The target type is a by-ref-like type and cannot be converted to a delegate.");

#if !NET9_0_OR_GREATER
            if (IsValueType)
                throw new ArgumentException("The target type is value type and cannot dynamic invoke.");
#endif

#if NET9_0_OR_GREATER
            object? instance = IsValueType
                ? RuntimeHelpers.Box(ref Unsafe.AsRef<byte>(_targetPointer), typeof(TTarget).TypeHandle)
                : _referenceTarget;
#else
            object? instance = _referenceTarget;
#endif

            if (instance is null)
                throw new InvalidOperationException("Target instance is null.");

            return _method.Invoke(instance, args);
        }
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13)
    {
        ThrowIfDisposed();

        if (!_isStatic && !IsValueType)
            return ((delegate* managed<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>)_methodPtr)(Unsafe.As<object?, TTarget>(ref _referenceTarget), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13);
        else if (IsValueType)
            return ((delegate* managed<ref TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>)_methodPtr)(ref Unsafe.AsRef<TTarget>(_targetPointer), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13);
        else
            return ((delegate* managed<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>)_methodPtr)(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13);
    }

    #endregion
    
    #region Auxiliary methods
    
    public TDelegate ToDelegate<TDelegate>()
        where TDelegate : Delegate
    {
        ThrowIfDisposed();
        if (_isStatic)
        {
            return (TDelegate)Delegate.CreateDelegate(typeof(TDelegate), _method);
        }
        else
        {
            if (typeof(TTarget).IsByRefLike)
                throw new ArgumentException("The target type is a by-ref-like type and cannot be converted to a delegate.");
            
#if !NET9_0_OR_GREATER
            if (IsValueType)
                throw new ArgumentException("The target type is value type and cannot be converted to a delegate.");
#endif

#if NET9_0_OR_GREATER
            object? instance = IsValueType 
                ? RuntimeHelpers.Box(ref Unsafe.AsRef<byte>(_targetPointer), typeof(TTarget).TypeHandle)
                : _referenceTarget;
#else
            object? instance = _referenceTarget;
#endif
            
            if (instance is null)
                throw new InvalidOperationException("Target instance is null.");
            
            return (TDelegate)Delegate.CreateDelegate(typeof(TDelegate), instance, _method);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void ThrowIfDisposed()
    {
        if (_disposed)
            throw new ObjectDisposedException(nameof(LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>));
    }
    
    #endregion
    
    #region Static Type Hash

    private static readonly int TypeHash = ComputeTypeHash();
    private static readonly int TargetTypeHash = TargetTypeHandle.GetHashCode();
    private static readonly RuntimeTypeHandle TargetTypeHandle = typeof(TTarget).TypeHandle;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static int ComputeTypeHash()
    {
        unchecked
        {
            int h = (int)2166136261;
            h = (h * 16777619) ^ typeof(TResult).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T1).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T2).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T3).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T4).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T5).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T6).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T7).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T8).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T9).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T10).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T11).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T12).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T13).TypeHandle.GetHashCode();
            return h;
        }
    }

    #endregion

    #region Method Caching

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static MethodCache GetCachedMethod(scoped in RuntimeTypeHandle type, string methodName, int nameHash = 0)
    {
        nameHash = nameHash is 0 ? StringComparer.Ordinal.GetHashCode(methodName) : nameHash;
        int key = type.Equals(TargetTypeHandle)
                      ? TypeHash ^ nameHash ^ TargetTypeHash
                      : TypeHash ^ nameHash ^ type.GetHashCode();
       
        if (!Methods.TryGetValue(key, out var result))
        {
            const BindingFlags flags = BindingFlags.Public | BindingFlags.NonPublic |
                                       BindingFlags.Instance | BindingFlags.Static;
    
            Type[] paramTypes = [ typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), typeof(T12), typeof(T13) ];

#if NET8_0_OR_GREATER
            var method = Type.GetTypeFromHandle(type)!.GetMethod(methodName, flags, paramTypes)
                         ?? throw new MissingMethodException($"Method {methodName} not found on {Type.GetTypeFromHandle(type)!}");
#else
            var method = Type.GetTypeFromHandle(type)!.GetMethod(methodName, flags, null, paramTypes, null)
                         ?? throw new MissingMethodException($"Method {methodName} not found on {Type.GetTypeFromHandle(type)!}");
#endif
            result = new MethodCache(method.IsStatic, method.MethodHandle.GetFunctionPointer(), method);

            Methods.TryAdd(key, result);
        }

        return result;
    }
    
    #endregion
}

public unsafe struct LuminFunction<
#if NET8_0_OR_GREATER
[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)]
#endif
TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> : IDisposable, ICloneable, ISerializable, IEquatable<LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>>
#if NET9_0_OR_GREATER
    where TTarget : allows ref struct
    where TResult : allows ref struct
    where T1 : allows ref struct
    where T2 : allows ref struct
    where T3 : allows ref struct
    where T4 : allows ref struct
    where T5 : allows ref struct
    where T6 : allows ref struct
    where T7 : allows ref struct
    where T8 : allows ref struct
    where T9 : allows ref struct
    where T10 : allows ref struct
    where T11 : allows ref struct
    where T12 : allows ref struct
    where T13 : allows ref struct
    where T14 : allows ref struct
#endif
{
    private void* _targetPointer; 
    private object? _referenceTarget; 
    private readonly IntPtr _methodPtr;
    private readonly bool _isStatic;
    private readonly MethodInfo _method;
    private bool _disposed;

    private static readonly bool IsValueType = typeof(TTarget).IsValueType;
    
    public TTarget? Target
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            ThrowIfDisposed();
            
            if (_isStatic)
                return default;
            
            if (IsValueType)
                return Unsafe.AsRef<TTarget?>(_targetPointer);
            
            var target = _referenceTarget;
            return Unsafe.As<object?, TTarget?>(ref target);
        }
    }
    
    public MethodInfo Method => _method;

    #region Constructors
    
    private LuminFunction(MethodCache method)
    {
        _method = method.MethodBase ?? throw new ArgumentNullException(nameof(method));
        _isStatic = method.IsStatic;
        _methodPtr = method.MethodPtr;

        if (!_isStatic)
            throw new ArgumentException("methods are not static!", method.MethodBase.Name);
        
        _referenceTarget = null;
        _targetPointer = null;
    }
    
    private LuminFunction(scoped ref TTarget? target, MethodCache method)
    {
        _method = method.MethodBase ?? throw new ArgumentNullException(nameof(method));
        _isStatic = method.IsStatic;
        _methodPtr = method.MethodPtr;
        _referenceTarget = null;

        if (!_isStatic)
        {
            if (IsValueType)
            {
#if NET8_0_OR_GREATER
                if (Unsafe.IsNullRef(ref target))
                    throw new ArgumentException("Target value instance cannot be null.", nameof(target));
#endif                

#if NET8_0_OR_GREATER
                _targetPointer = NativeMemory.Alloc((nuint)Unsafe.SizeOf<TTarget>());
#else
                _targetPointer = Marshal.AllocHGlobal(Unsafe.SizeOf<TTarget>()).ToPointer();
#endif
                Unsafe.CopyBlock(
                    _targetPointer,
                    Unsafe.AsPointer(ref target),
                    (uint)Unsafe.SizeOf<TTarget>()
                );
            }
            else
            {
                if (target is null)
                    throw new ArgumentException("Target instance object is null.", nameof(target));
                
                _referenceTarget = Unsafe.As<TTarget, object?>(ref target);
                
            }
        }
        else
        {
            _targetPointer = null;
        }
    }
    
    private LuminFunction(Delegate @delegate)
    {
        _method = @delegate.Method ?? throw new ArgumentNullException(nameof(@delegate.Method));
        _isStatic = @delegate.Method.IsStatic;
        _methodPtr = @delegate.Method.MethodHandle.GetFunctionPointer();
        _referenceTarget = null;
        
        var target = @delegate.Target;
        if (!_isStatic)
        {
            if (target is not TTarget)
                throw new ArgumentException("Target instance object is not type.", typeof(TTarget).Name);
                
            if (IsValueType)
            {
#if NET8_0_OR_GREATER
                if (Unsafe.IsNullRef(ref target))
                    throw new ArgumentException("Target value instance cannot be null.", nameof(target));
#endif
                
                var unboxedTarget = Unsafe.AsRef<TTarget>(Unsafe.AsPointer(ref target));
                
#if NET8_0_OR_GREATER
                _targetPointer = NativeMemory.Alloc((nuint)Unsafe.SizeOf<TTarget>());
#else
                _targetPointer = Marshal.AllocHGlobal(Unsafe.SizeOf<TTarget>()).ToPointer();
#endif
                Unsafe.CopyBlock(
                    _targetPointer,
                    Unsafe.AsPointer(ref unboxedTarget),
                    (uint)Unsafe.SizeOf<TTarget>()
                );
            }
            else
            {
                if (target is null)
                    throw new ArgumentException("Target instance object is null.", nameof(target));
                
                _referenceTarget = target;
            }
        }
        else
        {
            _targetPointer = null;
        }
    }

    #endregion
    
    #region Create Factory

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> Create(scoped ref TTarget? target, string methodName, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(IsValueType
                ? TargetTypeHandle
                : Unsafe.As<TTarget, object?>(ref target!)?.GetType().TypeHandle ?? TargetTypeHandle,
            methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        return new LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(ref target, method);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> Create(scoped ref TTarget? target, string methodName, Type targetType, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(targetType.TypeHandle, methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        return new LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(ref target, method);
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> Create(scoped ref TTarget? target, ReadOnlySpan<char> methodName, int methodNameHash = 0) =>
        Create(ref target, methodName.ToString(), methodNameHash);
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> Create(scoped ref TTarget? target, ReadOnlySpan<char> methodName, Type targetType, int methodNameHash = 0) =>
        Create(ref target, methodName.ToString(), targetType, methodNameHash);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> Create(Delegate @delegate) => 
        new LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(@delegate);
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> Create(string methodName, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(TargetTypeHandle, methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        if (!method.IsStatic)
            throw new ArgumentException("Method is not static, please pass in instance as parameter.", nameof(methodName));
        
        return new LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(method);
    }

    #endregion
    
    #region Interface Implementation

    public void Dispose()
    {
        if (_disposed)
            return;
        
        
        if (IsValueType && !_isStatic && _targetPointer != null)
        {
#if NET8_0_OR_GREATER
            NativeMemory.Free(_targetPointer);
#else
            Marshal.FreeHGlobal(new IntPtr(_targetPointer));
#endif
        }
       
        _targetPointer = null;
        _referenceTarget = null;

        _disposed = true;
    }
    
    public object Clone()
    {
        ThrowIfDisposed();
        var target = _referenceTarget;
        if (target is null)
            throw new NullReferenceException("Target instance cannot be null.");
                
        return new LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(ref Unsafe.As<object?, TTarget>(ref target)!, new MethodCache(_isStatic, _methodPtr, _method));
    }

    public void GetObjectData(SerializationInfo info, StreamingContext context)
    {
        throw new NotSupportedException();
    }
    
    public override bool Equals(object? obj)
    {
        return obj is LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> other && Equals(other);
    }

    public bool Equals(LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> other)
    {
        ThrowIfDisposed();
        return _methodPtr == other._methodPtr &&
               _isStatic == other._isStatic &&
               _targetPointer == other._targetPointer;
    }

    public override int GetHashCode()
    {
        ThrowIfDisposed();
        unchecked
        {
            int hash = 17;
            hash = hash * 31 + _methodPtr.GetHashCode();
            hash = hash * 31 + _isStatic.GetHashCode();
            hash = hash * 31 + ((IntPtr)_targetPointer).GetHashCode();
            return hash;
        }
    }

    #endregion
    
    #region Implicit
    
    public static implicit operator LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(in Delegate func) 
        => Create(func);

    public static implicit operator LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> func) => 
        Create(func);
    
    #endregion

    #region Invoke

    public object? DynamicInvoke(params object?[] args)
    {
        ThrowIfDisposed();
        
        if (_isStatic)
        {
            return _method.Invoke(null, args);
        }
        else
        {
            if (typeof(TTarget).IsByRefLike)
                throw new ArgumentException(
                    "The target type is a by-ref-like type and cannot be converted to a delegate.");

#if !NET9_0_OR_GREATER
            if (IsValueType)
                throw new ArgumentException("The target type is value type and cannot dynamic invoke.");
#endif

#if NET9_0_OR_GREATER
            object? instance = IsValueType
                ? RuntimeHelpers.Box(ref Unsafe.AsRef<byte>(_targetPointer), typeof(TTarget).TypeHandle)
                : _referenceTarget;
#else
            object? instance = _referenceTarget;
#endif

            if (instance is null)
                throw new InvalidOperationException("Target instance is null.");

            return _method.Invoke(instance, args);
        }
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14)
    {
        ThrowIfDisposed();

        if (!_isStatic && !IsValueType)
            return ((delegate* managed<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>)_methodPtr)(Unsafe.As<object?, TTarget>(ref _referenceTarget), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14);
        else if (IsValueType)
            return ((delegate* managed<ref TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>)_methodPtr)(ref Unsafe.AsRef<TTarget>(_targetPointer), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14);
        else
            return ((delegate* managed<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>)_methodPtr)(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14);
    }

    #endregion
    
    #region Auxiliary methods
    
    public TDelegate ToDelegate<TDelegate>()
        where TDelegate : Delegate
    {
        ThrowIfDisposed();
        if (_isStatic)
        {
            return (TDelegate)Delegate.CreateDelegate(typeof(TDelegate), _method);
        }
        else
        {
            if (typeof(TTarget).IsByRefLike)
                throw new ArgumentException("The target type is a by-ref-like type and cannot be converted to a delegate.");
            
#if !NET9_0_OR_GREATER
            if (IsValueType)
                throw new ArgumentException("The target type is value type and cannot be converted to a delegate.");
#endif

#if NET9_0_OR_GREATER
            object? instance = IsValueType 
                ? RuntimeHelpers.Box(ref Unsafe.AsRef<byte>(_targetPointer), typeof(TTarget).TypeHandle)
                : _referenceTarget;
#else
            object? instance = _referenceTarget;
#endif
            
            if (instance is null)
                throw new InvalidOperationException("Target instance is null.");
            
            return (TDelegate)Delegate.CreateDelegate(typeof(TDelegate), instance, _method);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void ThrowIfDisposed()
    {
        if (_disposed)
            throw new ObjectDisposedException(nameof(LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>));
    }
    
    #endregion
    
    #region Static Type Hash

    private static readonly int TypeHash = ComputeTypeHash();
    private static readonly int TargetTypeHash = TargetTypeHandle.GetHashCode();
    private static readonly RuntimeTypeHandle TargetTypeHandle = typeof(TTarget).TypeHandle;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static int ComputeTypeHash()
    {
        unchecked
        {
            int h = (int)2166136261;
            h = (h * 16777619) ^ typeof(TResult).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T1).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T2).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T3).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T4).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T5).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T6).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T7).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T8).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T9).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T10).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T11).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T12).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T13).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T14).TypeHandle.GetHashCode();
            return h;
        }
    }

    #endregion

    #region Method Caching

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static MethodCache GetCachedMethod(scoped in RuntimeTypeHandle type, string methodName, int nameHash = 0)
    {
        nameHash = nameHash is 0 ? StringComparer.Ordinal.GetHashCode(methodName) : nameHash;
        int key = type.Equals(TargetTypeHandle)
                      ? TypeHash ^ nameHash ^ TargetTypeHash
                      : TypeHash ^ nameHash ^ type.GetHashCode();
       
        if (!Methods.TryGetValue(key, out var result))
        {
            const BindingFlags flags = BindingFlags.Public | BindingFlags.NonPublic |
                                       BindingFlags.Instance | BindingFlags.Static;
    
            Type[] paramTypes = [ typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), typeof(T12), typeof(T13), typeof(T14) ];

#if NET8_0_OR_GREATER
            var method = Type.GetTypeFromHandle(type)!.GetMethod(methodName, flags, paramTypes)
                         ?? throw new MissingMethodException($"Method {methodName} not found on {Type.GetTypeFromHandle(type)!}");
#else
            var method = Type.GetTypeFromHandle(type)!.GetMethod(methodName, flags, null, paramTypes, null)
                         ?? throw new MissingMethodException($"Method {methodName} not found on {Type.GetTypeFromHandle(type)!}");
#endif
            result = new MethodCache(method.IsStatic, method.MethodHandle.GetFunctionPointer(), method);

            Methods.TryAdd(key, result);
        }

        return result;
    }
    
    #endregion
}

public unsafe struct LuminFunction<
#if NET8_0_OR_GREATER
[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)]
#endif
TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> : IDisposable, ICloneable, ISerializable, IEquatable<LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>>
#if NET9_0_OR_GREATER
    where TTarget : allows ref struct
    where TResult : allows ref struct
    where T1 : allows ref struct
    where T2 : allows ref struct
    where T3 : allows ref struct
    where T4 : allows ref struct
    where T5 : allows ref struct
    where T6 : allows ref struct
    where T7 : allows ref struct
    where T8 : allows ref struct
    where T9 : allows ref struct
    where T10 : allows ref struct
    where T11 : allows ref struct
    where T12 : allows ref struct
    where T13 : allows ref struct
    where T14 : allows ref struct
    where T15 : allows ref struct
#endif
{
    private void* _targetPointer; 
    private object? _referenceTarget; 
    private readonly IntPtr _methodPtr;
    private readonly bool _isStatic;
    private readonly MethodInfo _method;
    private bool _disposed;

    private static readonly bool IsValueType = typeof(TTarget).IsValueType;
    
    public TTarget? Target
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            ThrowIfDisposed();
            
            if (_isStatic)
                return default;
            
            if (IsValueType)
                return Unsafe.AsRef<TTarget?>(_targetPointer);
            
            var target = _referenceTarget;
            return Unsafe.As<object?, TTarget?>(ref target);
        }
    }
    
    public MethodInfo Method => _method;

    #region Constructors
    
    private LuminFunction(MethodCache method)
    {
        _method = method.MethodBase ?? throw new ArgumentNullException(nameof(method));
        _isStatic = method.IsStatic;
        _methodPtr = method.MethodPtr;

        if (!_isStatic)
            throw new ArgumentException("methods are not static!", method.MethodBase.Name);
        
        _referenceTarget = null;
        _targetPointer = null;
    }
    
    private LuminFunction(scoped ref TTarget? target, MethodCache method)
    {
        _method = method.MethodBase ?? throw new ArgumentNullException(nameof(method));
        _isStatic = method.IsStatic;
        _methodPtr = method.MethodPtr;
        _referenceTarget = null;

        if (!_isStatic)
        {
            if (IsValueType)
            {
#if NET8_0_OR_GREATER
                if (Unsafe.IsNullRef(ref target))
                    throw new ArgumentException("Target value instance cannot be null.", nameof(target));
#endif                

#if NET8_0_OR_GREATER
                _targetPointer = NativeMemory.Alloc((nuint)Unsafe.SizeOf<TTarget>());
#else
                _targetPointer = Marshal.AllocHGlobal(Unsafe.SizeOf<TTarget>()).ToPointer();
#endif
                Unsafe.CopyBlock(
                    _targetPointer,
                    Unsafe.AsPointer(ref target),
                    (uint)Unsafe.SizeOf<TTarget>()
                );
            }
            else
            {
                if (target is null)
                    throw new ArgumentException("Target instance object is null.", nameof(target));
                
                _referenceTarget = Unsafe.As<TTarget, object?>(ref target);
                
            }
        }
        else
        {
            _targetPointer = null;
        }
    }
    
    private LuminFunction(Delegate @delegate)
    {
        _method = @delegate.Method ?? throw new ArgumentNullException(nameof(@delegate.Method));
        _isStatic = @delegate.Method.IsStatic;
        _methodPtr = @delegate.Method.MethodHandle.GetFunctionPointer();
        _referenceTarget = null;
        
        var target = @delegate.Target;
        if (!_isStatic)
        {
            if (target is not TTarget)
                throw new ArgumentException("Target instance object is not type.", typeof(TTarget).Name);
                
            if (IsValueType)
            {
#if NET8_0_OR_GREATER
                if (Unsafe.IsNullRef(ref target))
                    throw new ArgumentException("Target value instance cannot be null.", nameof(target));
#endif
                
                var unboxedTarget = Unsafe.AsRef<TTarget>(Unsafe.AsPointer(ref target));
                
#if NET8_0_OR_GREATER
                _targetPointer = NativeMemory.Alloc((nuint)Unsafe.SizeOf<TTarget>());
#else
                _targetPointer = Marshal.AllocHGlobal(Unsafe.SizeOf<TTarget>()).ToPointer();
#endif
                Unsafe.CopyBlock(
                    _targetPointer,
                    Unsafe.AsPointer(ref unboxedTarget),
                    (uint)Unsafe.SizeOf<TTarget>()
                );
            }
            else
            {
                if (target is null)
                    throw new ArgumentException("Target instance object is null.", nameof(target));
                
                _referenceTarget = target;
            }
        }
        else
        {
            _targetPointer = null;
        }
    }

    #endregion
    
    #region Create Factory

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> Create(scoped ref TTarget? target, string methodName, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(IsValueType
                ? TargetTypeHandle
                : Unsafe.As<TTarget, object?>(ref target!)?.GetType().TypeHandle ?? TargetTypeHandle,
            methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        return new LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(ref target, method);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> Create(scoped ref TTarget? target, string methodName, Type targetType, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(targetType.TypeHandle, methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        return new LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(ref target, method);
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> Create(scoped ref TTarget? target, ReadOnlySpan<char> methodName, int methodNameHash = 0) =>
        Create(ref target, methodName.ToString(), methodNameHash);
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> Create(scoped ref TTarget? target, ReadOnlySpan<char> methodName, Type targetType, int methodNameHash = 0) =>
        Create(ref target, methodName.ToString(), targetType, methodNameHash);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> Create(Delegate @delegate) => 
        new LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(@delegate);
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> Create(string methodName, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(TargetTypeHandle, methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        if (!method.IsStatic)
            throw new ArgumentException("Method is not static, please pass in instance as parameter.", nameof(methodName));
        
        return new LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(method);
    }

    #endregion
    
    #region Interface Implementation

    public void Dispose()
    {
        if (_disposed)
            return;
        
        
        if (IsValueType && !_isStatic && _targetPointer != null)
        {
#if NET8_0_OR_GREATER
            NativeMemory.Free(_targetPointer);
#else
            Marshal.FreeHGlobal(new IntPtr(_targetPointer));
#endif
        }
       
        _targetPointer = null;
        _referenceTarget = null;

        _disposed = true;
    }
    
    public object Clone()
    {
        ThrowIfDisposed();
        var target = _referenceTarget;
        if (target is null)
            throw new NullReferenceException("Target instance cannot be null.");
                
        return new LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(ref Unsafe.As<object?, TTarget>(ref target)!, new MethodCache(_isStatic, _methodPtr, _method));
    }

    public void GetObjectData(SerializationInfo info, StreamingContext context)
    {
        throw new NotSupportedException();
    }
    
    public override bool Equals(object? obj)
    {
        return obj is LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> other && Equals(other);
    }

    public bool Equals(LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> other)
    {
        ThrowIfDisposed();
        return _methodPtr == other._methodPtr &&
               _isStatic == other._isStatic &&
               _targetPointer == other._targetPointer;
    }

    public override int GetHashCode()
    {
        ThrowIfDisposed();
        unchecked
        {
            int hash = 17;
            hash = hash * 31 + _methodPtr.GetHashCode();
            hash = hash * 31 + _isStatic.GetHashCode();
            hash = hash * 31 + ((IntPtr)_targetPointer).GetHashCode();
            return hash;
        }
    }

    #endregion
    
    #region Implicit
    
    public static implicit operator LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(in Delegate func) 
        => Create(func);

    public static implicit operator LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> func) => 
        Create(func);
    
    #endregion

    #region Invoke

    public object? DynamicInvoke(params object?[] args)
    {
        ThrowIfDisposed();
        
        if (_isStatic)
        {
            return _method.Invoke(null, args);
        }
        else
        {
            if (typeof(TTarget).IsByRefLike)
                throw new ArgumentException(
                    "The target type is a by-ref-like type and cannot be converted to a delegate.");

#if !NET9_0_OR_GREATER
            if (IsValueType)
                throw new ArgumentException("The target type is value type and cannot dynamic invoke.");
#endif

#if NET9_0_OR_GREATER
            object? instance = IsValueType
                ? RuntimeHelpers.Box(ref Unsafe.AsRef<byte>(_targetPointer), typeof(TTarget).TypeHandle)
                : _referenceTarget;
#else
            object? instance = _referenceTarget;
#endif

            if (instance is null)
                throw new InvalidOperationException("Target instance is null.");

            return _method.Invoke(instance, args);
        }
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15)
    {
        ThrowIfDisposed();

        if (!_isStatic && !IsValueType)
            return ((delegate* managed<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>)_methodPtr)(Unsafe.As<object?, TTarget>(ref _referenceTarget), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15);
        else if (IsValueType)
            return ((delegate* managed<ref TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>)_methodPtr)(ref Unsafe.AsRef<TTarget>(_targetPointer), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15);
        else
            return ((delegate* managed<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>)_methodPtr)(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15);
    }

    #endregion
    
    #region Auxiliary methods
    
    public TDelegate ToDelegate<TDelegate>()
        where TDelegate : Delegate
    {
        ThrowIfDisposed();
        if (_isStatic)
        {
            return (TDelegate)Delegate.CreateDelegate(typeof(TDelegate), _method);
        }
        else
        {
            if (typeof(TTarget).IsByRefLike)
                throw new ArgumentException("The target type is a by-ref-like type and cannot be converted to a delegate.");
            
#if !NET9_0_OR_GREATER
            if (IsValueType)
                throw new ArgumentException("The target type is value type and cannot be converted to a delegate.");
#endif

#if NET9_0_OR_GREATER
            object? instance = IsValueType 
                ? RuntimeHelpers.Box(ref Unsafe.AsRef<byte>(_targetPointer), typeof(TTarget).TypeHandle)
                : _referenceTarget;
#else
            object? instance = _referenceTarget;
#endif
            
            if (instance is null)
                throw new InvalidOperationException("Target instance is null.");
            
            return (TDelegate)Delegate.CreateDelegate(typeof(TDelegate), instance, _method);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void ThrowIfDisposed()
    {
        if (_disposed)
            throw new ObjectDisposedException(nameof(LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>));
    }
    
    #endregion
    
    #region Static Type Hash

    private static readonly int TypeHash = ComputeTypeHash();
    private static readonly int TargetTypeHash = TargetTypeHandle.GetHashCode();
    private static readonly RuntimeTypeHandle TargetTypeHandle = typeof(TTarget).TypeHandle;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static int ComputeTypeHash()
    {
        unchecked
        {
            int h = (int)2166136261;
            h = (h * 16777619) ^ typeof(TResult).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T1).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T2).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T3).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T4).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T5).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T6).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T7).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T8).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T9).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T10).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T11).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T12).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T13).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T14).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T15).TypeHandle.GetHashCode();
            return h;
        }
    }

    #endregion

    #region Method Caching

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static MethodCache GetCachedMethod(scoped in RuntimeTypeHandle type, string methodName, int nameHash = 0)
    {
        nameHash = nameHash is 0 ? StringComparer.Ordinal.GetHashCode(methodName) : nameHash;
        int key = type.Equals(TargetTypeHandle)
                      ? TypeHash ^ nameHash ^ TargetTypeHash
                      : TypeHash ^ nameHash ^ type.GetHashCode();
       
        if (!Methods.TryGetValue(key, out var result))
        {
            const BindingFlags flags = BindingFlags.Public | BindingFlags.NonPublic |
                                       BindingFlags.Instance | BindingFlags.Static;
    
            Type[] paramTypes = [ typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), typeof(T12), typeof(T13), typeof(T14), typeof(T15) ];

#if NET8_0_OR_GREATER
            var method = Type.GetTypeFromHandle(type)!.GetMethod(methodName, flags, paramTypes)
                         ?? throw new MissingMethodException($"Method {methodName} not found on {Type.GetTypeFromHandle(type)!}");
#else
            var method = Type.GetTypeFromHandle(type)!.GetMethod(methodName, flags, null, paramTypes, null)
                         ?? throw new MissingMethodException($"Method {methodName} not found on {Type.GetTypeFromHandle(type)!}");
#endif
            result = new MethodCache(method.IsStatic, method.MethodHandle.GetFunctionPointer(), method);

            Methods.TryAdd(key, result);
        }

        return result;
    }
    
    #endregion
}
