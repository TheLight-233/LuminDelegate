<#@ template language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#
const int MaxParams = 15;
string Join(int n, string fmt) => string.Join(", ", Enumerable.Range(1, n).Select(i => string.Format(fmt, i)));
string Where(int n) => string.Join(" ", Enumerable.Range(1, n).Select(i => $"where T{i} : allows ref struct"));
string DynAttr() => "[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)]";
#>

// <auto-generated/>
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;

#nullable enable
namespace LuminDelegates
{
    public static partial class LuminDelegate
    {
        #region LuminAction<TTarget>

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托
        /// </summary>
        /// <param name="target">委托绑定的实例（值类型或引用类型）</param>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget> CreateAction<TTarget>(TTarget? target, string methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
#endif
            => LuminAction<TTarget>.Create(ref target, methodName, methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（显式指定目标类型）
        /// 用于解决虚方法GetType开销
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="targetType">查找实例的类型</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#if NET8_0_OR_GREATER
        public static LuminAction<TTarget> CreateAction<TTarget>(TTarget? target, string methodName, <#= DynAttr() #> Type targetType, int methodNameHash = 0)
#else
        public static LuminAction<TTarget> CreateAction<TTarget>(TTarget? target, string methodName, Type targetType, int methodNameHash = 0)
#endif
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
#endif
            => LuminAction<TTarget>.Create(ref target, methodName, targetType, methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（避免字符串分配）
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名（只读字符范围）</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget> CreateAction<TTarget>(TTarget? target, ReadOnlySpan<char> methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
#endif
            => CreateAction<TTarget>(target, methodName.ToString(), methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（显式指定目标类型 + 避免字符串分配）
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名（只读字符范围）</param>
        /// <param name="targetType">绑定实例的类型</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#if NET8_0_OR_GREATER
        public static LuminAction<TTarget> CreateAction<TTarget>(TTarget? target, ReadOnlySpan<char> methodName, <#= DynAttr() #> Type targetType, int methodNameHash = 0)
#else
        public static LuminAction<TTarget> CreateAction<TTarget>(TTarget? target, ReadOnlySpan<char> methodName, Type targetType, int methodNameHash = 0)
#endif
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
#endif
            => CreateAction<TTarget>(target, methodName.ToString(), targetType, methodNameHash);

        /// <summary>
        /// 从现有委托创建 Lumin 委托
        /// </summary>
        /// <param name="delegate">现有的 .NET 委托</param>
        /// <returns>等价的 Lumin 委托</returns>
        [Obsolete("直接由委托隐式创建实例可能引发额外的 GC 压力与性能损耗，请显式传入对象实例和方法名以避免装箱与捕获成本。")]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget> CreateAction<TTarget>(Delegate @delegate)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
#endif
            => LuminAction<TTarget>.Create(@delegate);

        /// <summary>
        /// 从现有委托创建 Lumin 委托
        /// </summary>
        /// <param name="delegate">现有的 .NET 委托</param>
        /// <returns>等价的 Lumin 委托</returns>
        [Obsolete("直接由委托隐式创建实例可能引发额外的 GC 压力与性能损耗，请显式传入对象实例和方法名以避免装箱与捕获成本。")]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget> CreateAction<TTarget>(Action @delegate)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
#endif
            => LuminAction<TTarget>.Create(@delegate);

        /// <summary>
        /// 创建绑定静态方法的Lumin委托
        /// </summary>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget> CreateAction<TTarget>(string methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
#endif
            => LuminAction<TTarget>.Create(methodName, methodNameHash);

        /// <summary>
        /// 创建绑定静态方法的Lumin委托
        /// </summary>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget> CreateAction<TTarget>(ReadOnlySpan<char> methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
#endif
            => LuminAction<TTarget>.Create(methodName.ToString(), methodNameHash);

        #endregion

<#
for (int n = 1; n <= MaxParams; n++)
{
    string targs = Join(n, "T{0}");
    string full = $"LuminAction<TTarget, {targs}>";
#>
        #region <#= full #>

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托
        /// </summary>
        /// <param name="target">委托绑定的实例（值类型或引用类型）</param>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#= full #> CreateAction<TTarget, <#= targs #>>(TTarget? target, string methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            <#= Where(n) #>
#endif
            => <#= full #>.Create(ref target, methodName, methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（显式指定目标类型）
        /// 用于解决虚方法GetType开销
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="targetType">查找实例的类型</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#if NET8_0_OR_GREATER
        public static <#= full #> CreateAction<TTarget, <#= targs #>>(TTarget? target, string methodName, <#= DynAttr() #> Type targetType, int methodNameHash = 0)
#else
        public static <#= full #> CreateAction<TTarget, <#= targs #>>(TTarget? target, string methodName, Type targetType, int methodNameHash = 0)
#endif
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            <#= Where(n) #>
#endif
            => <#= full #>.Create(ref target, methodName, targetType, methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（避免字符串分配）
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名（只读字符范围）</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#= full #> CreateAction<TTarget, <#= targs #>>(TTarget? target, ReadOnlySpan<char> methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            <#= Where(n) #>
#endif
            => CreateAction<TTarget, <#= targs #>>(target, methodName.ToString(), methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（显式指定目标类型 + 避免字符串分配）
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名（只读字符范围）</param>
        /// <param name="targetType">绑定实例的类型</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#if NET8_0_OR_GREATER
        public static <#= full #> CreateAction<TTarget, <#= targs #>>(TTarget? target, ReadOnlySpan<char> methodName, <#= DynAttr() #> Type targetType, int methodNameHash = 0)
#else
        public static <#= full #> CreateAction<TTarget, <#= targs #>>(TTarget? target, ReadOnlySpan<char> methodName, Type targetType, int methodNameHash = 0)
#endif
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            <#= Where(n) #>
#endif
            => CreateAction<TTarget, <#= targs #>>(target, methodName.ToString(), targetType, methodNameHash);

        /// <summary>
        /// 从现有委托创建 Lumin 委托
        /// </summary>
        /// <param name="delegate">现有的 .NET 委托</param>
        /// <returns>等价的 Lumin 委托</returns>
        [Obsolete("直接由委托隐式创建实例可能引发额外的 GC 压力与性能损耗，请显式传入对象实例和方法名以避免装箱与捕获成本。")]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#= full #> CreateAction<TTarget, <#= targs #>>(Delegate @delegate)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            <#= Where(n) #>
#endif
            => <#= full #>.Create(@delegate);

        /// <summary>
        /// 从现有委托创建 Lumin 委托
        /// </summary>
        /// <param name="delegate">现有的 .NET 委托</param>
        /// <returns>等价的 Lumin 委托</returns>
        [Obsolete("直接由委托隐式创建实例可能引发额外的 GC 压力与性能损耗，请显式传入对象实例和方法名以避免装箱与捕获成本。")]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#= full #> CreateAction<TTarget, <#= targs #>>(Action<<#= targs #>> @delegate)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            <#= Where(n) #>
#endif
            => <#= full #>.Create(@delegate);

        /// <summary>
        /// 创建绑定静态方法的Lumin委托
        /// </summary>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#= full #> CreateAction<TTarget, <#= targs #>>(string methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            <#= Where(n) #>
#endif
            => <#= full #>.Create(methodName, methodNameHash);

        /// <summary>
        /// 创建绑定静态方法的Lumin委托
        /// </summary>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#= full #> CreateAction<TTarget, <#= targs #>>(ReadOnlySpan<char> methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            <#= Where(n) #>
#endif
            => <#= full #>.Create(methodName.ToString(), methodNameHash);

        #endregion

<#
}
#>
    }
}