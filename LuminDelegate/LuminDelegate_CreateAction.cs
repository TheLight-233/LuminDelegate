
// <auto-generated/>
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;

#nullable enable
namespace LuminDelegates
{
    public static partial class LuminDelegate
    {
        #region LuminAction<TTarget>

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托
        /// </summary>
        /// <param name="target">委托绑定的实例（值类型或引用类型）</param>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget> CreateAction<TTarget>(TTarget? target, string methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
#endif
            => LuminAction<TTarget>.Create(ref target, methodName, methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（显式指定目标类型）
        /// 用于解决虚方法GetType开销
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="targetType">查找实例的类型</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#if NET8_0_OR_GREATER
        public static LuminAction<TTarget> CreateAction<TTarget>(TTarget? target, string methodName, [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type targetType, int methodNameHash = 0)
#else
        public static LuminAction<TTarget> CreateAction<TTarget>(TTarget? target, string methodName, Type targetType, int methodNameHash = 0)
#endif
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
#endif
            => LuminAction<TTarget>.Create(ref target, methodName, targetType, methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（避免字符串分配）
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名（只读字符范围）</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget> CreateAction<TTarget>(TTarget? target, ReadOnlySpan<char> methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
#endif
            => CreateAction<TTarget>(target, methodName.ToString(), methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（显式指定目标类型 + 避免字符串分配）
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名（只读字符范围）</param>
        /// <param name="targetType">绑定实例的类型</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#if NET8_0_OR_GREATER
        public static LuminAction<TTarget> CreateAction<TTarget>(TTarget? target, ReadOnlySpan<char> methodName, [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type targetType, int methodNameHash = 0)
#else
        public static LuminAction<TTarget> CreateAction<TTarget>(TTarget? target, ReadOnlySpan<char> methodName, Type targetType, int methodNameHash = 0)
#endif
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
#endif
            => CreateAction<TTarget>(target, methodName.ToString(), targetType, methodNameHash);

        /// <summary>
        /// 从现有委托创建 Lumin 委托
        /// </summary>
        /// <param name="delegate">现有的 .NET 委托</param>
        /// <returns>等价的 Lumin 委托</returns>
        [Obsolete("直接由委托隐式创建实例可能引发额外的 GC 压力与性能损耗，请显式传入对象实例和方法名以避免装箱与捕获成本。")]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget> CreateAction<TTarget>(Delegate @delegate)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
#endif
            => LuminAction<TTarget>.Create(@delegate);

        /// <summary>
        /// 从现有委托创建 Lumin 委托
        /// </summary>
        /// <param name="delegate">现有的 .NET 委托</param>
        /// <returns>等价的 Lumin 委托</returns>
        [Obsolete("直接由委托隐式创建实例可能引发额外的 GC 压力与性能损耗，请显式传入对象实例和方法名以避免装箱与捕获成本。")]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget> CreateAction<TTarget>(Action @delegate)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
#endif
            => LuminAction<TTarget>.Create(@delegate);

        /// <summary>
        /// 创建绑定静态方法的Lumin委托
        /// </summary>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget> CreateAction<TTarget>(string methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
#endif
            => LuminAction<TTarget>.Create(methodName, methodNameHash);

        /// <summary>
        /// 创建绑定静态方法的Lumin委托
        /// </summary>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget> CreateAction<TTarget>(ReadOnlySpan<char> methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
#endif
            => LuminAction<TTarget>.Create(methodName.ToString(), methodNameHash);

        #endregion

        #region LuminAction<TTarget, T1>

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托
        /// </summary>
        /// <param name="target">委托绑定的实例（值类型或引用类型）</param>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1> CreateAction<TTarget, T1>(TTarget? target, string methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct
#endif
            => LuminAction<TTarget, T1>.Create(ref target, methodName, methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（显式指定目标类型）
        /// 用于解决虚方法GetType开销
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="targetType">查找实例的类型</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#if NET8_0_OR_GREATER
        public static LuminAction<TTarget, T1> CreateAction<TTarget, T1>(TTarget? target, string methodName, [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type targetType, int methodNameHash = 0)
#else
        public static LuminAction<TTarget, T1> CreateAction<TTarget, T1>(TTarget? target, string methodName, Type targetType, int methodNameHash = 0)
#endif
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct
#endif
            => LuminAction<TTarget, T1>.Create(ref target, methodName, targetType, methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（避免字符串分配）
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名（只读字符范围）</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1> CreateAction<TTarget, T1>(TTarget? target, ReadOnlySpan<char> methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct
#endif
            => CreateAction<TTarget, T1>(target, methodName.ToString(), methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（显式指定目标类型 + 避免字符串分配）
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名（只读字符范围）</param>
        /// <param name="targetType">绑定实例的类型</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#if NET8_0_OR_GREATER
        public static LuminAction<TTarget, T1> CreateAction<TTarget, T1>(TTarget? target, ReadOnlySpan<char> methodName, [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type targetType, int methodNameHash = 0)
#else
        public static LuminAction<TTarget, T1> CreateAction<TTarget, T1>(TTarget? target, ReadOnlySpan<char> methodName, Type targetType, int methodNameHash = 0)
#endif
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct
#endif
            => CreateAction<TTarget, T1>(target, methodName.ToString(), targetType, methodNameHash);

        /// <summary>
        /// 从现有委托创建 Lumin 委托
        /// </summary>
        /// <param name="delegate">现有的 .NET 委托</param>
        /// <returns>等价的 Lumin 委托</returns>
        [Obsolete("直接由委托隐式创建实例可能引发额外的 GC 压力与性能损耗，请显式传入对象实例和方法名以避免装箱与捕获成本。")]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1> CreateAction<TTarget, T1>(Delegate @delegate)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct
#endif
            => LuminAction<TTarget, T1>.Create(@delegate);

        /// <summary>
        /// 从现有委托创建 Lumin 委托
        /// </summary>
        /// <param name="delegate">现有的 .NET 委托</param>
        /// <returns>等价的 Lumin 委托</returns>
        [Obsolete("直接由委托隐式创建实例可能引发额外的 GC 压力与性能损耗，请显式传入对象实例和方法名以避免装箱与捕获成本。")]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1> CreateAction<TTarget, T1>(Action<T1> @delegate)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct
#endif
            => LuminAction<TTarget, T1>.Create(@delegate);

        /// <summary>
        /// 创建绑定静态方法的Lumin委托
        /// </summary>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1> CreateAction<TTarget, T1>(string methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct
#endif
            => LuminAction<TTarget, T1>.Create(methodName, methodNameHash);

        /// <summary>
        /// 创建绑定静态方法的Lumin委托
        /// </summary>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1> CreateAction<TTarget, T1>(ReadOnlySpan<char> methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct
#endif
            => LuminAction<TTarget, T1>.Create(methodName.ToString(), methodNameHash);

        #endregion

        #region LuminAction<TTarget, T1, T2>

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托
        /// </summary>
        /// <param name="target">委托绑定的实例（值类型或引用类型）</param>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2> CreateAction<TTarget, T1, T2>(TTarget? target, string methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2>.Create(ref target, methodName, methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（显式指定目标类型）
        /// 用于解决虚方法GetType开销
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="targetType">查找实例的类型</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#if NET8_0_OR_GREATER
        public static LuminAction<TTarget, T1, T2> CreateAction<TTarget, T1, T2>(TTarget? target, string methodName, [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type targetType, int methodNameHash = 0)
#else
        public static LuminAction<TTarget, T1, T2> CreateAction<TTarget, T1, T2>(TTarget? target, string methodName, Type targetType, int methodNameHash = 0)
#endif
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2>.Create(ref target, methodName, targetType, methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（避免字符串分配）
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名（只读字符范围）</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2> CreateAction<TTarget, T1, T2>(TTarget? target, ReadOnlySpan<char> methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct
#endif
            => CreateAction<TTarget, T1, T2>(target, methodName.ToString(), methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（显式指定目标类型 + 避免字符串分配）
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名（只读字符范围）</param>
        /// <param name="targetType">绑定实例的类型</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#if NET8_0_OR_GREATER
        public static LuminAction<TTarget, T1, T2> CreateAction<TTarget, T1, T2>(TTarget? target, ReadOnlySpan<char> methodName, [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type targetType, int methodNameHash = 0)
#else
        public static LuminAction<TTarget, T1, T2> CreateAction<TTarget, T1, T2>(TTarget? target, ReadOnlySpan<char> methodName, Type targetType, int methodNameHash = 0)
#endif
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct
#endif
            => CreateAction<TTarget, T1, T2>(target, methodName.ToString(), targetType, methodNameHash);

        /// <summary>
        /// 从现有委托创建 Lumin 委托
        /// </summary>
        /// <param name="delegate">现有的 .NET 委托</param>
        /// <returns>等价的 Lumin 委托</returns>
        [Obsolete("直接由委托隐式创建实例可能引发额外的 GC 压力与性能损耗，请显式传入对象实例和方法名以避免装箱与捕获成本。")]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2> CreateAction<TTarget, T1, T2>(Delegate @delegate)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2>.Create(@delegate);

        /// <summary>
        /// 从现有委托创建 Lumin 委托
        /// </summary>
        /// <param name="delegate">现有的 .NET 委托</param>
        /// <returns>等价的 Lumin 委托</returns>
        [Obsolete("直接由委托隐式创建实例可能引发额外的 GC 压力与性能损耗，请显式传入对象实例和方法名以避免装箱与捕获成本。")]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2> CreateAction<TTarget, T1, T2>(Action<T1, T2> @delegate)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2>.Create(@delegate);

        /// <summary>
        /// 创建绑定静态方法的Lumin委托
        /// </summary>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2> CreateAction<TTarget, T1, T2>(string methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2>.Create(methodName, methodNameHash);

        /// <summary>
        /// 创建绑定静态方法的Lumin委托
        /// </summary>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2> CreateAction<TTarget, T1, T2>(ReadOnlySpan<char> methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2>.Create(methodName.ToString(), methodNameHash);

        #endregion

        #region LuminAction<TTarget, T1, T2, T3>

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托
        /// </summary>
        /// <param name="target">委托绑定的实例（值类型或引用类型）</param>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3> CreateAction<TTarget, T1, T2, T3>(TTarget? target, string methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3>.Create(ref target, methodName, methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（显式指定目标类型）
        /// 用于解决虚方法GetType开销
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="targetType">查找实例的类型</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#if NET8_0_OR_GREATER
        public static LuminAction<TTarget, T1, T2, T3> CreateAction<TTarget, T1, T2, T3>(TTarget? target, string methodName, [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type targetType, int methodNameHash = 0)
#else
        public static LuminAction<TTarget, T1, T2, T3> CreateAction<TTarget, T1, T2, T3>(TTarget? target, string methodName, Type targetType, int methodNameHash = 0)
#endif
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3>.Create(ref target, methodName, targetType, methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（避免字符串分配）
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名（只读字符范围）</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3> CreateAction<TTarget, T1, T2, T3>(TTarget? target, ReadOnlySpan<char> methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct
#endif
            => CreateAction<TTarget, T1, T2, T3>(target, methodName.ToString(), methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（显式指定目标类型 + 避免字符串分配）
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名（只读字符范围）</param>
        /// <param name="targetType">绑定实例的类型</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#if NET8_0_OR_GREATER
        public static LuminAction<TTarget, T1, T2, T3> CreateAction<TTarget, T1, T2, T3>(TTarget? target, ReadOnlySpan<char> methodName, [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type targetType, int methodNameHash = 0)
#else
        public static LuminAction<TTarget, T1, T2, T3> CreateAction<TTarget, T1, T2, T3>(TTarget? target, ReadOnlySpan<char> methodName, Type targetType, int methodNameHash = 0)
#endif
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct
#endif
            => CreateAction<TTarget, T1, T2, T3>(target, methodName.ToString(), targetType, methodNameHash);

        /// <summary>
        /// 从现有委托创建 Lumin 委托
        /// </summary>
        /// <param name="delegate">现有的 .NET 委托</param>
        /// <returns>等价的 Lumin 委托</returns>
        [Obsolete("直接由委托隐式创建实例可能引发额外的 GC 压力与性能损耗，请显式传入对象实例和方法名以避免装箱与捕获成本。")]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3> CreateAction<TTarget, T1, T2, T3>(Delegate @delegate)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3>.Create(@delegate);

        /// <summary>
        /// 从现有委托创建 Lumin 委托
        /// </summary>
        /// <param name="delegate">现有的 .NET 委托</param>
        /// <returns>等价的 Lumin 委托</returns>
        [Obsolete("直接由委托隐式创建实例可能引发额外的 GC 压力与性能损耗，请显式传入对象实例和方法名以避免装箱与捕获成本。")]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3> CreateAction<TTarget, T1, T2, T3>(Action<T1, T2, T3> @delegate)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3>.Create(@delegate);

        /// <summary>
        /// 创建绑定静态方法的Lumin委托
        /// </summary>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3> CreateAction<TTarget, T1, T2, T3>(string methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3>.Create(methodName, methodNameHash);

        /// <summary>
        /// 创建绑定静态方法的Lumin委托
        /// </summary>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3> CreateAction<TTarget, T1, T2, T3>(ReadOnlySpan<char> methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3>.Create(methodName.ToString(), methodNameHash);

        #endregion

        #region LuminAction<TTarget, T1, T2, T3, T4>

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托
        /// </summary>
        /// <param name="target">委托绑定的实例（值类型或引用类型）</param>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3, T4> CreateAction<TTarget, T1, T2, T3, T4>(TTarget? target, string methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3, T4>.Create(ref target, methodName, methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（显式指定目标类型）
        /// 用于解决虚方法GetType开销
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="targetType">查找实例的类型</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#if NET8_0_OR_GREATER
        public static LuminAction<TTarget, T1, T2, T3, T4> CreateAction<TTarget, T1, T2, T3, T4>(TTarget? target, string methodName, [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type targetType, int methodNameHash = 0)
#else
        public static LuminAction<TTarget, T1, T2, T3, T4> CreateAction<TTarget, T1, T2, T3, T4>(TTarget? target, string methodName, Type targetType, int methodNameHash = 0)
#endif
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3, T4>.Create(ref target, methodName, targetType, methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（避免字符串分配）
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名（只读字符范围）</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3, T4> CreateAction<TTarget, T1, T2, T3, T4>(TTarget? target, ReadOnlySpan<char> methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct
#endif
            => CreateAction<TTarget, T1, T2, T3, T4>(target, methodName.ToString(), methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（显式指定目标类型 + 避免字符串分配）
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名（只读字符范围）</param>
        /// <param name="targetType">绑定实例的类型</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#if NET8_0_OR_GREATER
        public static LuminAction<TTarget, T1, T2, T3, T4> CreateAction<TTarget, T1, T2, T3, T4>(TTarget? target, ReadOnlySpan<char> methodName, [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type targetType, int methodNameHash = 0)
#else
        public static LuminAction<TTarget, T1, T2, T3, T4> CreateAction<TTarget, T1, T2, T3, T4>(TTarget? target, ReadOnlySpan<char> methodName, Type targetType, int methodNameHash = 0)
#endif
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct
#endif
            => CreateAction<TTarget, T1, T2, T3, T4>(target, methodName.ToString(), targetType, methodNameHash);

        /// <summary>
        /// 从现有委托创建 Lumin 委托
        /// </summary>
        /// <param name="delegate">现有的 .NET 委托</param>
        /// <returns>等价的 Lumin 委托</returns>
        [Obsolete("直接由委托隐式创建实例可能引发额外的 GC 压力与性能损耗，请显式传入对象实例和方法名以避免装箱与捕获成本。")]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3, T4> CreateAction<TTarget, T1, T2, T3, T4>(Delegate @delegate)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3, T4>.Create(@delegate);

        /// <summary>
        /// 从现有委托创建 Lumin 委托
        /// </summary>
        /// <param name="delegate">现有的 .NET 委托</param>
        /// <returns>等价的 Lumin 委托</returns>
        [Obsolete("直接由委托隐式创建实例可能引发额外的 GC 压力与性能损耗，请显式传入对象实例和方法名以避免装箱与捕获成本。")]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3, T4> CreateAction<TTarget, T1, T2, T3, T4>(Action<T1, T2, T3, T4> @delegate)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3, T4>.Create(@delegate);

        /// <summary>
        /// 创建绑定静态方法的Lumin委托
        /// </summary>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3, T4> CreateAction<TTarget, T1, T2, T3, T4>(string methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3, T4>.Create(methodName, methodNameHash);

        /// <summary>
        /// 创建绑定静态方法的Lumin委托
        /// </summary>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3, T4> CreateAction<TTarget, T1, T2, T3, T4>(ReadOnlySpan<char> methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3, T4>.Create(methodName.ToString(), methodNameHash);

        #endregion

        #region LuminAction<TTarget, T1, T2, T3, T4, T5>

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托
        /// </summary>
        /// <param name="target">委托绑定的实例（值类型或引用类型）</param>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3, T4, T5> CreateAction<TTarget, T1, T2, T3, T4, T5>(TTarget? target, string methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3, T4, T5>.Create(ref target, methodName, methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（显式指定目标类型）
        /// 用于解决虚方法GetType开销
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="targetType">查找实例的类型</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#if NET8_0_OR_GREATER
        public static LuminAction<TTarget, T1, T2, T3, T4, T5> CreateAction<TTarget, T1, T2, T3, T4, T5>(TTarget? target, string methodName, [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type targetType, int methodNameHash = 0)
#else
        public static LuminAction<TTarget, T1, T2, T3, T4, T5> CreateAction<TTarget, T1, T2, T3, T4, T5>(TTarget? target, string methodName, Type targetType, int methodNameHash = 0)
#endif
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3, T4, T5>.Create(ref target, methodName, targetType, methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（避免字符串分配）
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名（只读字符范围）</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3, T4, T5> CreateAction<TTarget, T1, T2, T3, T4, T5>(TTarget? target, ReadOnlySpan<char> methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct
#endif
            => CreateAction<TTarget, T1, T2, T3, T4, T5>(target, methodName.ToString(), methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（显式指定目标类型 + 避免字符串分配）
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名（只读字符范围）</param>
        /// <param name="targetType">绑定实例的类型</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#if NET8_0_OR_GREATER
        public static LuminAction<TTarget, T1, T2, T3, T4, T5> CreateAction<TTarget, T1, T2, T3, T4, T5>(TTarget? target, ReadOnlySpan<char> methodName, [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type targetType, int methodNameHash = 0)
#else
        public static LuminAction<TTarget, T1, T2, T3, T4, T5> CreateAction<TTarget, T1, T2, T3, T4, T5>(TTarget? target, ReadOnlySpan<char> methodName, Type targetType, int methodNameHash = 0)
#endif
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct
#endif
            => CreateAction<TTarget, T1, T2, T3, T4, T5>(target, methodName.ToString(), targetType, methodNameHash);

        /// <summary>
        /// 从现有委托创建 Lumin 委托
        /// </summary>
        /// <param name="delegate">现有的 .NET 委托</param>
        /// <returns>等价的 Lumin 委托</returns>
        [Obsolete("直接由委托隐式创建实例可能引发额外的 GC 压力与性能损耗，请显式传入对象实例和方法名以避免装箱与捕获成本。")]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3, T4, T5> CreateAction<TTarget, T1, T2, T3, T4, T5>(Delegate @delegate)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3, T4, T5>.Create(@delegate);

        /// <summary>
        /// 从现有委托创建 Lumin 委托
        /// </summary>
        /// <param name="delegate">现有的 .NET 委托</param>
        /// <returns>等价的 Lumin 委托</returns>
        [Obsolete("直接由委托隐式创建实例可能引发额外的 GC 压力与性能损耗，请显式传入对象实例和方法名以避免装箱与捕获成本。")]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3, T4, T5> CreateAction<TTarget, T1, T2, T3, T4, T5>(Action<T1, T2, T3, T4, T5> @delegate)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3, T4, T5>.Create(@delegate);

        /// <summary>
        /// 创建绑定静态方法的Lumin委托
        /// </summary>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3, T4, T5> CreateAction<TTarget, T1, T2, T3, T4, T5>(string methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3, T4, T5>.Create(methodName, methodNameHash);

        /// <summary>
        /// 创建绑定静态方法的Lumin委托
        /// </summary>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3, T4, T5> CreateAction<TTarget, T1, T2, T3, T4, T5>(ReadOnlySpan<char> methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3, T4, T5>.Create(methodName.ToString(), methodNameHash);

        #endregion

        #region LuminAction<TTarget, T1, T2, T3, T4, T5, T6>

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托
        /// </summary>
        /// <param name="target">委托绑定的实例（值类型或引用类型）</param>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6> CreateAction<TTarget, T1, T2, T3, T4, T5, T6>(TTarget? target, string methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3, T4, T5, T6>.Create(ref target, methodName, methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（显式指定目标类型）
        /// 用于解决虚方法GetType开销
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="targetType">查找实例的类型</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#if NET8_0_OR_GREATER
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6> CreateAction<TTarget, T1, T2, T3, T4, T5, T6>(TTarget? target, string methodName, [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type targetType, int methodNameHash = 0)
#else
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6> CreateAction<TTarget, T1, T2, T3, T4, T5, T6>(TTarget? target, string methodName, Type targetType, int methodNameHash = 0)
#endif
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3, T4, T5, T6>.Create(ref target, methodName, targetType, methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（避免字符串分配）
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名（只读字符范围）</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6> CreateAction<TTarget, T1, T2, T3, T4, T5, T6>(TTarget? target, ReadOnlySpan<char> methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct
#endif
            => CreateAction<TTarget, T1, T2, T3, T4, T5, T6>(target, methodName.ToString(), methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（显式指定目标类型 + 避免字符串分配）
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名（只读字符范围）</param>
        /// <param name="targetType">绑定实例的类型</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#if NET8_0_OR_GREATER
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6> CreateAction<TTarget, T1, T2, T3, T4, T5, T6>(TTarget? target, ReadOnlySpan<char> methodName, [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type targetType, int methodNameHash = 0)
#else
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6> CreateAction<TTarget, T1, T2, T3, T4, T5, T6>(TTarget? target, ReadOnlySpan<char> methodName, Type targetType, int methodNameHash = 0)
#endif
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct
#endif
            => CreateAction<TTarget, T1, T2, T3, T4, T5, T6>(target, methodName.ToString(), targetType, methodNameHash);

        /// <summary>
        /// 从现有委托创建 Lumin 委托
        /// </summary>
        /// <param name="delegate">现有的 .NET 委托</param>
        /// <returns>等价的 Lumin 委托</returns>
        [Obsolete("直接由委托隐式创建实例可能引发额外的 GC 压力与性能损耗，请显式传入对象实例和方法名以避免装箱与捕获成本。")]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6> CreateAction<TTarget, T1, T2, T3, T4, T5, T6>(Delegate @delegate)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3, T4, T5, T6>.Create(@delegate);

        /// <summary>
        /// 从现有委托创建 Lumin 委托
        /// </summary>
        /// <param name="delegate">现有的 .NET 委托</param>
        /// <returns>等价的 Lumin 委托</returns>
        [Obsolete("直接由委托隐式创建实例可能引发额外的 GC 压力与性能损耗，请显式传入对象实例和方法名以避免装箱与捕获成本。")]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6> CreateAction<TTarget, T1, T2, T3, T4, T5, T6>(Action<T1, T2, T3, T4, T5, T6> @delegate)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3, T4, T5, T6>.Create(@delegate);

        /// <summary>
        /// 创建绑定静态方法的Lumin委托
        /// </summary>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6> CreateAction<TTarget, T1, T2, T3, T4, T5, T6>(string methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3, T4, T5, T6>.Create(methodName, methodNameHash);

        /// <summary>
        /// 创建绑定静态方法的Lumin委托
        /// </summary>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6> CreateAction<TTarget, T1, T2, T3, T4, T5, T6>(ReadOnlySpan<char> methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3, T4, T5, T6>.Create(methodName.ToString(), methodNameHash);

        #endregion

        #region LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7>

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托
        /// </summary>
        /// <param name="target">委托绑定的实例（值类型或引用类型）</param>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7>(TTarget? target, string methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7>.Create(ref target, methodName, methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（显式指定目标类型）
        /// 用于解决虚方法GetType开销
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="targetType">查找实例的类型</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#if NET8_0_OR_GREATER
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7>(TTarget? target, string methodName, [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type targetType, int methodNameHash = 0)
#else
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7>(TTarget? target, string methodName, Type targetType, int methodNameHash = 0)
#endif
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7>.Create(ref target, methodName, targetType, methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（避免字符串分配）
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名（只读字符范围）</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7>(TTarget? target, ReadOnlySpan<char> methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct
#endif
            => CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7>(target, methodName.ToString(), methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（显式指定目标类型 + 避免字符串分配）
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名（只读字符范围）</param>
        /// <param name="targetType">绑定实例的类型</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#if NET8_0_OR_GREATER
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7>(TTarget? target, ReadOnlySpan<char> methodName, [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type targetType, int methodNameHash = 0)
#else
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7>(TTarget? target, ReadOnlySpan<char> methodName, Type targetType, int methodNameHash = 0)
#endif
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct
#endif
            => CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7>(target, methodName.ToString(), targetType, methodNameHash);

        /// <summary>
        /// 从现有委托创建 Lumin 委托
        /// </summary>
        /// <param name="delegate">现有的 .NET 委托</param>
        /// <returns>等价的 Lumin 委托</returns>
        [Obsolete("直接由委托隐式创建实例可能引发额外的 GC 压力与性能损耗，请显式传入对象实例和方法名以避免装箱与捕获成本。")]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7>(Delegate @delegate)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7>.Create(@delegate);

        /// <summary>
        /// 从现有委托创建 Lumin 委托
        /// </summary>
        /// <param name="delegate">现有的 .NET 委托</param>
        /// <returns>等价的 Lumin 委托</returns>
        [Obsolete("直接由委托隐式创建实例可能引发额外的 GC 压力与性能损耗，请显式传入对象实例和方法名以避免装箱与捕获成本。")]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7>(Action<T1, T2, T3, T4, T5, T6, T7> @delegate)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7>.Create(@delegate);

        /// <summary>
        /// 创建绑定静态方法的Lumin委托
        /// </summary>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7>(string methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7>.Create(methodName, methodNameHash);

        /// <summary>
        /// 创建绑定静态方法的Lumin委托
        /// </summary>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7>(ReadOnlySpan<char> methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7>.Create(methodName.ToString(), methodNameHash);

        #endregion

        #region LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8>

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托
        /// </summary>
        /// <param name="target">委托绑定的实例（值类型或引用类型）</param>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8>(TTarget? target, string methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8>.Create(ref target, methodName, methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（显式指定目标类型）
        /// 用于解决虚方法GetType开销
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="targetType">查找实例的类型</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#if NET8_0_OR_GREATER
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8>(TTarget? target, string methodName, [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type targetType, int methodNameHash = 0)
#else
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8>(TTarget? target, string methodName, Type targetType, int methodNameHash = 0)
#endif
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8>.Create(ref target, methodName, targetType, methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（避免字符串分配）
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名（只读字符范围）</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8>(TTarget? target, ReadOnlySpan<char> methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct
#endif
            => CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8>(target, methodName.ToString(), methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（显式指定目标类型 + 避免字符串分配）
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名（只读字符范围）</param>
        /// <param name="targetType">绑定实例的类型</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#if NET8_0_OR_GREATER
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8>(TTarget? target, ReadOnlySpan<char> methodName, [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type targetType, int methodNameHash = 0)
#else
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8>(TTarget? target, ReadOnlySpan<char> methodName, Type targetType, int methodNameHash = 0)
#endif
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct
#endif
            => CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8>(target, methodName.ToString(), targetType, methodNameHash);

        /// <summary>
        /// 从现有委托创建 Lumin 委托
        /// </summary>
        /// <param name="delegate">现有的 .NET 委托</param>
        /// <returns>等价的 Lumin 委托</returns>
        [Obsolete("直接由委托隐式创建实例可能引发额外的 GC 压力与性能损耗，请显式传入对象实例和方法名以避免装箱与捕获成本。")]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8>(Delegate @delegate)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8>.Create(@delegate);

        /// <summary>
        /// 从现有委托创建 Lumin 委托
        /// </summary>
        /// <param name="delegate">现有的 .NET 委托</param>
        /// <returns>等价的 Lumin 委托</returns>
        [Obsolete("直接由委托隐式创建实例可能引发额外的 GC 压力与性能损耗，请显式传入对象实例和方法名以避免装箱与捕获成本。")]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8>(Action<T1, T2, T3, T4, T5, T6, T7, T8> @delegate)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8>.Create(@delegate);

        /// <summary>
        /// 创建绑定静态方法的Lumin委托
        /// </summary>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8>(string methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8>.Create(methodName, methodNameHash);

        /// <summary>
        /// 创建绑定静态方法的Lumin委托
        /// </summary>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8>(ReadOnlySpan<char> methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8>.Create(methodName.ToString(), methodNameHash);

        #endregion

        #region LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9>

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托
        /// </summary>
        /// <param name="target">委托绑定的实例（值类型或引用类型）</param>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9>(TTarget? target, string methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9>.Create(ref target, methodName, methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（显式指定目标类型）
        /// 用于解决虚方法GetType开销
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="targetType">查找实例的类型</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#if NET8_0_OR_GREATER
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9>(TTarget? target, string methodName, [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type targetType, int methodNameHash = 0)
#else
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9>(TTarget? target, string methodName, Type targetType, int methodNameHash = 0)
#endif
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9>.Create(ref target, methodName, targetType, methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（避免字符串分配）
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名（只读字符范围）</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9>(TTarget? target, ReadOnlySpan<char> methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct
#endif
            => CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9>(target, methodName.ToString(), methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（显式指定目标类型 + 避免字符串分配）
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名（只读字符范围）</param>
        /// <param name="targetType">绑定实例的类型</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#if NET8_0_OR_GREATER
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9>(TTarget? target, ReadOnlySpan<char> methodName, [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type targetType, int methodNameHash = 0)
#else
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9>(TTarget? target, ReadOnlySpan<char> methodName, Type targetType, int methodNameHash = 0)
#endif
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct
#endif
            => CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9>(target, methodName.ToString(), targetType, methodNameHash);

        /// <summary>
        /// 从现有委托创建 Lumin 委托
        /// </summary>
        /// <param name="delegate">现有的 .NET 委托</param>
        /// <returns>等价的 Lumin 委托</returns>
        [Obsolete("直接由委托隐式创建实例可能引发额外的 GC 压力与性能损耗，请显式传入对象实例和方法名以避免装箱与捕获成本。")]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9>(Delegate @delegate)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9>.Create(@delegate);

        /// <summary>
        /// 从现有委托创建 Lumin 委托
        /// </summary>
        /// <param name="delegate">现有的 .NET 委托</param>
        /// <returns>等价的 Lumin 委托</returns>
        [Obsolete("直接由委托隐式创建实例可能引发额外的 GC 压力与性能损耗，请显式传入对象实例和方法名以避免装箱与捕获成本。")]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9>(Action<T1, T2, T3, T4, T5, T6, T7, T8, T9> @delegate)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9>.Create(@delegate);

        /// <summary>
        /// 创建绑定静态方法的Lumin委托
        /// </summary>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9>(string methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9>.Create(methodName, methodNameHash);

        /// <summary>
        /// 创建绑定静态方法的Lumin委托
        /// </summary>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9>(ReadOnlySpan<char> methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9>.Create(methodName.ToString(), methodNameHash);

        #endregion

        #region LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托
        /// </summary>
        /// <param name="target">委托绑定的实例（值类型或引用类型）</param>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(TTarget? target, string methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.Create(ref target, methodName, methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（显式指定目标类型）
        /// 用于解决虚方法GetType开销
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="targetType">查找实例的类型</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#if NET8_0_OR_GREATER
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(TTarget? target, string methodName, [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type targetType, int methodNameHash = 0)
#else
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(TTarget? target, string methodName, Type targetType, int methodNameHash = 0)
#endif
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.Create(ref target, methodName, targetType, methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（避免字符串分配）
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名（只读字符范围）</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(TTarget? target, ReadOnlySpan<char> methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct
#endif
            => CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(target, methodName.ToString(), methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（显式指定目标类型 + 避免字符串分配）
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名（只读字符范围）</param>
        /// <param name="targetType">绑定实例的类型</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#if NET8_0_OR_GREATER
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(TTarget? target, ReadOnlySpan<char> methodName, [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type targetType, int methodNameHash = 0)
#else
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(TTarget? target, ReadOnlySpan<char> methodName, Type targetType, int methodNameHash = 0)
#endif
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct
#endif
            => CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(target, methodName.ToString(), targetType, methodNameHash);

        /// <summary>
        /// 从现有委托创建 Lumin 委托
        /// </summary>
        /// <param name="delegate">现有的 .NET 委托</param>
        /// <returns>等价的 Lumin 委托</returns>
        [Obsolete("直接由委托隐式创建实例可能引发额外的 GC 压力与性能损耗，请显式传入对象实例和方法名以避免装箱与捕获成本。")]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(Delegate @delegate)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.Create(@delegate);

        /// <summary>
        /// 从现有委托创建 Lumin 委托
        /// </summary>
        /// <param name="delegate">现有的 .NET 委托</param>
        /// <returns>等价的 Lumin 委托</returns>
        [Obsolete("直接由委托隐式创建实例可能引发额外的 GC 压力与性能损耗，请显式传入对象实例和方法名以避免装箱与捕获成本。")]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(Action<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> @delegate)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.Create(@delegate);

        /// <summary>
        /// 创建绑定静态方法的Lumin委托
        /// </summary>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(string methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.Create(methodName, methodNameHash);

        /// <summary>
        /// 创建绑定静态方法的Lumin委托
        /// </summary>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(ReadOnlySpan<char> methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.Create(methodName.ToString(), methodNameHash);

        #endregion

        #region LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托
        /// </summary>
        /// <param name="target">委托绑定的实例（值类型或引用类型）</param>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(TTarget? target, string methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>.Create(ref target, methodName, methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（显式指定目标类型）
        /// 用于解决虚方法GetType开销
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="targetType">查找实例的类型</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#if NET8_0_OR_GREATER
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(TTarget? target, string methodName, [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type targetType, int methodNameHash = 0)
#else
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(TTarget? target, string methodName, Type targetType, int methodNameHash = 0)
#endif
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>.Create(ref target, methodName, targetType, methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（避免字符串分配）
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名（只读字符范围）</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(TTarget? target, ReadOnlySpan<char> methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct
#endif
            => CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(target, methodName.ToString(), methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（显式指定目标类型 + 避免字符串分配）
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名（只读字符范围）</param>
        /// <param name="targetType">绑定实例的类型</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#if NET8_0_OR_GREATER
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(TTarget? target, ReadOnlySpan<char> methodName, [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type targetType, int methodNameHash = 0)
#else
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(TTarget? target, ReadOnlySpan<char> methodName, Type targetType, int methodNameHash = 0)
#endif
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct
#endif
            => CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(target, methodName.ToString(), targetType, methodNameHash);

        /// <summary>
        /// 从现有委托创建 Lumin 委托
        /// </summary>
        /// <param name="delegate">现有的 .NET 委托</param>
        /// <returns>等价的 Lumin 委托</returns>
        [Obsolete("直接由委托隐式创建实例可能引发额外的 GC 压力与性能损耗，请显式传入对象实例和方法名以避免装箱与捕获成本。")]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(Delegate @delegate)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>.Create(@delegate);

        /// <summary>
        /// 从现有委托创建 Lumin 委托
        /// </summary>
        /// <param name="delegate">现有的 .NET 委托</param>
        /// <returns>等价的 Lumin 委托</returns>
        [Obsolete("直接由委托隐式创建实例可能引发额外的 GC 压力与性能损耗，请显式传入对象实例和方法名以避免装箱与捕获成本。")]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(Action<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> @delegate)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>.Create(@delegate);

        /// <summary>
        /// 创建绑定静态方法的Lumin委托
        /// </summary>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(string methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>.Create(methodName, methodNameHash);

        /// <summary>
        /// 创建绑定静态方法的Lumin委托
        /// </summary>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(ReadOnlySpan<char> methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>.Create(methodName.ToString(), methodNameHash);

        #endregion

        #region LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托
        /// </summary>
        /// <param name="target">委托绑定的实例（值类型或引用类型）</param>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(TTarget? target, string methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct where T12 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>.Create(ref target, methodName, methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（显式指定目标类型）
        /// 用于解决虚方法GetType开销
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="targetType">查找实例的类型</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#if NET8_0_OR_GREATER
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(TTarget? target, string methodName, [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type targetType, int methodNameHash = 0)
#else
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(TTarget? target, string methodName, Type targetType, int methodNameHash = 0)
#endif
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct where T12 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>.Create(ref target, methodName, targetType, methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（避免字符串分配）
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名（只读字符范围）</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(TTarget? target, ReadOnlySpan<char> methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct where T12 : allows ref struct
#endif
            => CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(target, methodName.ToString(), methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（显式指定目标类型 + 避免字符串分配）
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名（只读字符范围）</param>
        /// <param name="targetType">绑定实例的类型</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#if NET8_0_OR_GREATER
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(TTarget? target, ReadOnlySpan<char> methodName, [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type targetType, int methodNameHash = 0)
#else
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(TTarget? target, ReadOnlySpan<char> methodName, Type targetType, int methodNameHash = 0)
#endif
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct where T12 : allows ref struct
#endif
            => CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(target, methodName.ToString(), targetType, methodNameHash);

        /// <summary>
        /// 从现有委托创建 Lumin 委托
        /// </summary>
        /// <param name="delegate">现有的 .NET 委托</param>
        /// <returns>等价的 Lumin 委托</returns>
        [Obsolete("直接由委托隐式创建实例可能引发额外的 GC 压力与性能损耗，请显式传入对象实例和方法名以避免装箱与捕获成本。")]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(Delegate @delegate)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct where T12 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>.Create(@delegate);

        /// <summary>
        /// 从现有委托创建 Lumin 委托
        /// </summary>
        /// <param name="delegate">现有的 .NET 委托</param>
        /// <returns>等价的 Lumin 委托</returns>
        [Obsolete("直接由委托隐式创建实例可能引发额外的 GC 压力与性能损耗，请显式传入对象实例和方法名以避免装箱与捕获成本。")]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(Action<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> @delegate)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct where T12 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>.Create(@delegate);

        /// <summary>
        /// 创建绑定静态方法的Lumin委托
        /// </summary>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(string methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct where T12 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>.Create(methodName, methodNameHash);

        /// <summary>
        /// 创建绑定静态方法的Lumin委托
        /// </summary>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(ReadOnlySpan<char> methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct where T12 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>.Create(methodName.ToString(), methodNameHash);

        #endregion

        #region LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托
        /// </summary>
        /// <param name="target">委托绑定的实例（值类型或引用类型）</param>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(TTarget? target, string methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct where T12 : allows ref struct where T13 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>.Create(ref target, methodName, methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（显式指定目标类型）
        /// 用于解决虚方法GetType开销
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="targetType">查找实例的类型</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#if NET8_0_OR_GREATER
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(TTarget? target, string methodName, [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type targetType, int methodNameHash = 0)
#else
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(TTarget? target, string methodName, Type targetType, int methodNameHash = 0)
#endif
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct where T12 : allows ref struct where T13 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>.Create(ref target, methodName, targetType, methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（避免字符串分配）
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名（只读字符范围）</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(TTarget? target, ReadOnlySpan<char> methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct where T12 : allows ref struct where T13 : allows ref struct
#endif
            => CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(target, methodName.ToString(), methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（显式指定目标类型 + 避免字符串分配）
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名（只读字符范围）</param>
        /// <param name="targetType">绑定实例的类型</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#if NET8_0_OR_GREATER
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(TTarget? target, ReadOnlySpan<char> methodName, [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type targetType, int methodNameHash = 0)
#else
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(TTarget? target, ReadOnlySpan<char> methodName, Type targetType, int methodNameHash = 0)
#endif
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct where T12 : allows ref struct where T13 : allows ref struct
#endif
            => CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(target, methodName.ToString(), targetType, methodNameHash);

        /// <summary>
        /// 从现有委托创建 Lumin 委托
        /// </summary>
        /// <param name="delegate">现有的 .NET 委托</param>
        /// <returns>等价的 Lumin 委托</returns>
        [Obsolete("直接由委托隐式创建实例可能引发额外的 GC 压力与性能损耗，请显式传入对象实例和方法名以避免装箱与捕获成本。")]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(Delegate @delegate)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct where T12 : allows ref struct where T13 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>.Create(@delegate);

        /// <summary>
        /// 从现有委托创建 Lumin 委托
        /// </summary>
        /// <param name="delegate">现有的 .NET 委托</param>
        /// <returns>等价的 Lumin 委托</returns>
        [Obsolete("直接由委托隐式创建实例可能引发额外的 GC 压力与性能损耗，请显式传入对象实例和方法名以避免装箱与捕获成本。")]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(Action<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> @delegate)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct where T12 : allows ref struct where T13 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>.Create(@delegate);

        /// <summary>
        /// 创建绑定静态方法的Lumin委托
        /// </summary>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(string methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct where T12 : allows ref struct where T13 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>.Create(methodName, methodNameHash);

        /// <summary>
        /// 创建绑定静态方法的Lumin委托
        /// </summary>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(ReadOnlySpan<char> methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct where T12 : allows ref struct where T13 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>.Create(methodName.ToString(), methodNameHash);

        #endregion

        #region LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托
        /// </summary>
        /// <param name="target">委托绑定的实例（值类型或引用类型）</param>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(TTarget? target, string methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct where T12 : allows ref struct where T13 : allows ref struct where T14 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>.Create(ref target, methodName, methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（显式指定目标类型）
        /// 用于解决虚方法GetType开销
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="targetType">查找实例的类型</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#if NET8_0_OR_GREATER
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(TTarget? target, string methodName, [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type targetType, int methodNameHash = 0)
#else
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(TTarget? target, string methodName, Type targetType, int methodNameHash = 0)
#endif
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct where T12 : allows ref struct where T13 : allows ref struct where T14 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>.Create(ref target, methodName, targetType, methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（避免字符串分配）
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名（只读字符范围）</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(TTarget? target, ReadOnlySpan<char> methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct where T12 : allows ref struct where T13 : allows ref struct where T14 : allows ref struct
#endif
            => CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(target, methodName.ToString(), methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（显式指定目标类型 + 避免字符串分配）
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名（只读字符范围）</param>
        /// <param name="targetType">绑定实例的类型</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#if NET8_0_OR_GREATER
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(TTarget? target, ReadOnlySpan<char> methodName, [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type targetType, int methodNameHash = 0)
#else
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(TTarget? target, ReadOnlySpan<char> methodName, Type targetType, int methodNameHash = 0)
#endif
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct where T12 : allows ref struct where T13 : allows ref struct where T14 : allows ref struct
#endif
            => CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(target, methodName.ToString(), targetType, methodNameHash);

        /// <summary>
        /// 从现有委托创建 Lumin 委托
        /// </summary>
        /// <param name="delegate">现有的 .NET 委托</param>
        /// <returns>等价的 Lumin 委托</returns>
        [Obsolete("直接由委托隐式创建实例可能引发额外的 GC 压力与性能损耗，请显式传入对象实例和方法名以避免装箱与捕获成本。")]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(Delegate @delegate)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct where T12 : allows ref struct where T13 : allows ref struct where T14 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>.Create(@delegate);

        /// <summary>
        /// 从现有委托创建 Lumin 委托
        /// </summary>
        /// <param name="delegate">现有的 .NET 委托</param>
        /// <returns>等价的 Lumin 委托</returns>
        [Obsolete("直接由委托隐式创建实例可能引发额外的 GC 压力与性能损耗，请显式传入对象实例和方法名以避免装箱与捕获成本。")]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(Action<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> @delegate)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct where T12 : allows ref struct where T13 : allows ref struct where T14 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>.Create(@delegate);

        /// <summary>
        /// 创建绑定静态方法的Lumin委托
        /// </summary>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(string methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct where T12 : allows ref struct where T13 : allows ref struct where T14 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>.Create(methodName, methodNameHash);

        /// <summary>
        /// 创建绑定静态方法的Lumin委托
        /// </summary>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(ReadOnlySpan<char> methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct where T12 : allows ref struct where T13 : allows ref struct where T14 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>.Create(methodName.ToString(), methodNameHash);

        #endregion

        #region LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托
        /// </summary>
        /// <param name="target">委托绑定的实例（值类型或引用类型）</param>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(TTarget? target, string methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct where T12 : allows ref struct where T13 : allows ref struct where T14 : allows ref struct where T15 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>.Create(ref target, methodName, methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（显式指定目标类型）
        /// 用于解决虚方法GetType开销
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="targetType">查找实例的类型</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#if NET8_0_OR_GREATER
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(TTarget? target, string methodName, [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type targetType, int methodNameHash = 0)
#else
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(TTarget? target, string methodName, Type targetType, int methodNameHash = 0)
#endif
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct where T12 : allows ref struct where T13 : allows ref struct where T14 : allows ref struct where T15 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>.Create(ref target, methodName, targetType, methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（避免字符串分配）
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名（只读字符范围）</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(TTarget? target, ReadOnlySpan<char> methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct where T12 : allows ref struct where T13 : allows ref struct where T14 : allows ref struct where T15 : allows ref struct
#endif
            => CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(target, methodName.ToString(), methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（显式指定目标类型 + 避免字符串分配）
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名（只读字符范围）</param>
        /// <param name="targetType">绑定实例的类型</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#if NET8_0_OR_GREATER
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(TTarget? target, ReadOnlySpan<char> methodName, [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type targetType, int methodNameHash = 0)
#else
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(TTarget? target, ReadOnlySpan<char> methodName, Type targetType, int methodNameHash = 0)
#endif
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct where T12 : allows ref struct where T13 : allows ref struct where T14 : allows ref struct where T15 : allows ref struct
#endif
            => CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(target, methodName.ToString(), targetType, methodNameHash);

        /// <summary>
        /// 从现有委托创建 Lumin 委托
        /// </summary>
        /// <param name="delegate">现有的 .NET 委托</param>
        /// <returns>等价的 Lumin 委托</returns>
        [Obsolete("直接由委托隐式创建实例可能引发额外的 GC 压力与性能损耗，请显式传入对象实例和方法名以避免装箱与捕获成本。")]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(Delegate @delegate)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct where T12 : allows ref struct where T13 : allows ref struct where T14 : allows ref struct where T15 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>.Create(@delegate);

        /// <summary>
        /// 从现有委托创建 Lumin 委托
        /// </summary>
        /// <param name="delegate">现有的 .NET 委托</param>
        /// <returns>等价的 Lumin 委托</returns>
        [Obsolete("直接由委托隐式创建实例可能引发额外的 GC 压力与性能损耗，请显式传入对象实例和方法名以避免装箱与捕获成本。")]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(Action<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> @delegate)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct where T12 : allows ref struct where T13 : allows ref struct where T14 : allows ref struct where T15 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>.Create(@delegate);

        /// <summary>
        /// 创建绑定静态方法的Lumin委托
        /// </summary>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(string methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct where T12 : allows ref struct where T13 : allows ref struct where T14 : allows ref struct where T15 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>.Create(methodName, methodNameHash);

        /// <summary>
        /// 创建绑定静态方法的Lumin委托
        /// </summary>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> CreateAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(ReadOnlySpan<char> methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct where T12 : allows ref struct where T13 : allows ref struct where T14 : allows ref struct where T15 : allows ref struct
#endif
            => LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>.Create(methodName.ToString(), methodNameHash);

        #endregion

    }
}