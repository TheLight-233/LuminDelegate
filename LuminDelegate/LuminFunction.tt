<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
// <auto-generated>
//     This code was generated by a T4 template.
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>

using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;

using static LuminDelegates.LuminDelegate;

#nullable enable
namespace LuminDelegates;

<# 
    for (int paramCount = 0; paramCount <= 15; paramCount++) 
    {
        var typeParams = paramCount == 0 
            ? "<TResult>" 
            : "<" + string.Join(", ", Enumerable.Range(1, paramCount).Select(i => "T" + i)) + ", TResult>";
            
        var genericParams = paramCount == 0 
            ? "TResult" 
            : string.Join(", ", Enumerable.Range(1, paramCount).Select(i => "T" + i)) + ", TResult";
            
        var methodKeyParams = string.Join(", ", Enumerable.Range(1, 15).Select(i => 
            i <= paramCount ? $"typeof(T{i}).TypeHandle" : "default"));
#>

[StructLayout(LayoutKind.Sequential, Pack = 1)]
public unsafe struct LuminFunction<
#if NET8_0_OR_GREATER
[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)]
#endif
TTarget, <#= genericParams #>> : IDisposable, ICloneable, ISerializable, IEquatable<LuminFunction<TTarget, <#= genericParams #>>>
#if NET9_0_OR_GREATER
    where TTarget : allows ref struct
    where TResult : allows ref struct
<# if(paramCount > 0) { #>
    <#= string.Join("\n    ", Enumerable.Range(1, paramCount).Select(i => $"where T{i} : allows ref struct")) #>
<# } #>
#endif
{
    private void* _targetPointer; <#= paramCount == 0 ? "// 值类型对象" : "" #>
    private object? _referenceTarget; <#= paramCount == 0 ? "// 引用类型对象" : "" #>
    private readonly IntPtr _methodPtr;
    private readonly bool _isStatic;
    private readonly MethodInfo _method;
    private bool _disposed;

    private static readonly bool IsValueType = typeof(TTarget).IsValueType;
    
    public TTarget? Target
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            ThrowIfDisposed();
            
            if (_isStatic)
                return default;
            
            if (IsValueType)
                return Unsafe.AsRef<TTarget?>(_targetPointer);
            
            var target = _referenceTarget;
            return Unsafe.As<object?, TTarget?>(ref target);
        }
    }
    
    public MethodInfo Method => _method;

    #region Constructors
    
    private LuminFunction(MethodCache method)
    {
        _method = method.MethodBase ?? throw new ArgumentNullException(nameof(method));
        _isStatic = method.IsStatic;
        _methodPtr = method.MethodPtr;

        if (!_isStatic)
            throw new ArgumentException("methods are not static!", method.MethodBase.Name);
        
        _referenceTarget = null;
        _targetPointer = null;
    }
    
    private LuminFunction(scoped ref TTarget? target, MethodCache method)
    {
        _method = method.MethodBase ?? throw new ArgumentNullException(nameof(method));
        _isStatic = method.IsStatic;
        _methodPtr = method.MethodPtr;
        _referenceTarget = null;

        if (!_isStatic)
        {
            if (IsValueType)
            {
#if NET8_0_OR_GREATER
                if (Unsafe.IsNullRef(ref target))
                    throw new ArgumentException("Target value instance cannot be null.", nameof(target));
#endif                

#if NET8_0_OR_GREATER
                _targetPointer = NativeMemory.Alloc((nuint)Unsafe.SizeOf<TTarget>());
#else
                _targetPointer = Marshal.AllocHGlobal(Unsafe.SizeOf<TTarget>()).ToPointer();
#endif
                Unsafe.CopyBlock(
                    _targetPointer,
                    Unsafe.AsPointer(ref target),
                    (uint)Unsafe.SizeOf<TTarget>()
                );
            }
            else
            {
                if (target is null)
                    throw new ArgumentException("Target instance object is null.", nameof(target));
                
                _referenceTarget = Unsafe.As<TTarget, object?>(ref target);
                
            }
        }
        else
        {
            _targetPointer = null;
        }
    }
    
    private LuminFunction(Delegate @delegate)
    {
        _method = @delegate.Method ?? throw new ArgumentNullException(nameof(@delegate.Method));
        _isStatic = @delegate.Method.IsStatic;
        _methodPtr = @delegate.Method.MethodHandle.GetFunctionPointer();
        _referenceTarget = null;
        
        var target = @delegate.Target;
        if (!_isStatic)
        {
            if (target is not TTarget)
                throw new ArgumentException("Target instance object is not type.", typeof(TTarget).Name);
                
            if (IsValueType)
            {
#if NET8_0_OR_GREATER
                if (Unsafe.IsNullRef(ref target))
                    throw new ArgumentException("Target value instance cannot be null.", nameof(target));
#endif
                
                var unboxedTarget = Unsafe.AsRef<TTarget>(Unsafe.AsPointer(ref target));
                
#if NET8_0_OR_GREATER
                _targetPointer = NativeMemory.Alloc((nuint)Unsafe.SizeOf<TTarget>());
#else
                _targetPointer = Marshal.AllocHGlobal(Unsafe.SizeOf<TTarget>()).ToPointer();
#endif
                Unsafe.CopyBlock(
                    _targetPointer,
                    Unsafe.AsPointer(ref unboxedTarget),
                    (uint)Unsafe.SizeOf<TTarget>()
                );
            }
            else
            {
                if (target is null)
                    throw new ArgumentException("Target instance object is null.", nameof(target));
                
                _referenceTarget = target;
            }
        }
        else
        {
            _targetPointer = null;
        }
    }

    #endregion
    
    #region Create Factory

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, <#= genericParams #>> Create(scoped ref TTarget? target, string methodName, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(IsValueType
                ? TargetTypeHandle
                : Unsafe.As<TTarget, object?>(ref target!)?.GetType().TypeHandle ?? TargetTypeHandle,
            methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        return new LuminFunction<TTarget, <#= genericParams #>>(ref target, method);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, <#= genericParams #>> Create(scoped ref TTarget? target, string methodName, Type targetType, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(targetType.TypeHandle, methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        return new LuminFunction<TTarget, <#= genericParams #>>(ref target, method);
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, <#= genericParams #>> Create(scoped ref TTarget? target, ReadOnlySpan<char> methodName, int methodNameHash = 0) =>
        Create(ref target, methodName.ToString(), methodNameHash);
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, <#= genericParams #>> Create(scoped ref TTarget? target, ReadOnlySpan<char> methodName, Type targetType, int methodNameHash = 0) =>
        Create(ref target, methodName.ToString(), targetType, methodNameHash);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, <#= genericParams #>> Create(Delegate @delegate) => 
        new LuminFunction<TTarget, <#= genericParams #>>(@delegate);
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminFunction<TTarget, <#= genericParams #>> Create(string methodName, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(TargetTypeHandle, methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        if (!method.IsStatic)
            throw new ArgumentException("Method is not static, please pass in instance as parameter.", nameof(methodName));
        
        return new LuminFunction<TTarget, <#= genericParams #>>(method);
    }

    #endregion
    
    #region Interface Implementation

    public void Dispose()
    {
        if (_disposed)
            return;
        
        
        if (IsValueType && !_isStatic && _targetPointer != null)
        {
#if NET8_0_OR_GREATER
            NativeMemory.Free(_targetPointer);
#else
            Marshal.FreeHGlobal(new IntPtr(_targetPointer));
#endif
        }
       
        _targetPointer = null;
        _referenceTarget = null;

        _disposed = true;
    }
    
    public object Clone()
    {
        ThrowIfDisposed();
        var target = _referenceTarget;
        if (target is null)
            throw new NullReferenceException("Target instance cannot be null.");
                
        return new LuminFunction<TTarget, <#= genericParams #>>(ref Unsafe.As<object?, TTarget>(ref target)!, new MethodCache(_isStatic, _methodPtr, _method));
    }

    public void GetObjectData(SerializationInfo info, StreamingContext context)
    {
        throw new NotSupportedException();
    }
    
    public override bool Equals(object? obj)
    {
        return obj is LuminFunction<TTarget, <#= genericParams #>> other && Equals(other);
    }

    public bool Equals(LuminFunction<TTarget, <#= genericParams #>> other)
    {
        ThrowIfDisposed();
        return _methodPtr == other._methodPtr &&
               _isStatic == other._isStatic &&
               _targetPointer == other._targetPointer;
    }

    public override int GetHashCode()
    {
        ThrowIfDisposed();
        unchecked
        {
            int hash = 17;
            hash = hash * 31 + _methodPtr.GetHashCode();
            hash = hash * 31 + _isStatic.GetHashCode();
            hash = hash * 31 + ((IntPtr)_targetPointer).GetHashCode();
            return hash;
        }
    }

    #endregion
    
    #region Implicit
    
    public static implicit operator LuminFunction<TTarget, <#= genericParams #>>(in Delegate func) 
        => Create(func);
<# if(paramCount == 0) { #>

    public static implicit operator LuminFunction<TTarget, TResult>(Func<TResult> func) => 
        Create(func);
<# } else { #>

    public static implicit operator LuminFunction<TTarget, <#= genericParams #>>(Func<<#= genericParams #>> func) => 
        Create(func);
<# } #>
    
    #endregion

    #region Invoke

    public object? DynamicInvoke(params object?[] args)
    {
        ThrowIfDisposed();
        
        if (_isStatic)
        {
            return _method.Invoke(null, args);
        }
        else
        {
            if (typeof(TTarget).IsByRefLike)
                throw new ArgumentException(
                    "The target type is a by-ref-like type and cannot be converted to a delegate.");

#if !NET9_0_OR_GREATER
            if (IsValueType)
                throw new ArgumentException("The target type is value type and cannot dynamic invoke.");
#endif

#if NET9_0_OR_GREATER
            object? instance = IsValueType
                ? RuntimeHelpers.Box(ref Unsafe.AsRef<byte>(_targetPointer), typeof(TTarget).TypeHandle)
                : _referenceTarget;
#else
            object? instance = _referenceTarget;
#endif

            if (instance is null)
                throw new InvalidOperationException("Target instance is null.");

            return _method.Invoke(instance, args);
        }
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public TResult Invoke(<#= string.Join(", ", Enumerable.Range(1, paramCount).Select(i => $"T{i} arg{i}")) #>)
    {
        ThrowIfDisposed();

        if (!_isStatic && !IsValueType)
            return ((delegate* managed<TTarget<#= paramCount > 0 ? ", " + string.Join(", ", Enumerable.Range(1, paramCount).Select(i => $"T{i}")) : "" #>, TResult>)_methodPtr)(Unsafe.As<object?, TTarget>(ref _referenceTarget)<#= paramCount > 0 ? ", " + string.Join(", ", Enumerable.Range(1, paramCount).Select(i => $"arg{i}")) : "" #>);
        else if (IsValueType)
            return ((delegate* managed<ref TTarget<#= paramCount > 0 ? ", " + string.Join(", ", Enumerable.Range(1, paramCount).Select(i => $"T{i}")) : "" #>, TResult>)_methodPtr)(ref Unsafe.AsRef<TTarget>(_targetPointer)<#= paramCount > 0 ? ", " + string.Join(", ", Enumerable.Range(1, paramCount).Select(i => $"arg{i}")) : "" #>);
        else
            return ((delegate* managed<#= paramCount > 0 ? "<" + string.Join(", ", Enumerable.Range(1, paramCount).Select(i => $"T{i}")) + ", " : "<" #>TResult>)_methodPtr)(<#= string.Join(", ", Enumerable.Range(1, paramCount).Select(i => $"arg{i}")) #>);
    }

    #endregion
    
    #region Auxiliary methods
    
    public TDelegate ToDelegate<TDelegate>()
        where TDelegate : Delegate
    {
        ThrowIfDisposed();
        if (_isStatic)
        {
            return (TDelegate)Delegate.CreateDelegate(typeof(TDelegate), _method);
        }
        else
        {
            if (typeof(TTarget).IsByRefLike)
                throw new ArgumentException("The target type is a by-ref-like type and cannot be converted to a delegate.");
            
#if !NET9_0_OR_GREATER
            if (IsValueType)
                throw new ArgumentException("The target type is value type and cannot be converted to a delegate.");
#endif

#if NET9_0_OR_GREATER
            object? instance = IsValueType 
                ? RuntimeHelpers.Box(ref Unsafe.AsRef<byte>(_targetPointer), typeof(TTarget).TypeHandle)
                : _referenceTarget;
#else
            object? instance = _referenceTarget;
#endif
            
            if (instance is null)
                throw new InvalidOperationException("Target instance is null.");
            
            return (TDelegate)Delegate.CreateDelegate(typeof(TDelegate), instance, _method);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void ThrowIfDisposed()
    {
        if (_disposed)
            throw new ObjectDisposedException(nameof(LuminFunction<TTarget, <#= genericParams #>>));
    }
    
    #endregion
    
    #region Static Type Hash

    private static readonly int TypeHash = ComputeTypeHash();
    private static readonly int TargetTypeHash = TargetTypeHandle.GetHashCode();
    private static readonly RuntimeTypeHandle TargetTypeHandle = typeof(TTarget).TypeHandle;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static int ComputeTypeHash()
    {
        unchecked
        {
            int h = (int)2166136261;
            h = (h * 16777619) ^ typeof(TResult).TypeHandle.GetHashCode();
<#
            for (int i = 1; i <= paramCount; i++)
            {
#>
            h = (h * 16777619) ^ typeof(T<#= i #>).TypeHandle.GetHashCode();
<#
            }
#>
            return h;
        }
    }

    #endregion

    #region Method Caching

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static MethodCache GetCachedMethod(scoped in RuntimeTypeHandle type, string methodName, int nameHash = 0)
    {
        nameHash = nameHash is 0 ? StringComparer.Ordinal.GetHashCode(methodName) : nameHash;
        int key = type.Equals(TargetTypeHandle)
                      ? TypeHash ^ nameHash ^ TargetTypeHash
                      : TypeHash ^ nameHash ^ type.GetHashCode();
       
        if (!Methods.TryGetValue(key, out var result))
        {
            const BindingFlags flags = BindingFlags.Public | BindingFlags.NonPublic |
                                       BindingFlags.Instance | BindingFlags.Static;
    
            Type[] paramTypes = <#= paramCount == 0 ? "Type.EmptyTypes" : $"[ {string.Join(", ", Enumerable.Range(1, paramCount).Select(i => $"typeof(T{i})"))} ]" #>;

            var method = MethodFinder.GetConcreteMethod(typeof(TTarget), methodName, paramTypes);
            
            if (IsIl2Cpp)
                result = new MethodCache(method.IsStatic, method.MethodHandle.Value, method);
            else
                result = new MethodCache(method.IsStatic, method.MethodHandle.GetFunctionPointer(), method);

            Methods.TryAdd(key, result);
        }

        return result;
    }
    
    #endregion
}
<# } #>