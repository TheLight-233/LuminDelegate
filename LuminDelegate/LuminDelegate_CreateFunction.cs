
// <auto-generated/>
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;

#nullable enable
namespace LuminDelegates
{
    public static partial class LuminDelegate
    {
        #region LuminFunction<TTarget, TResult>

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托
        /// </summary>
        /// <param name="target">委托绑定的实例（值类型或引用类型）</param>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, TResult> CreateFunction<TTarget, TResult>(TTarget? target, string methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
#endif
            => LuminFunction<TTarget, TResult>.Create(ref target, methodName, methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（显式指定目标类型）
        /// 用于解决虚方法GetType开销
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="targetType">查找实例的类型</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#if NET8_0_OR_GREATER
        public static LuminFunction<TTarget, TResult> CreateFunction<TTarget, TResult>(TTarget? target, string methodName, [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type targetType, int methodNameHash = 0)
#else
        public static LuminFunction<TTarget, TResult> CreateFunction<TTarget, TResult>(TTarget? target, string methodName, Type targetType, int methodNameHash = 0)
#endif
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
#endif
            => LuminFunction<TTarget, TResult>.Create(ref target, methodName, targetType, methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（避免字符串分配）
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名（只读字符范围）</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, TResult> CreateFunction<TTarget, TResult>(TTarget? target, ReadOnlySpan<char> methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
#endif
            => CreateFunction<TTarget, TResult>(target, methodName.ToString(), methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（显式指定目标类型 + 避免字符串分配）
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名（只读字符范围）</param>
        /// <param name="targetType">绑定实例的类型</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#if NET8_0_OR_GREATER
        public static LuminFunction<TTarget, TResult> CreateFunction<TTarget, TResult>(TTarget? target, ReadOnlySpan<char> methodName, [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type targetType, int methodNameHash = 0)
#else
        public static LuminFunction<TTarget, TResult> CreateFunction<TTarget, TResult>(TTarget? target, ReadOnlySpan<char> methodName, Type targetType, int methodNameHash = 0)
#endif
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
#endif
            => CreateFunction<TTarget, TResult>(target, methodName.ToString(), targetType, methodNameHash);

        /// <summary>
        /// 从现有委托创建 Lumin 委托
        /// </summary>
        /// <param name="delegate">现有的 .NET 委托</param>
        /// <returns>等价的 Lumin 委托</returns>
        [Obsolete("直接由委托隐式创建实例可能引发额外的 GC 压力与性能损耗，请显式传入对象实例和方法名以避免装箱与捕获成本。")]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, TResult> CreateFunction<TTarget, TResult>(Delegate @delegate)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
#endif
            => LuminFunction<TTarget, TResult>.Create(@delegate);

        /// <summary>
        /// 从现有委托创建 Lumin 委托
        /// </summary>
        /// <param name="delegate">现有的 .NET 委托</param>
        /// <returns>等价的 Lumin 委托</returns>
        [Obsolete("直接由委托隐式创建实例可能引发额外的 GC 压力与性能损耗，请显式传入对象实例和方法名以避免装箱与捕获成本。")]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, TResult> CreateFunction<TTarget, TResult>(Func<TResult> @delegate)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
#endif
            => LuminFunction<TTarget, TResult>.Create(@delegate);

        /// <summary>
        /// 创建绑定静态方法的Lumin委托
        /// </summary>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, TResult> CreateFunction<TTarget, TResult>(string methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
#endif
            => LuminFunction<TTarget, TResult>.Create(methodName, methodNameHash);

        /// <summary>
        /// 创建绑定静态方法的Lumin委托
        /// </summary>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, TResult> CreateFunction<TTarget, TResult>(ReadOnlySpan<char> methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
#endif
            => LuminFunction<TTarget, TResult>.Create(methodName.ToString(), methodNameHash);

        #endregion

        #region LuminFunction<TTarget, T1, TResult>

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托
        /// </summary>
        /// <param name="target">委托绑定的实例（值类型或引用类型）</param>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, TResult> CreateFunction<TTarget, T1, TResult>(TTarget? target, string methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, TResult>.Create(ref target, methodName, methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（显式指定目标类型）
        /// 用于解决虚方法GetType开销
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="targetType">查找实例的类型</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#if NET8_0_OR_GREATER
        public static LuminFunction<TTarget, T1, TResult> CreateFunction<TTarget, T1, TResult>(TTarget? target, string methodName, [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type targetType, int methodNameHash = 0)
#else
        public static LuminFunction<TTarget, T1, TResult> CreateFunction<TTarget, T1, TResult>(TTarget? target, string methodName, Type targetType, int methodNameHash = 0)
#endif
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, TResult>.Create(ref target, methodName, targetType, methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（避免字符串分配）
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名（只读字符范围）</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, TResult> CreateFunction<TTarget, T1, TResult>(TTarget? target, ReadOnlySpan<char> methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct
#endif
            => CreateFunction<TTarget, T1, TResult>(target, methodName.ToString(), methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（显式指定目标类型 + 避免字符串分配）
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名（只读字符范围）</param>
        /// <param name="targetType">绑定实例的类型</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#if NET8_0_OR_GREATER
        public static LuminFunction<TTarget, T1, TResult> CreateFunction<TTarget, T1, TResult>(TTarget? target, ReadOnlySpan<char> methodName, [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type targetType, int methodNameHash = 0)
#else
        public static LuminFunction<TTarget, T1, TResult> CreateFunction<TTarget, T1, TResult>(TTarget? target, ReadOnlySpan<char> methodName, Type targetType, int methodNameHash = 0)
#endif
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct
#endif
            => CreateFunction<TTarget, T1, TResult>(target, methodName.ToString(), targetType, methodNameHash);

        /// <summary>
        /// 从现有委托创建 Lumin 委托
        /// </summary>
        /// <param name="delegate">现有的 .NET 委托</param>
        /// <returns>等价的 Lumin 委托</returns>
        [Obsolete("直接由委托隐式创建实例可能引发额外的 GC 压力与性能损耗，请显式传入对象实例和方法名以避免装箱与捕获成本。")]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, TResult> CreateFunction<TTarget, T1, TResult>(Delegate @delegate)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, TResult>.Create(@delegate);

        /// <summary>
        /// 从现有委托创建 Lumin 委托
        /// </summary>
        /// <param name="delegate">现有的 .NET 委托</param>
        /// <returns>等价的 Lumin 委托</returns>
        [Obsolete("直接由委托隐式创建实例可能引发额外的 GC 压力与性能损耗，请显式传入对象实例和方法名以避免装箱与捕获成本。")]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, TResult> CreateFunction<TTarget, T1, TResult>(Func<T1, TResult> @delegate)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, TResult>.Create(@delegate);

        /// <summary>
        /// 创建绑定静态方法的Lumin委托
        /// </summary>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, TResult> CreateFunction<TTarget, T1, TResult>(string methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, TResult>.Create(methodName, methodNameHash);

        /// <summary>
        /// 创建绑定静态方法的Lumin委托
        /// </summary>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, TResult> CreateFunction<TTarget, T1, TResult>(ReadOnlySpan<char> methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, TResult>.Create(methodName.ToString(), methodNameHash);

        #endregion

        #region LuminFunction<TTarget, T1, T2, TResult>

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托
        /// </summary>
        /// <param name="target">委托绑定的实例（值类型或引用类型）</param>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, TResult> CreateFunction<TTarget, T1, T2, TResult>(TTarget? target, string methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, TResult>.Create(ref target, methodName, methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（显式指定目标类型）
        /// 用于解决虚方法GetType开销
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="targetType">查找实例的类型</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#if NET8_0_OR_GREATER
        public static LuminFunction<TTarget, T1, T2, TResult> CreateFunction<TTarget, T1, T2, TResult>(TTarget? target, string methodName, [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type targetType, int methodNameHash = 0)
#else
        public static LuminFunction<TTarget, T1, T2, TResult> CreateFunction<TTarget, T1, T2, TResult>(TTarget? target, string methodName, Type targetType, int methodNameHash = 0)
#endif
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, TResult>.Create(ref target, methodName, targetType, methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（避免字符串分配）
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名（只读字符范围）</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, TResult> CreateFunction<TTarget, T1, T2, TResult>(TTarget? target, ReadOnlySpan<char> methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct
#endif
            => CreateFunction<TTarget, T1, T2, TResult>(target, methodName.ToString(), methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（显式指定目标类型 + 避免字符串分配）
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名（只读字符范围）</param>
        /// <param name="targetType">绑定实例的类型</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#if NET8_0_OR_GREATER
        public static LuminFunction<TTarget, T1, T2, TResult> CreateFunction<TTarget, T1, T2, TResult>(TTarget? target, ReadOnlySpan<char> methodName, [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type targetType, int methodNameHash = 0)
#else
        public static LuminFunction<TTarget, T1, T2, TResult> CreateFunction<TTarget, T1, T2, TResult>(TTarget? target, ReadOnlySpan<char> methodName, Type targetType, int methodNameHash = 0)
#endif
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct
#endif
            => CreateFunction<TTarget, T1, T2, TResult>(target, methodName.ToString(), targetType, methodNameHash);

        /// <summary>
        /// 从现有委托创建 Lumin 委托
        /// </summary>
        /// <param name="delegate">现有的 .NET 委托</param>
        /// <returns>等价的 Lumin 委托</returns>
        [Obsolete("直接由委托隐式创建实例可能引发额外的 GC 压力与性能损耗，请显式传入对象实例和方法名以避免装箱与捕获成本。")]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, TResult> CreateFunction<TTarget, T1, T2, TResult>(Delegate @delegate)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, TResult>.Create(@delegate);

        /// <summary>
        /// 从现有委托创建 Lumin 委托
        /// </summary>
        /// <param name="delegate">现有的 .NET 委托</param>
        /// <returns>等价的 Lumin 委托</returns>
        [Obsolete("直接由委托隐式创建实例可能引发额外的 GC 压力与性能损耗，请显式传入对象实例和方法名以避免装箱与捕获成本。")]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, TResult> CreateFunction<TTarget, T1, T2, TResult>(Func<T1, T2, TResult> @delegate)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, TResult>.Create(@delegate);

        /// <summary>
        /// 创建绑定静态方法的Lumin委托
        /// </summary>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, TResult> CreateFunction<TTarget, T1, T2, TResult>(string methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, TResult>.Create(methodName, methodNameHash);

        /// <summary>
        /// 创建绑定静态方法的Lumin委托
        /// </summary>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, TResult> CreateFunction<TTarget, T1, T2, TResult>(ReadOnlySpan<char> methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, TResult>.Create(methodName.ToString(), methodNameHash);

        #endregion

        #region LuminFunction<TTarget, T1, T2, T3, TResult>

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托
        /// </summary>
        /// <param name="target">委托绑定的实例（值类型或引用类型）</param>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, TResult> CreateFunction<TTarget, T1, T2, T3, TResult>(TTarget? target, string methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, TResult>.Create(ref target, methodName, methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（显式指定目标类型）
        /// 用于解决虚方法GetType开销
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="targetType">查找实例的类型</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#if NET8_0_OR_GREATER
        public static LuminFunction<TTarget, T1, T2, T3, TResult> CreateFunction<TTarget, T1, T2, T3, TResult>(TTarget? target, string methodName, [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type targetType, int methodNameHash = 0)
#else
        public static LuminFunction<TTarget, T1, T2, T3, TResult> CreateFunction<TTarget, T1, T2, T3, TResult>(TTarget? target, string methodName, Type targetType, int methodNameHash = 0)
#endif
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, TResult>.Create(ref target, methodName, targetType, methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（避免字符串分配）
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名（只读字符范围）</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, TResult> CreateFunction<TTarget, T1, T2, T3, TResult>(TTarget? target, ReadOnlySpan<char> methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct
#endif
            => CreateFunction<TTarget, T1, T2, T3, TResult>(target, methodName.ToString(), methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（显式指定目标类型 + 避免字符串分配）
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名（只读字符范围）</param>
        /// <param name="targetType">绑定实例的类型</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#if NET8_0_OR_GREATER
        public static LuminFunction<TTarget, T1, T2, T3, TResult> CreateFunction<TTarget, T1, T2, T3, TResult>(TTarget? target, ReadOnlySpan<char> methodName, [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type targetType, int methodNameHash = 0)
#else
        public static LuminFunction<TTarget, T1, T2, T3, TResult> CreateFunction<TTarget, T1, T2, T3, TResult>(TTarget? target, ReadOnlySpan<char> methodName, Type targetType, int methodNameHash = 0)
#endif
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct
#endif
            => CreateFunction<TTarget, T1, T2, T3, TResult>(target, methodName.ToString(), targetType, methodNameHash);

        /// <summary>
        /// 从现有委托创建 Lumin 委托
        /// </summary>
        /// <param name="delegate">现有的 .NET 委托</param>
        /// <returns>等价的 Lumin 委托</returns>
        [Obsolete("直接由委托隐式创建实例可能引发额外的 GC 压力与性能损耗，请显式传入对象实例和方法名以避免装箱与捕获成本。")]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, TResult> CreateFunction<TTarget, T1, T2, T3, TResult>(Delegate @delegate)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, TResult>.Create(@delegate);

        /// <summary>
        /// 从现有委托创建 Lumin 委托
        /// </summary>
        /// <param name="delegate">现有的 .NET 委托</param>
        /// <returns>等价的 Lumin 委托</returns>
        [Obsolete("直接由委托隐式创建实例可能引发额外的 GC 压力与性能损耗，请显式传入对象实例和方法名以避免装箱与捕获成本。")]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, TResult> CreateFunction<TTarget, T1, T2, T3, TResult>(Func<T1, T2, T3, TResult> @delegate)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, TResult>.Create(@delegate);

        /// <summary>
        /// 创建绑定静态方法的Lumin委托
        /// </summary>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, TResult> CreateFunction<TTarget, T1, T2, T3, TResult>(string methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, TResult>.Create(methodName, methodNameHash);

        /// <summary>
        /// 创建绑定静态方法的Lumin委托
        /// </summary>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, TResult> CreateFunction<TTarget, T1, T2, T3, TResult>(ReadOnlySpan<char> methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, TResult>.Create(methodName.ToString(), methodNameHash);

        #endregion

        #region LuminFunction<TTarget, T1, T2, T3, T4, TResult>

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托
        /// </summary>
        /// <param name="target">委托绑定的实例（值类型或引用类型）</param>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, T4, TResult> CreateFunction<TTarget, T1, T2, T3, T4, TResult>(TTarget? target, string methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, T4, TResult>.Create(ref target, methodName, methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（显式指定目标类型）
        /// 用于解决虚方法GetType开销
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="targetType">查找实例的类型</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#if NET8_0_OR_GREATER
        public static LuminFunction<TTarget, T1, T2, T3, T4, TResult> CreateFunction<TTarget, T1, T2, T3, T4, TResult>(TTarget? target, string methodName, [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type targetType, int methodNameHash = 0)
#else
        public static LuminFunction<TTarget, T1, T2, T3, T4, TResult> CreateFunction<TTarget, T1, T2, T3, T4, TResult>(TTarget? target, string methodName, Type targetType, int methodNameHash = 0)
#endif
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, T4, TResult>.Create(ref target, methodName, targetType, methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（避免字符串分配）
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名（只读字符范围）</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, T4, TResult> CreateFunction<TTarget, T1, T2, T3, T4, TResult>(TTarget? target, ReadOnlySpan<char> methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct
#endif
            => CreateFunction<TTarget, T1, T2, T3, T4, TResult>(target, methodName.ToString(), methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（显式指定目标类型 + 避免字符串分配）
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名（只读字符范围）</param>
        /// <param name="targetType">绑定实例的类型</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#if NET8_0_OR_GREATER
        public static LuminFunction<TTarget, T1, T2, T3, T4, TResult> CreateFunction<TTarget, T1, T2, T3, T4, TResult>(TTarget? target, ReadOnlySpan<char> methodName, [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type targetType, int methodNameHash = 0)
#else
        public static LuminFunction<TTarget, T1, T2, T3, T4, TResult> CreateFunction<TTarget, T1, T2, T3, T4, TResult>(TTarget? target, ReadOnlySpan<char> methodName, Type targetType, int methodNameHash = 0)
#endif
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct
#endif
            => CreateFunction<TTarget, T1, T2, T3, T4, TResult>(target, methodName.ToString(), targetType, methodNameHash);

        /// <summary>
        /// 从现有委托创建 Lumin 委托
        /// </summary>
        /// <param name="delegate">现有的 .NET 委托</param>
        /// <returns>等价的 Lumin 委托</returns>
        [Obsolete("直接由委托隐式创建实例可能引发额外的 GC 压力与性能损耗，请显式传入对象实例和方法名以避免装箱与捕获成本。")]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, T4, TResult> CreateFunction<TTarget, T1, T2, T3, T4, TResult>(Delegate @delegate)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, T4, TResult>.Create(@delegate);

        /// <summary>
        /// 从现有委托创建 Lumin 委托
        /// </summary>
        /// <param name="delegate">现有的 .NET 委托</param>
        /// <returns>等价的 Lumin 委托</returns>
        [Obsolete("直接由委托隐式创建实例可能引发额外的 GC 压力与性能损耗，请显式传入对象实例和方法名以避免装箱与捕获成本。")]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, T4, TResult> CreateFunction<TTarget, T1, T2, T3, T4, TResult>(Func<T1, T2, T3, T4, TResult> @delegate)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, T4, TResult>.Create(@delegate);

        /// <summary>
        /// 创建绑定静态方法的Lumin委托
        /// </summary>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, T4, TResult> CreateFunction<TTarget, T1, T2, T3, T4, TResult>(string methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, T4, TResult>.Create(methodName, methodNameHash);

        /// <summary>
        /// 创建绑定静态方法的Lumin委托
        /// </summary>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, T4, TResult> CreateFunction<TTarget, T1, T2, T3, T4, TResult>(ReadOnlySpan<char> methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, T4, TResult>.Create(methodName.ToString(), methodNameHash);

        #endregion

        #region LuminFunction<TTarget, T1, T2, T3, T4, T5, TResult>

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托
        /// </summary>
        /// <param name="target">委托绑定的实例（值类型或引用类型）</param>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, TResult>(TTarget? target, string methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, T4, T5, TResult>.Create(ref target, methodName, methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（显式指定目标类型）
        /// 用于解决虚方法GetType开销
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="targetType">查找实例的类型</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#if NET8_0_OR_GREATER
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, TResult>(TTarget? target, string methodName, [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type targetType, int methodNameHash = 0)
#else
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, TResult>(TTarget? target, string methodName, Type targetType, int methodNameHash = 0)
#endif
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, T4, T5, TResult>.Create(ref target, methodName, targetType, methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（避免字符串分配）
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名（只读字符范围）</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, TResult>(TTarget? target, ReadOnlySpan<char> methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct
#endif
            => CreateFunction<TTarget, T1, T2, T3, T4, T5, TResult>(target, methodName.ToString(), methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（显式指定目标类型 + 避免字符串分配）
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名（只读字符范围）</param>
        /// <param name="targetType">绑定实例的类型</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#if NET8_0_OR_GREATER
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, TResult>(TTarget? target, ReadOnlySpan<char> methodName, [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type targetType, int methodNameHash = 0)
#else
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, TResult>(TTarget? target, ReadOnlySpan<char> methodName, Type targetType, int methodNameHash = 0)
#endif
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct
#endif
            => CreateFunction<TTarget, T1, T2, T3, T4, T5, TResult>(target, methodName.ToString(), targetType, methodNameHash);

        /// <summary>
        /// 从现有委托创建 Lumin 委托
        /// </summary>
        /// <param name="delegate">现有的 .NET 委托</param>
        /// <returns>等价的 Lumin 委托</returns>
        [Obsolete("直接由委托隐式创建实例可能引发额外的 GC 压力与性能损耗，请显式传入对象实例和方法名以避免装箱与捕获成本。")]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, TResult>(Delegate @delegate)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, T4, T5, TResult>.Create(@delegate);

        /// <summary>
        /// 从现有委托创建 Lumin 委托
        /// </summary>
        /// <param name="delegate">现有的 .NET 委托</param>
        /// <returns>等价的 Lumin 委托</returns>
        [Obsolete("直接由委托隐式创建实例可能引发额外的 GC 压力与性能损耗，请显式传入对象实例和方法名以避免装箱与捕获成本。")]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, TResult>(Func<T1, T2, T3, T4, T5, TResult> @delegate)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, T4, T5, TResult>.Create(@delegate);

        /// <summary>
        /// 创建绑定静态方法的Lumin委托
        /// </summary>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, TResult>(string methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, T4, T5, TResult>.Create(methodName, methodNameHash);

        /// <summary>
        /// 创建绑定静态方法的Lumin委托
        /// </summary>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, TResult>(ReadOnlySpan<char> methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, T4, T5, TResult>.Create(methodName.ToString(), methodNameHash);

        #endregion

        #region LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, TResult>

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托
        /// </summary>
        /// <param name="target">委托绑定的实例（值类型或引用类型）</param>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, TResult>(TTarget? target, string methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, TResult>.Create(ref target, methodName, methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（显式指定目标类型）
        /// 用于解决虚方法GetType开销
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="targetType">查找实例的类型</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#if NET8_0_OR_GREATER
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, TResult>(TTarget? target, string methodName, [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type targetType, int methodNameHash = 0)
#else
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, TResult>(TTarget? target, string methodName, Type targetType, int methodNameHash = 0)
#endif
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, TResult>.Create(ref target, methodName, targetType, methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（避免字符串分配）
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名（只读字符范围）</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, TResult>(TTarget? target, ReadOnlySpan<char> methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct
#endif
            => CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, TResult>(target, methodName.ToString(), methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（显式指定目标类型 + 避免字符串分配）
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名（只读字符范围）</param>
        /// <param name="targetType">绑定实例的类型</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#if NET8_0_OR_GREATER
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, TResult>(TTarget? target, ReadOnlySpan<char> methodName, [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type targetType, int methodNameHash = 0)
#else
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, TResult>(TTarget? target, ReadOnlySpan<char> methodName, Type targetType, int methodNameHash = 0)
#endif
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct
#endif
            => CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, TResult>(target, methodName.ToString(), targetType, methodNameHash);

        /// <summary>
        /// 从现有委托创建 Lumin 委托
        /// </summary>
        /// <param name="delegate">现有的 .NET 委托</param>
        /// <returns>等价的 Lumin 委托</returns>
        [Obsolete("直接由委托隐式创建实例可能引发额外的 GC 压力与性能损耗，请显式传入对象实例和方法名以避免装箱与捕获成本。")]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, TResult>(Delegate @delegate)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, TResult>.Create(@delegate);

        /// <summary>
        /// 从现有委托创建 Lumin 委托
        /// </summary>
        /// <param name="delegate">现有的 .NET 委托</param>
        /// <returns>等价的 Lumin 委托</returns>
        [Obsolete("直接由委托隐式创建实例可能引发额外的 GC 压力与性能损耗，请显式传入对象实例和方法名以避免装箱与捕获成本。")]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, TResult>(Func<T1, T2, T3, T4, T5, T6, TResult> @delegate)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, TResult>.Create(@delegate);

        /// <summary>
        /// 创建绑定静态方法的Lumin委托
        /// </summary>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, TResult>(string methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, TResult>.Create(methodName, methodNameHash);

        /// <summary>
        /// 创建绑定静态方法的Lumin委托
        /// </summary>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, TResult>(ReadOnlySpan<char> methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, TResult>.Create(methodName.ToString(), methodNameHash);

        #endregion

        #region LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, TResult>

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托
        /// </summary>
        /// <param name="target">委托绑定的实例（值类型或引用类型）</param>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, TResult>(TTarget? target, string methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, TResult>.Create(ref target, methodName, methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（显式指定目标类型）
        /// 用于解决虚方法GetType开销
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="targetType">查找实例的类型</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#if NET8_0_OR_GREATER
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, TResult>(TTarget? target, string methodName, [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type targetType, int methodNameHash = 0)
#else
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, TResult>(TTarget? target, string methodName, Type targetType, int methodNameHash = 0)
#endif
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, TResult>.Create(ref target, methodName, targetType, methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（避免字符串分配）
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名（只读字符范围）</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, TResult>(TTarget? target, ReadOnlySpan<char> methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct
#endif
            => CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, TResult>(target, methodName.ToString(), methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（显式指定目标类型 + 避免字符串分配）
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名（只读字符范围）</param>
        /// <param name="targetType">绑定实例的类型</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#if NET8_0_OR_GREATER
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, TResult>(TTarget? target, ReadOnlySpan<char> methodName, [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type targetType, int methodNameHash = 0)
#else
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, TResult>(TTarget? target, ReadOnlySpan<char> methodName, Type targetType, int methodNameHash = 0)
#endif
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct
#endif
            => CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, TResult>(target, methodName.ToString(), targetType, methodNameHash);

        /// <summary>
        /// 从现有委托创建 Lumin 委托
        /// </summary>
        /// <param name="delegate">现有的 .NET 委托</param>
        /// <returns>等价的 Lumin 委托</returns>
        [Obsolete("直接由委托隐式创建实例可能引发额外的 GC 压力与性能损耗，请显式传入对象实例和方法名以避免装箱与捕获成本。")]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, TResult>(Delegate @delegate)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, TResult>.Create(@delegate);

        /// <summary>
        /// 从现有委托创建 Lumin 委托
        /// </summary>
        /// <param name="delegate">现有的 .NET 委托</param>
        /// <returns>等价的 Lumin 委托</returns>
        [Obsolete("直接由委托隐式创建实例可能引发额外的 GC 压力与性能损耗，请显式传入对象实例和方法名以避免装箱与捕获成本。")]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, TResult>(Func<T1, T2, T3, T4, T5, T6, T7, TResult> @delegate)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, TResult>.Create(@delegate);

        /// <summary>
        /// 创建绑定静态方法的Lumin委托
        /// </summary>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, TResult>(string methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, TResult>.Create(methodName, methodNameHash);

        /// <summary>
        /// 创建绑定静态方法的Lumin委托
        /// </summary>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, TResult>(ReadOnlySpan<char> methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, TResult>.Create(methodName.ToString(), methodNameHash);

        #endregion

        #region LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, TResult>

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托
        /// </summary>
        /// <param name="target">委托绑定的实例（值类型或引用类型）</param>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, TResult>(TTarget? target, string methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, TResult>.Create(ref target, methodName, methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（显式指定目标类型）
        /// 用于解决虚方法GetType开销
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="targetType">查找实例的类型</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#if NET8_0_OR_GREATER
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, TResult>(TTarget? target, string methodName, [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type targetType, int methodNameHash = 0)
#else
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, TResult>(TTarget? target, string methodName, Type targetType, int methodNameHash = 0)
#endif
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, TResult>.Create(ref target, methodName, targetType, methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（避免字符串分配）
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名（只读字符范围）</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, TResult>(TTarget? target, ReadOnlySpan<char> methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct
#endif
            => CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, TResult>(target, methodName.ToString(), methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（显式指定目标类型 + 避免字符串分配）
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名（只读字符范围）</param>
        /// <param name="targetType">绑定实例的类型</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#if NET8_0_OR_GREATER
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, TResult>(TTarget? target, ReadOnlySpan<char> methodName, [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type targetType, int methodNameHash = 0)
#else
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, TResult>(TTarget? target, ReadOnlySpan<char> methodName, Type targetType, int methodNameHash = 0)
#endif
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct
#endif
            => CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, TResult>(target, methodName.ToString(), targetType, methodNameHash);

        /// <summary>
        /// 从现有委托创建 Lumin 委托
        /// </summary>
        /// <param name="delegate">现有的 .NET 委托</param>
        /// <returns>等价的 Lumin 委托</returns>
        [Obsolete("直接由委托隐式创建实例可能引发额外的 GC 压力与性能损耗，请显式传入对象实例和方法名以避免装箱与捕获成本。")]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, TResult>(Delegate @delegate)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, TResult>.Create(@delegate);

        /// <summary>
        /// 从现有委托创建 Lumin 委托
        /// </summary>
        /// <param name="delegate">现有的 .NET 委托</param>
        /// <returns>等价的 Lumin 委托</returns>
        [Obsolete("直接由委托隐式创建实例可能引发额外的 GC 压力与性能损耗，请显式传入对象实例和方法名以避免装箱与捕获成本。")]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, TResult>(Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult> @delegate)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, TResult>.Create(@delegate);

        /// <summary>
        /// 创建绑定静态方法的Lumin委托
        /// </summary>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, TResult>(string methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, TResult>.Create(methodName, methodNameHash);

        /// <summary>
        /// 创建绑定静态方法的Lumin委托
        /// </summary>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, TResult>(ReadOnlySpan<char> methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, TResult>.Create(methodName.ToString(), methodNameHash);

        #endregion

        #region LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托
        /// </summary>
        /// <param name="target">委托绑定的实例（值类型或引用类型）</param>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(TTarget? target, string methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>.Create(ref target, methodName, methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（显式指定目标类型）
        /// 用于解决虚方法GetType开销
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="targetType">查找实例的类型</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#if NET8_0_OR_GREATER
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(TTarget? target, string methodName, [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type targetType, int methodNameHash = 0)
#else
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(TTarget? target, string methodName, Type targetType, int methodNameHash = 0)
#endif
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>.Create(ref target, methodName, targetType, methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（避免字符串分配）
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名（只读字符范围）</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(TTarget? target, ReadOnlySpan<char> methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct
#endif
            => CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(target, methodName.ToString(), methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（显式指定目标类型 + 避免字符串分配）
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名（只读字符范围）</param>
        /// <param name="targetType">绑定实例的类型</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#if NET8_0_OR_GREATER
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(TTarget? target, ReadOnlySpan<char> methodName, [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type targetType, int methodNameHash = 0)
#else
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(TTarget? target, ReadOnlySpan<char> methodName, Type targetType, int methodNameHash = 0)
#endif
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct
#endif
            => CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(target, methodName.ToString(), targetType, methodNameHash);

        /// <summary>
        /// 从现有委托创建 Lumin 委托
        /// </summary>
        /// <param name="delegate">现有的 .NET 委托</param>
        /// <returns>等价的 Lumin 委托</returns>
        [Obsolete("直接由委托隐式创建实例可能引发额外的 GC 压力与性能损耗，请显式传入对象实例和方法名以避免装箱与捕获成本。")]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(Delegate @delegate)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>.Create(@delegate);

        /// <summary>
        /// 从现有委托创建 Lumin 委托
        /// </summary>
        /// <param name="delegate">现有的 .NET 委托</param>
        /// <returns>等价的 Lumin 委托</returns>
        [Obsolete("直接由委托隐式创建实例可能引发额外的 GC 压力与性能损耗，请显式传入对象实例和方法名以避免装箱与捕获成本。")]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> @delegate)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>.Create(@delegate);

        /// <summary>
        /// 创建绑定静态方法的Lumin委托
        /// </summary>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(string methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>.Create(methodName, methodNameHash);

        /// <summary>
        /// 创建绑定静态方法的Lumin委托
        /// </summary>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(ReadOnlySpan<char> methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>.Create(methodName.ToString(), methodNameHash);

        #endregion

        #region LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托
        /// </summary>
        /// <param name="target">委托绑定的实例（值类型或引用类型）</param>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(TTarget? target, string methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>.Create(ref target, methodName, methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（显式指定目标类型）
        /// 用于解决虚方法GetType开销
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="targetType">查找实例的类型</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#if NET8_0_OR_GREATER
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(TTarget? target, string methodName, [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type targetType, int methodNameHash = 0)
#else
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(TTarget? target, string methodName, Type targetType, int methodNameHash = 0)
#endif
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>.Create(ref target, methodName, targetType, methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（避免字符串分配）
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名（只读字符范围）</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(TTarget? target, ReadOnlySpan<char> methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct
#endif
            => CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(target, methodName.ToString(), methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（显式指定目标类型 + 避免字符串分配）
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名（只读字符范围）</param>
        /// <param name="targetType">绑定实例的类型</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#if NET8_0_OR_GREATER
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(TTarget? target, ReadOnlySpan<char> methodName, [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type targetType, int methodNameHash = 0)
#else
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(TTarget? target, ReadOnlySpan<char> methodName, Type targetType, int methodNameHash = 0)
#endif
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct
#endif
            => CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(target, methodName.ToString(), targetType, methodNameHash);

        /// <summary>
        /// 从现有委托创建 Lumin 委托
        /// </summary>
        /// <param name="delegate">现有的 .NET 委托</param>
        /// <returns>等价的 Lumin 委托</returns>
        [Obsolete("直接由委托隐式创建实例可能引发额外的 GC 压力与性能损耗，请显式传入对象实例和方法名以避免装箱与捕获成本。")]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(Delegate @delegate)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>.Create(@delegate);

        /// <summary>
        /// 从现有委托创建 Lumin 委托
        /// </summary>
        /// <param name="delegate">现有的 .NET 委托</param>
        /// <returns>等价的 Lumin 委托</returns>
        [Obsolete("直接由委托隐式创建实例可能引发额外的 GC 压力与性能损耗，请显式传入对象实例和方法名以避免装箱与捕获成本。")]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> @delegate)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>.Create(@delegate);

        /// <summary>
        /// 创建绑定静态方法的Lumin委托
        /// </summary>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(string methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>.Create(methodName, methodNameHash);

        /// <summary>
        /// 创建绑定静态方法的Lumin委托
        /// </summary>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(ReadOnlySpan<char> methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>.Create(methodName.ToString(), methodNameHash);

        #endregion

        #region LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托
        /// </summary>
        /// <param name="target">委托绑定的实例（值类型或引用类型）</param>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(TTarget? target, string methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>.Create(ref target, methodName, methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（显式指定目标类型）
        /// 用于解决虚方法GetType开销
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="targetType">查找实例的类型</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#if NET8_0_OR_GREATER
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(TTarget? target, string methodName, [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type targetType, int methodNameHash = 0)
#else
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(TTarget? target, string methodName, Type targetType, int methodNameHash = 0)
#endif
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>.Create(ref target, methodName, targetType, methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（避免字符串分配）
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名（只读字符范围）</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(TTarget? target, ReadOnlySpan<char> methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct
#endif
            => CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(target, methodName.ToString(), methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（显式指定目标类型 + 避免字符串分配）
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名（只读字符范围）</param>
        /// <param name="targetType">绑定实例的类型</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#if NET8_0_OR_GREATER
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(TTarget? target, ReadOnlySpan<char> methodName, [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type targetType, int methodNameHash = 0)
#else
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(TTarget? target, ReadOnlySpan<char> methodName, Type targetType, int methodNameHash = 0)
#endif
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct
#endif
            => CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(target, methodName.ToString(), targetType, methodNameHash);

        /// <summary>
        /// 从现有委托创建 Lumin 委托
        /// </summary>
        /// <param name="delegate">现有的 .NET 委托</param>
        /// <returns>等价的 Lumin 委托</returns>
        [Obsolete("直接由委托隐式创建实例可能引发额外的 GC 压力与性能损耗，请显式传入对象实例和方法名以避免装箱与捕获成本。")]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(Delegate @delegate)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>.Create(@delegate);

        /// <summary>
        /// 从现有委托创建 Lumin 委托
        /// </summary>
        /// <param name="delegate">现有的 .NET 委托</param>
        /// <returns>等价的 Lumin 委托</returns>
        [Obsolete("直接由委托隐式创建实例可能引发额外的 GC 压力与性能损耗，请显式传入对象实例和方法名以避免装箱与捕获成本。")]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> @delegate)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>.Create(@delegate);

        /// <summary>
        /// 创建绑定静态方法的Lumin委托
        /// </summary>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(string methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>.Create(methodName, methodNameHash);

        /// <summary>
        /// 创建绑定静态方法的Lumin委托
        /// </summary>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(ReadOnlySpan<char> methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>.Create(methodName.ToString(), methodNameHash);

        #endregion

        #region LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托
        /// </summary>
        /// <param name="target">委托绑定的实例（值类型或引用类型）</param>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(TTarget? target, string methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct where T12 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>.Create(ref target, methodName, methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（显式指定目标类型）
        /// 用于解决虚方法GetType开销
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="targetType">查找实例的类型</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#if NET8_0_OR_GREATER
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(TTarget? target, string methodName, [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type targetType, int methodNameHash = 0)
#else
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(TTarget? target, string methodName, Type targetType, int methodNameHash = 0)
#endif
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct where T12 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>.Create(ref target, methodName, targetType, methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（避免字符串分配）
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名（只读字符范围）</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(TTarget? target, ReadOnlySpan<char> methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct where T12 : allows ref struct
#endif
            => CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(target, methodName.ToString(), methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（显式指定目标类型 + 避免字符串分配）
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名（只读字符范围）</param>
        /// <param name="targetType">绑定实例的类型</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#if NET8_0_OR_GREATER
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(TTarget? target, ReadOnlySpan<char> methodName, [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type targetType, int methodNameHash = 0)
#else
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(TTarget? target, ReadOnlySpan<char> methodName, Type targetType, int methodNameHash = 0)
#endif
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct where T12 : allows ref struct
#endif
            => CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(target, methodName.ToString(), targetType, methodNameHash);

        /// <summary>
        /// 从现有委托创建 Lumin 委托
        /// </summary>
        /// <param name="delegate">现有的 .NET 委托</param>
        /// <returns>等价的 Lumin 委托</returns>
        [Obsolete("直接由委托隐式创建实例可能引发额外的 GC 压力与性能损耗，请显式传入对象实例和方法名以避免装箱与捕获成本。")]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(Delegate @delegate)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct where T12 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>.Create(@delegate);

        /// <summary>
        /// 从现有委托创建 Lumin 委托
        /// </summary>
        /// <param name="delegate">现有的 .NET 委托</param>
        /// <returns>等价的 Lumin 委托</returns>
        [Obsolete("直接由委托隐式创建实例可能引发额外的 GC 压力与性能损耗，请显式传入对象实例和方法名以避免装箱与捕获成本。")]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> @delegate)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct where T12 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>.Create(@delegate);

        /// <summary>
        /// 创建绑定静态方法的Lumin委托
        /// </summary>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(string methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct where T12 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>.Create(methodName, methodNameHash);

        /// <summary>
        /// 创建绑定静态方法的Lumin委托
        /// </summary>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(ReadOnlySpan<char> methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct where T12 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>.Create(methodName.ToString(), methodNameHash);

        #endregion

        #region LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托
        /// </summary>
        /// <param name="target">委托绑定的实例（值类型或引用类型）</param>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(TTarget? target, string methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct where T12 : allows ref struct where T13 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>.Create(ref target, methodName, methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（显式指定目标类型）
        /// 用于解决虚方法GetType开销
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="targetType">查找实例的类型</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#if NET8_0_OR_GREATER
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(TTarget? target, string methodName, [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type targetType, int methodNameHash = 0)
#else
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(TTarget? target, string methodName, Type targetType, int methodNameHash = 0)
#endif
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct where T12 : allows ref struct where T13 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>.Create(ref target, methodName, targetType, methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（避免字符串分配）
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名（只读字符范围）</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(TTarget? target, ReadOnlySpan<char> methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct where T12 : allows ref struct where T13 : allows ref struct
#endif
            => CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(target, methodName.ToString(), methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（显式指定目标类型 + 避免字符串分配）
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名（只读字符范围）</param>
        /// <param name="targetType">绑定实例的类型</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#if NET8_0_OR_GREATER
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(TTarget? target, ReadOnlySpan<char> methodName, [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type targetType, int methodNameHash = 0)
#else
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(TTarget? target, ReadOnlySpan<char> methodName, Type targetType, int methodNameHash = 0)
#endif
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct where T12 : allows ref struct where T13 : allows ref struct
#endif
            => CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(target, methodName.ToString(), targetType, methodNameHash);

        /// <summary>
        /// 从现有委托创建 Lumin 委托
        /// </summary>
        /// <param name="delegate">现有的 .NET 委托</param>
        /// <returns>等价的 Lumin 委托</returns>
        [Obsolete("直接由委托隐式创建实例可能引发额外的 GC 压力与性能损耗，请显式传入对象实例和方法名以避免装箱与捕获成本。")]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(Delegate @delegate)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct where T12 : allows ref struct where T13 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>.Create(@delegate);

        /// <summary>
        /// 从现有委托创建 Lumin 委托
        /// </summary>
        /// <param name="delegate">现有的 .NET 委托</param>
        /// <returns>等价的 Lumin 委托</returns>
        [Obsolete("直接由委托隐式创建实例可能引发额外的 GC 压力与性能损耗，请显式传入对象实例和方法名以避免装箱与捕获成本。")]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> @delegate)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct where T12 : allows ref struct where T13 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>.Create(@delegate);

        /// <summary>
        /// 创建绑定静态方法的Lumin委托
        /// </summary>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(string methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct where T12 : allows ref struct where T13 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>.Create(methodName, methodNameHash);

        /// <summary>
        /// 创建绑定静态方法的Lumin委托
        /// </summary>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(ReadOnlySpan<char> methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct where T12 : allows ref struct where T13 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>.Create(methodName.ToString(), methodNameHash);

        #endregion

        #region LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托
        /// </summary>
        /// <param name="target">委托绑定的实例（值类型或引用类型）</param>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(TTarget? target, string methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct where T12 : allows ref struct where T13 : allows ref struct where T14 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>.Create(ref target, methodName, methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（显式指定目标类型）
        /// 用于解决虚方法GetType开销
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="targetType">查找实例的类型</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#if NET8_0_OR_GREATER
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(TTarget? target, string methodName, [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type targetType, int methodNameHash = 0)
#else
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(TTarget? target, string methodName, Type targetType, int methodNameHash = 0)
#endif
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct where T12 : allows ref struct where T13 : allows ref struct where T14 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>.Create(ref target, methodName, targetType, methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（避免字符串分配）
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名（只读字符范围）</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(TTarget? target, ReadOnlySpan<char> methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct where T12 : allows ref struct where T13 : allows ref struct where T14 : allows ref struct
#endif
            => CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(target, methodName.ToString(), methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（显式指定目标类型 + 避免字符串分配）
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名（只读字符范围）</param>
        /// <param name="targetType">绑定实例的类型</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#if NET8_0_OR_GREATER
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(TTarget? target, ReadOnlySpan<char> methodName, [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type targetType, int methodNameHash = 0)
#else
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(TTarget? target, ReadOnlySpan<char> methodName, Type targetType, int methodNameHash = 0)
#endif
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct where T12 : allows ref struct where T13 : allows ref struct where T14 : allows ref struct
#endif
            => CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(target, methodName.ToString(), targetType, methodNameHash);

        /// <summary>
        /// 从现有委托创建 Lumin 委托
        /// </summary>
        /// <param name="delegate">现有的 .NET 委托</param>
        /// <returns>等价的 Lumin 委托</returns>
        [Obsolete("直接由委托隐式创建实例可能引发额外的 GC 压力与性能损耗，请显式传入对象实例和方法名以避免装箱与捕获成本。")]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(Delegate @delegate)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct where T12 : allows ref struct where T13 : allows ref struct where T14 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>.Create(@delegate);

        /// <summary>
        /// 从现有委托创建 Lumin 委托
        /// </summary>
        /// <param name="delegate">现有的 .NET 委托</param>
        /// <returns>等价的 Lumin 委托</returns>
        [Obsolete("直接由委托隐式创建实例可能引发额外的 GC 压力与性能损耗，请显式传入对象实例和方法名以避免装箱与捕获成本。")]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> @delegate)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct where T12 : allows ref struct where T13 : allows ref struct where T14 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>.Create(@delegate);

        /// <summary>
        /// 创建绑定静态方法的Lumin委托
        /// </summary>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(string methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct where T12 : allows ref struct where T13 : allows ref struct where T14 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>.Create(methodName, methodNameHash);

        /// <summary>
        /// 创建绑定静态方法的Lumin委托
        /// </summary>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(ReadOnlySpan<char> methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct where T12 : allows ref struct where T13 : allows ref struct where T14 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>.Create(methodName.ToString(), methodNameHash);

        #endregion

        #region LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托
        /// </summary>
        /// <param name="target">委托绑定的实例（值类型或引用类型）</param>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(TTarget? target, string methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct where T12 : allows ref struct where T13 : allows ref struct where T14 : allows ref struct where T15 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>.Create(ref target, methodName, methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（显式指定目标类型）
        /// 用于解决虚方法GetType开销
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="targetType">查找实例的类型</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#if NET8_0_OR_GREATER
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(TTarget? target, string methodName, [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type targetType, int methodNameHash = 0)
#else
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(TTarget? target, string methodName, Type targetType, int methodNameHash = 0)
#endif
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct where T12 : allows ref struct where T13 : allows ref struct where T14 : allows ref struct where T15 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>.Create(ref target, methodName, targetType, methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（避免字符串分配）
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名（只读字符范围）</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(TTarget? target, ReadOnlySpan<char> methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct where T12 : allows ref struct where T13 : allows ref struct where T14 : allows ref struct where T15 : allows ref struct
#endif
            => CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(target, methodName.ToString(), methodNameHash);

        /// <summary>
        /// 创建绑定实例方法的 Lumin 委托（显式指定目标类型 + 避免字符串分配）
        /// </summary>
        /// <param name="target">委托绑定的实例</param>
        /// <param name="methodName">委托绑定的方法名（只读字符范围）</param>
        /// <param name="targetType">绑定实例的类型</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns>构造的 Lumin 委托</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#if NET8_0_OR_GREATER
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(TTarget? target, ReadOnlySpan<char> methodName, [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type targetType, int methodNameHash = 0)
#else
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(TTarget? target, ReadOnlySpan<char> methodName, Type targetType, int methodNameHash = 0)
#endif
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct where T12 : allows ref struct where T13 : allows ref struct where T14 : allows ref struct where T15 : allows ref struct
#endif
            => CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(target, methodName.ToString(), targetType, methodNameHash);

        /// <summary>
        /// 从现有委托创建 Lumin 委托
        /// </summary>
        /// <param name="delegate">现有的 .NET 委托</param>
        /// <returns>等价的 Lumin 委托</returns>
        [Obsolete("直接由委托隐式创建实例可能引发额外的 GC 压力与性能损耗，请显式传入对象实例和方法名以避免装箱与捕获成本。")]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(Delegate @delegate)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct where T12 : allows ref struct where T13 : allows ref struct where T14 : allows ref struct where T15 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>.Create(@delegate);

        /// <summary>
        /// 从现有委托创建 Lumin 委托
        /// </summary>
        /// <param name="delegate">现有的 .NET 委托</param>
        /// <returns>等价的 Lumin 委托</returns>
        [Obsolete("直接由委托隐式创建实例可能引发额外的 GC 压力与性能损耗，请显式传入对象实例和方法名以避免装箱与捕获成本。")]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> @delegate)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct where T12 : allows ref struct where T13 : allows ref struct where T14 : allows ref struct where T15 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>.Create(@delegate);

        /// <summary>
        /// 创建绑定静态方法的Lumin委托
        /// </summary>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(string methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct where T12 : allows ref struct where T13 : allows ref struct where T14 : allows ref struct where T15 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>.Create(methodName, methodNameHash);

        /// <summary>
        /// 创建绑定静态方法的Lumin委托
        /// </summary>
        /// <param name="methodName">委托绑定的方法名</param>
        /// <param name="methodNameHash">方法名哈希值（可选）</param>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> CreateFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(ReadOnlySpan<char> methodName, int methodNameHash = 0)
#if NET9_0_OR_GREATER
            where TTarget : allows ref struct
            where TResult : allows ref struct
            where T1 : allows ref struct where T2 : allows ref struct where T3 : allows ref struct where T4 : allows ref struct where T5 : allows ref struct where T6 : allows ref struct where T7 : allows ref struct where T8 : allows ref struct where T9 : allows ref struct where T10 : allows ref struct where T11 : allows ref struct where T12 : allows ref struct where T13 : allows ref struct where T14 : allows ref struct where T15 : allows ref struct
#endif
            => LuminFunction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>.Create(methodName.ToString(), methodNameHash);

        #endregion

    }
}