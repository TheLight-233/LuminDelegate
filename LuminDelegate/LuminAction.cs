// <auto-generated>
//     This code was generated by a T4 template.
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>

using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;

using static LuminDelegates.LuminDelegate;

#nullable enable
namespace LuminDelegates;


public unsafe struct LuminAction<
#if NET8_0_OR_GREATER
[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)]
#endif
TTarget> : IDisposable, ICloneable, ISerializable, IEquatable<LuminAction<TTarget>>
#if NET9_0_OR_GREATER
    where TTarget : allows ref struct
#endif
{
    private void* _targetPointer; // 值类型对象
    private object? _referenceTarget; // 引用类型对象
    private readonly IntPtr _methodPtr;
    private readonly bool _isStatic;
    private readonly MethodInfo _method; // 存储关联的方法信息
    private bool _disposed;

    private static readonly bool IsValueType = typeof(TTarget).IsValueType;
    
    public TTarget? Target
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            ThrowIfDisposed();
            
            if (_isStatic)
                return default;
            
            if (IsValueType)
                return Unsafe.AsRef<TTarget?>(_targetPointer);
            
            var target = _referenceTarget;
            return Unsafe.As<object?, TTarget?>(ref target);
        }
    }
    
    public MethodInfo Method => _method;

    #region Constructors
    
    private LuminAction(MethodCache method)
    {
        _method = method.MethodBase ?? throw new ArgumentNullException(nameof(method));
        _isStatic = method.IsStatic;
        _methodPtr = method.MethodPtr;


        if (!_isStatic)
            throw new ArgumentException("methods are not static!", method.MethodBase.Name);

        _referenceTarget = null;
        _targetPointer = null;
    }
    
    private LuminAction(scoped ref TTarget? target, MethodCache method)
    {
        _method = method.MethodBase ?? throw new ArgumentNullException(nameof(method));
        _isStatic = method.IsStatic;
        _methodPtr = method.MethodPtr;
        _targetPointer = null;        
        if (!_isStatic)
        {
            if (IsValueType)
            {
#if NET8_0_OR_GREATER
                if (Unsafe.IsNullRef(ref target))
                    throw new ArgumentException("Target value instance cannot be null.", nameof(target));
#endif

#if NET8_0_OR_GREATER
                _targetPointer = NativeMemory.Alloc((nuint)Unsafe.SizeOf<TTarget>());
#else
                _targetPointer = Marshal.AllocHGlobal(Unsafe.SizeOf<TTarget>()).ToPointer();
#endif
                Unsafe.CopyBlock(
                    _targetPointer,
                    Unsafe.AsPointer(ref target),
                    (uint)Unsafe.SizeOf<TTarget>()
                );
            }
            else
            {
                // 引用类型：固定对象并获取指针
                if (target is null)
                    throw new ArgumentException("Target instance object is null.", nameof(target));
                
                _referenceTarget = Unsafe.As<TTarget, object?>(ref target);
                
            }
        }
        else
        {
            _referenceTarget = null;
        }
    }
    
    private LuminAction(Delegate @delegate)
    {
        _method = @delegate.Method ?? throw new ArgumentNullException(nameof(@delegate.Method));
        _isStatic = @delegate.Method.IsStatic;
        _methodPtr = @delegate.Method.MethodHandle.GetFunctionPointer();
        _targetPointer = null;

        var target = @delegate.Target;
        if (!_isStatic)
        {
            if (target is not TTarget)
                throw new ArgumentException("Target instance object is not type.", typeof(TTarget).Name);
                
            if (IsValueType)
            {
#if NET8_0_OR_GREATER
                if (Unsafe.IsNullRef(ref target))
                    throw new ArgumentException("Target value instance cannot be null.", nameof(target));
#endif
                // 从Delegate创建，不可能是refLike
                var unboxedTarget = Unsafe.AsRef<TTarget>(Unsafe.AsPointer(ref target));
                
#if NET8_0_OR_GREATER
                _targetPointer = NativeMemory.Alloc((nuint)Unsafe.SizeOf<TTarget>());
#else
                _targetPointer = Marshal.AllocHGlobal(Unsafe.SizeOf<TTarget>()).ToPointer();
#endif
                Unsafe.CopyBlock(
                    _targetPointer,
                    Unsafe.AsPointer(ref unboxedTarget),
                    (uint)Unsafe.SizeOf<TTarget>()
                );
            }
            else
            {
                // 引用类型：固定对象并获取指针
                if (target is null)
                    throw new ArgumentException("Target instance object is null.", nameof(target));
                
                _referenceTarget = target;
            }
        }
        else
        {
            _referenceTarget = null;
        }
    }

    #endregion
    
    #region Create Factory

    /// <summary>
    /// 创建Lumin委托
    /// </summary>
    /// <param name="target">委托绑定的实例</param>
    /// <param name="methodName">委托绑定的方法名</param>
    /// <param name="methodNameHash">方法名哈希值（可选）</param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget> Create(scoped ref TTarget? target, string methodName, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        
        var method = GetCachedMethod(IsValueType
                ? TargetTypeHandle
                : Unsafe.As<TTarget, object?>(ref target!)?.GetType().TypeHandle ?? TargetTypeHandle,
            methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        return new LuminAction<TTarget>(ref target, method);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget> Create(scoped ref TTarget? target, string methodName, Type targetType, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(targetType.TypeHandle, methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        return new LuminAction<TTarget>(ref target, method);
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget> Create(scoped ref TTarget? target, ReadOnlySpan<char> methodName, int methodNameHash = 0) =>
        Create(ref target, methodName.ToString(), methodNameHash);
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget> Create(scoped ref TTarget? target, ReadOnlySpan<char> methodName, Type targetType, int methodNameHash = 0) =>
        Create(ref target, methodName.ToString(), targetType, methodNameHash);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget> Create(Delegate @delegate) => 
        new LuminAction<TTarget>(@delegate);
    
    /// <summary>
    /// 创建绑定静态方法的Lumin委托
    /// </summary>
    /// <param name="methodName">委托绑定的方法名</param>
    /// <param name="methodNameHash">方法名哈希值（可选）</param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget> Create(string methodName, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(TargetTypeHandle, methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        if (!method.IsStatic)
            throw new ArgumentException("Method is not static, please pass in instance as parameter.", nameof(methodName));
        
        return new LuminAction<TTarget>(method);
    }

    #endregion
    
    #region Interface Implementation

    public void Dispose()
    {
        if (_disposed)
            return;
        
        if (IsValueType && !_isStatic && _targetPointer != null)
        {
#if NET8_0_OR_GREATER
            NativeMemory.Free(_targetPointer);
#else
            Marshal.FreeHGlobal(new IntPtr(_targetPointer));
#endif
        }
        
        _targetPointer = null;
        _referenceTarget = null;

        _disposed = true;
    }
    
    public object Clone()
    {
        ThrowIfDisposed();
        var target = _referenceTarget;
        if (target is null)
            throw new NullReferenceException("Target instance cannot be null.");
                
        return new LuminAction<TTarget>(ref Unsafe.As<object?, TTarget>(ref target)!, new MethodCache(_isStatic, _methodPtr, _method));
    }

    public void GetObjectData(SerializationInfo info, StreamingContext context)
    {
        throw new NotSupportedException();
    }
    
    public override bool Equals(object? obj)
    {
        return obj is LuminAction<TTarget> other && Equals(other);
    }

    public bool Equals(LuminAction<TTarget> other)
    {
        ThrowIfDisposed();
        return _methodPtr == other._methodPtr &&
               _isStatic == other._isStatic &&
               _targetPointer == other._targetPointer;
    }

    public override int GetHashCode()
    {
        ThrowIfDisposed();
        unchecked
        {
            int hash = 17;
            hash = hash * 31 + _methodPtr.GetHashCode();
            hash = hash * 31 + _isStatic.GetHashCode();
            hash = hash * 31 + ((IntPtr)_targetPointer).GetHashCode();
            return hash;
        }
    }

    #endregion
    
    #region Implicit
    
    public static implicit operator LuminAction<TTarget>(in Delegate action) 
        => Create(action);

    // Action 类型的隐式转换
    public static implicit operator LuminAction<TTarget>(Action action) => 
        Create(action);
    
    #endregion

    #region Invoke

    /// <summary>
    /// 使用反射动态调用方法
    /// 慎用，开销较大
    /// </summary>
    /// <param name="args">方法参数数组</param>
    /// <returns>方法返回值</returns>
    public object? DynamicInvoke(params object?[] args)
    {
        ThrowIfDisposed();
        
        if (_isStatic)
        {
            return _method.Invoke(null, args);
        }
        else
        {
            if (typeof(TTarget).IsByRefLike)
                throw new ArgumentException(
                    "The target type is a by-ref-like type and cannot be converted to a delegate.");

#if !NET9_0_OR_GREATER
            if (IsValueType)
                throw new ArgumentException("The target type is value type and cannot dynamic invoke.");
#endif

#if NET9_0_OR_GREATER
            object? instance = IsValueType
                ? RuntimeHelpers.Box(ref Unsafe.AsRef<byte>(_targetPointer), typeof(TTarget).TypeHandle)
                : _referenceTarget;
#else
            object? instance = _referenceTarget;
#endif

            if (instance is null)
                throw new InvalidOperationException("Target instance is null.");

            return _method.Invoke(instance, args);
        }
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Invoke()
    {
        ThrowIfDisposed();
 
        if (!_isStatic && !IsValueType)
            ((delegate* managed<TTarget, void>)_methodPtr)(Unsafe.As<object?, TTarget>(ref _referenceTarget));
        else if (IsValueType)
            ((delegate* managed<ref TTarget, void>)_methodPtr)(ref Unsafe.AsRef<TTarget>(_targetPointer));
        else
            ((delegate* managed<void>)_methodPtr)();
    }

    #endregion
    
    #region Auxiliary methods
    
    public TDelegate ToDelegate<TDelegate>()
        where TDelegate : Delegate
    {
        ThrowIfDisposed();
        if (_isStatic)
        {
            return (TDelegate)Delegate.CreateDelegate(typeof(TDelegate), _method);
        }
        else
        {
            if (typeof(TTarget).IsByRefLike)
                throw new ArgumentException("The target type is a by-ref-like type and cannot be converted to a delegate.");
            
#if !NET9_0_OR_GREATER
            if (IsValueType)
                throw new ArgumentException("The target type is value type and cannot be converted to a delegate.");
#endif

#if NET9_0_OR_GREATER
            object? instance = IsValueType 
                ? RuntimeHelpers.Box(ref Unsafe.AsRef<byte>(_targetPointer), typeof(TTarget).TypeHandle)
                : _referenceTarget;
#else
            object? instance = _referenceTarget;
#endif
            
            if (instance is null)
                throw new InvalidOperationException("Target instance is null.");
            
            return (TDelegate)Delegate.CreateDelegate(typeof(TDelegate), instance, _method);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void ThrowIfDisposed()
    {
        if (_disposed)
            throw new ObjectDisposedException(nameof(LuminAction<TTarget>));
    }
    
    #endregion
    
    #region Static Type Hash

    private static readonly int TypeHash = ComputeTypeHash();
    private static readonly int TargetTypeHash = TargetTypeHandle.GetHashCode();
    private static readonly RuntimeTypeHandle TargetTypeHandle = typeof(TTarget).TypeHandle;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static int ComputeTypeHash()
    {
        unchecked
        {
            int h = (int)2166136261;
    
            return h;
        }
    }

    #endregion

    #region Method Caching

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static MethodCache GetCachedMethod(scoped in RuntimeTypeHandle type, string methodName, int nameHash = 0)
    {
        nameHash = nameHash is 0 ? StringComparer.Ordinal.GetHashCode(methodName) : nameHash;
        int key = type.Equals(TargetTypeHandle)
                      ? TypeHash ^ nameHash ^ TargetTypeHash
                      : TypeHash ^ nameHash ^ type.GetHashCode();

        if (!Methods.TryGetValue(key, out var result))
        {
            const BindingFlags flags = BindingFlags.Public | BindingFlags.NonPublic |
                                       BindingFlags.Instance | BindingFlags.Static;
    
            Type[] paramTypes = Type.EmptyTypes;

#if NET8_0_OR_GREATER
            var method = Type.GetTypeFromHandle(type)!.GetMethod(methodName, flags, paramTypes)
                         ?? throw new MissingMethodException($"Method {methodName} not found on {Type.GetTypeFromHandle(type)!}");
#else
            var method = Type.GetTypeFromHandle(type)!.GetMethod(methodName, flags, null, paramTypes, null)
                         ?? throw new MissingMethodException($"Method {methodName} not found on {Type.GetTypeFromHandle(type)!}");
#endif
            result = new MethodCache(method.IsStatic, method.MethodHandle.GetFunctionPointer(), method);

            Methods.TryAdd(key, result);
        }

        return result;
    }
    
    #endregion
}

public unsafe struct LuminAction<
#if NET8_0_OR_GREATER
[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)]
#endif
TTarget, T1> : IDisposable, ICloneable, ISerializable, IEquatable<LuminAction<TTarget, T1>>
#if NET9_0_OR_GREATER
    where TTarget : allows ref struct
    where T1 : allows ref struct
#endif
{
    private void* _targetPointer; 
    private object? _referenceTarget; 
    private readonly IntPtr _methodPtr;
    private readonly bool _isStatic;
    private readonly MethodInfo _method; 
    private bool _disposed;

    private static readonly bool IsValueType = typeof(TTarget).IsValueType;
    
    public TTarget? Target
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            ThrowIfDisposed();
            
            if (_isStatic)
                return default;
            
            if (IsValueType)
                return Unsafe.AsRef<TTarget?>(_targetPointer);
            
            var target = _referenceTarget;
            return Unsafe.As<object?, TTarget?>(ref target);
        }
    }
    
    public MethodInfo Method => _method;

    #region Constructors
    
    private LuminAction(MethodCache method)
    {
        _method = method.MethodBase ?? throw new ArgumentNullException(nameof(method));
        _isStatic = method.IsStatic;
        _methodPtr = method.MethodPtr;


        if (!_isStatic)
            throw new ArgumentException("methods are not static!", method.MethodBase.Name);

        _referenceTarget = null;
        _targetPointer = null;
    }
    
    private LuminAction(scoped ref TTarget? target, MethodCache method)
    {
        _method = method.MethodBase ?? throw new ArgumentNullException(nameof(method));
        _isStatic = method.IsStatic;
        _methodPtr = method.MethodPtr;
        _targetPointer = null;        
        if (!_isStatic)
        {
            if (IsValueType)
            {
#if NET8_0_OR_GREATER
                if (Unsafe.IsNullRef(ref target))
                    throw new ArgumentException("Target value instance cannot be null.", nameof(target));
#endif

#if NET8_0_OR_GREATER
                _targetPointer = NativeMemory.Alloc((nuint)Unsafe.SizeOf<TTarget>());
#else
                _targetPointer = Marshal.AllocHGlobal(Unsafe.SizeOf<TTarget>()).ToPointer();
#endif
                Unsafe.CopyBlock(
                    _targetPointer,
                    Unsafe.AsPointer(ref target),
                    (uint)Unsafe.SizeOf<TTarget>()
                );
            }
            else
            {
                // 引用类型：固定对象并获取指针
                if (target is null)
                    throw new ArgumentException("Target instance object is null.", nameof(target));
                
                _referenceTarget = Unsafe.As<TTarget, object?>(ref target);
                
            }
        }
        else
        {
            _referenceTarget = null;
        }
    }
    
    private LuminAction(Delegate @delegate)
    {
        _method = @delegate.Method ?? throw new ArgumentNullException(nameof(@delegate.Method));
        _isStatic = @delegate.Method.IsStatic;
        _methodPtr = @delegate.Method.MethodHandle.GetFunctionPointer();
        _targetPointer = null;

        var target = @delegate.Target;
        if (!_isStatic)
        {
            if (target is not TTarget)
                throw new ArgumentException("Target instance object is not type.", typeof(TTarget).Name);
                
            if (IsValueType)
            {
#if NET8_0_OR_GREATER
                if (Unsafe.IsNullRef(ref target))
                    throw new ArgumentException("Target value instance cannot be null.", nameof(target));
#endif
                // 从Delegate创建，不可能是refLike
                var unboxedTarget = Unsafe.AsRef<TTarget>(Unsafe.AsPointer(ref target));
                
#if NET8_0_OR_GREATER
                _targetPointer = NativeMemory.Alloc((nuint)Unsafe.SizeOf<TTarget>());
#else
                _targetPointer = Marshal.AllocHGlobal(Unsafe.SizeOf<TTarget>()).ToPointer();
#endif
                Unsafe.CopyBlock(
                    _targetPointer,
                    Unsafe.AsPointer(ref unboxedTarget),
                    (uint)Unsafe.SizeOf<TTarget>()
                );
            }
            else
            {
                // 引用类型：固定对象并获取指针
                if (target is null)
                    throw new ArgumentException("Target instance object is null.", nameof(target));
                
                _referenceTarget = target;
            }
        }
        else
        {
            _referenceTarget = null;
        }
    }

    #endregion
    
    #region Create Factory

    /// <summary>
    /// 创建Lumin委托
    /// </summary>
    /// <param name="target">委托绑定的实例</param>
    /// <param name="methodName">委托绑定的方法名</param>
    /// <param name="methodNameHash">方法名哈希值（可选）</param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1> Create(scoped ref TTarget? target, string methodName, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        
        var method = GetCachedMethod(IsValueType
                ? TargetTypeHandle
                : Unsafe.As<TTarget, object?>(ref target!)?.GetType().TypeHandle ?? TargetTypeHandle,
            methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        return new LuminAction<TTarget, T1>(ref target, method);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1> Create(scoped ref TTarget? target, string methodName, Type targetType, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(targetType.TypeHandle, methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        return new LuminAction<TTarget, T1>(ref target, method);
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1> Create(scoped ref TTarget? target, ReadOnlySpan<char> methodName, int methodNameHash = 0) =>
        Create(ref target, methodName.ToString(), methodNameHash);
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1> Create(scoped ref TTarget? target, ReadOnlySpan<char> methodName, Type targetType, int methodNameHash = 0) =>
        Create(ref target, methodName.ToString(), targetType, methodNameHash);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1> Create(Delegate @delegate) => 
        new LuminAction<TTarget, T1>(@delegate);
    
    /// <summary>
    /// 创建绑定静态方法的Lumin委托
    /// </summary>
    /// <param name="methodName">委托绑定的方法名</param>
    /// <param name="methodNameHash">方法名哈希值（可选）</param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1> Create(string methodName, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(TargetTypeHandle, methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        if (!method.IsStatic)
            throw new ArgumentException("Method is not static, please pass in instance as parameter.", nameof(methodName));
        
        return new LuminAction<TTarget, T1>(method);
    }

    #endregion
    
    #region Interface Implementation

    public void Dispose()
    {
        if (_disposed)
            return;
        
        if (IsValueType && !_isStatic && _targetPointer != null)
        {
#if NET8_0_OR_GREATER
            NativeMemory.Free(_targetPointer);
#else
            Marshal.FreeHGlobal(new IntPtr(_targetPointer));
#endif
        }
        
        _targetPointer = null;
        _referenceTarget = null;

        _disposed = true;
    }
    
    public object Clone()
    {
        ThrowIfDisposed();
        var target = _referenceTarget;
        if (target is null)
            throw new NullReferenceException("Target instance cannot be null.");
                
        return new LuminAction<TTarget, T1>(ref Unsafe.As<object?, TTarget>(ref target)!, new MethodCache(_isStatic, _methodPtr, _method));
    }

    public void GetObjectData(SerializationInfo info, StreamingContext context)
    {
        throw new NotSupportedException();
    }
    
    public override bool Equals(object? obj)
    {
        return obj is LuminAction<TTarget, T1> other && Equals(other);
    }

    public bool Equals(LuminAction<TTarget, T1> other)
    {
        ThrowIfDisposed();
        return _methodPtr == other._methodPtr &&
               _isStatic == other._isStatic &&
               _targetPointer == other._targetPointer;
    }

    public override int GetHashCode()
    {
        ThrowIfDisposed();
        unchecked
        {
            int hash = 17;
            hash = hash * 31 + _methodPtr.GetHashCode();
            hash = hash * 31 + _isStatic.GetHashCode();
            hash = hash * 31 + ((IntPtr)_targetPointer).GetHashCode();
            return hash;
        }
    }

    #endregion
    
    #region Implicit
    
    public static implicit operator LuminAction<TTarget, T1>(in Delegate action) 
        => Create(action);

    // Action 类型的隐式转换
    public static implicit operator LuminAction<TTarget, T1>(Action<T1> action) => 
        Create(action);
    
    #endregion

    #region Invoke

    /// <summary>
    /// 使用反射动态调用方法
    /// 慎用，开销较大
    /// </summary>
    /// <param name="args">方法参数数组</param>
    /// <returns>方法返回值</returns>
    public object? DynamicInvoke(params object?[] args)
    {
        ThrowIfDisposed();
        
        if (_isStatic)
        {
            return _method.Invoke(null, args);
        }
        else
        {
            if (typeof(TTarget).IsByRefLike)
                throw new ArgumentException(
                    "The target type is a by-ref-like type and cannot be converted to a delegate.");

#if !NET9_0_OR_GREATER
            if (IsValueType)
                throw new ArgumentException("The target type is value type and cannot dynamic invoke.");
#endif

#if NET9_0_OR_GREATER
            object? instance = IsValueType
                ? RuntimeHelpers.Box(ref Unsafe.AsRef<byte>(_targetPointer), typeof(TTarget).TypeHandle)
                : _referenceTarget;
#else
            object? instance = _referenceTarget;
#endif

            if (instance is null)
                throw new InvalidOperationException("Target instance is null.");

            return _method.Invoke(instance, args);
        }
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Invoke(T1 arg1)
    {
        ThrowIfDisposed();
 
        if (!_isStatic && !IsValueType)
            ((delegate* managed<TTarget, T1, void>)_methodPtr)(Unsafe.As<object?, TTarget>(ref _referenceTarget), arg1);
        else if (IsValueType)
            ((delegate* managed<ref TTarget, T1, void>)_methodPtr)(ref Unsafe.AsRef<TTarget>(_targetPointer), arg1);
        else
            ((delegate* managed<T1, void>)_methodPtr)(arg1);
    }

    #endregion
    
    #region Auxiliary methods
    
    public TDelegate ToDelegate<TDelegate>()
        where TDelegate : Delegate
    {
        ThrowIfDisposed();
        if (_isStatic)
        {
            return (TDelegate)Delegate.CreateDelegate(typeof(TDelegate), _method);
        }
        else
        {
            if (typeof(TTarget).IsByRefLike)
                throw new ArgumentException("The target type is a by-ref-like type and cannot be converted to a delegate.");
            
#if !NET9_0_OR_GREATER
            if (IsValueType)
                throw new ArgumentException("The target type is value type and cannot be converted to a delegate.");
#endif

#if NET9_0_OR_GREATER
            object? instance = IsValueType 
                ? RuntimeHelpers.Box(ref Unsafe.AsRef<byte>(_targetPointer), typeof(TTarget).TypeHandle)
                : _referenceTarget;
#else
            object? instance = _referenceTarget;
#endif
            
            if (instance is null)
                throw new InvalidOperationException("Target instance is null.");
            
            return (TDelegate)Delegate.CreateDelegate(typeof(TDelegate), instance, _method);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void ThrowIfDisposed()
    {
        if (_disposed)
            throw new ObjectDisposedException(nameof(LuminAction<TTarget, T1>));
    }
    
    #endregion
    
    #region Static Type Hash

    private static readonly int TypeHash = ComputeTypeHash();
    private static readonly int TargetTypeHash = TargetTypeHandle.GetHashCode();
    private static readonly RuntimeTypeHandle TargetTypeHandle = typeof(TTarget).TypeHandle;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static int ComputeTypeHash()
    {
        unchecked
        {
            int h = (int)2166136261;
    
            h = (h * 16777619) ^ typeof(T1).TypeHandle.GetHashCode();
            return h;
        }
    }

    #endregion

    #region Method Caching

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static MethodCache GetCachedMethod(scoped in RuntimeTypeHandle type, string methodName, int nameHash = 0)
    {
        nameHash = nameHash is 0 ? StringComparer.Ordinal.GetHashCode(methodName) : nameHash;
        int key = type.Equals(TargetTypeHandle)
                      ? TypeHash ^ nameHash ^ TargetTypeHash
                      : TypeHash ^ nameHash ^ type.GetHashCode();

        if (!Methods.TryGetValue(key, out var result))
        {
            const BindingFlags flags = BindingFlags.Public | BindingFlags.NonPublic |
                                       BindingFlags.Instance | BindingFlags.Static;
    
            Type[] paramTypes = [ typeof(T1) ];

#if NET8_0_OR_GREATER
            var method = Type.GetTypeFromHandle(type)!.GetMethod(methodName, flags, paramTypes)
                         ?? throw new MissingMethodException($"Method {methodName} not found on {Type.GetTypeFromHandle(type)!}");
#else
            var method = Type.GetTypeFromHandle(type)!.GetMethod(methodName, flags, null, paramTypes, null)
                         ?? throw new MissingMethodException($"Method {methodName} not found on {Type.GetTypeFromHandle(type)!}");
#endif
            result = new MethodCache(method.IsStatic, method.MethodHandle.GetFunctionPointer(), method);

            Methods.TryAdd(key, result);
        }

        return result;
    }
    
    #endregion
}

public unsafe struct LuminAction<
#if NET8_0_OR_GREATER
[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)]
#endif
TTarget, T1, T2> : IDisposable, ICloneable, ISerializable, IEquatable<LuminAction<TTarget, T1, T2>>
#if NET9_0_OR_GREATER
    where TTarget : allows ref struct
    where T1 : allows ref struct
    where T2 : allows ref struct
#endif
{
    private void* _targetPointer; 
    private object? _referenceTarget; 
    private readonly IntPtr _methodPtr;
    private readonly bool _isStatic;
    private readonly MethodInfo _method; 
    private bool _disposed;

    private static readonly bool IsValueType = typeof(TTarget).IsValueType;
    
    public TTarget? Target
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            ThrowIfDisposed();
            
            if (_isStatic)
                return default;
            
            if (IsValueType)
                return Unsafe.AsRef<TTarget?>(_targetPointer);
            
            var target = _referenceTarget;
            return Unsafe.As<object?, TTarget?>(ref target);
        }
    }
    
    public MethodInfo Method => _method;

    #region Constructors
    
    private LuminAction(MethodCache method)
    {
        _method = method.MethodBase ?? throw new ArgumentNullException(nameof(method));
        _isStatic = method.IsStatic;
        _methodPtr = method.MethodPtr;


        if (!_isStatic)
            throw new ArgumentException("methods are not static!", method.MethodBase.Name);

        _referenceTarget = null;
        _targetPointer = null;
    }
    
    private LuminAction(scoped ref TTarget? target, MethodCache method)
    {
        _method = method.MethodBase ?? throw new ArgumentNullException(nameof(method));
        _isStatic = method.IsStatic;
        _methodPtr = method.MethodPtr;
        _targetPointer = null;        
        if (!_isStatic)
        {
            if (IsValueType)
            {
#if NET8_0_OR_GREATER
                if (Unsafe.IsNullRef(ref target))
                    throw new ArgumentException("Target value instance cannot be null.", nameof(target));
#endif

#if NET8_0_OR_GREATER
                _targetPointer = NativeMemory.Alloc((nuint)Unsafe.SizeOf<TTarget>());
#else
                _targetPointer = Marshal.AllocHGlobal(Unsafe.SizeOf<TTarget>()).ToPointer();
#endif
                Unsafe.CopyBlock(
                    _targetPointer,
                    Unsafe.AsPointer(ref target),
                    (uint)Unsafe.SizeOf<TTarget>()
                );
            }
            else
            {
                // 引用类型：固定对象并获取指针
                if (target is null)
                    throw new ArgumentException("Target instance object is null.", nameof(target));
                
                _referenceTarget = Unsafe.As<TTarget, object?>(ref target);
                
            }
        }
        else
        {
            _referenceTarget = null;
        }
    }
    
    private LuminAction(Delegate @delegate)
    {
        _method = @delegate.Method ?? throw new ArgumentNullException(nameof(@delegate.Method));
        _isStatic = @delegate.Method.IsStatic;
        _methodPtr = @delegate.Method.MethodHandle.GetFunctionPointer();
        _targetPointer = null;

        var target = @delegate.Target;
        if (!_isStatic)
        {
            if (target is not TTarget)
                throw new ArgumentException("Target instance object is not type.", typeof(TTarget).Name);
                
            if (IsValueType)
            {
#if NET8_0_OR_GREATER
                if (Unsafe.IsNullRef(ref target))
                    throw new ArgumentException("Target value instance cannot be null.", nameof(target));
#endif
                // 从Delegate创建，不可能是refLike
                var unboxedTarget = Unsafe.AsRef<TTarget>(Unsafe.AsPointer(ref target));
                
#if NET8_0_OR_GREATER
                _targetPointer = NativeMemory.Alloc((nuint)Unsafe.SizeOf<TTarget>());
#else
                _targetPointer = Marshal.AllocHGlobal(Unsafe.SizeOf<TTarget>()).ToPointer();
#endif
                Unsafe.CopyBlock(
                    _targetPointer,
                    Unsafe.AsPointer(ref unboxedTarget),
                    (uint)Unsafe.SizeOf<TTarget>()
                );
            }
            else
            {
                // 引用类型：固定对象并获取指针
                if (target is null)
                    throw new ArgumentException("Target instance object is null.", nameof(target));
                
                _referenceTarget = target;
            }
        }
        else
        {
            _referenceTarget = null;
        }
    }

    #endregion
    
    #region Create Factory

    /// <summary>
    /// 创建Lumin委托
    /// </summary>
    /// <param name="target">委托绑定的实例</param>
    /// <param name="methodName">委托绑定的方法名</param>
    /// <param name="methodNameHash">方法名哈希值（可选）</param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2> Create(scoped ref TTarget? target, string methodName, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        
        var method = GetCachedMethod(IsValueType
                ? TargetTypeHandle
                : Unsafe.As<TTarget, object?>(ref target!)?.GetType().TypeHandle ?? TargetTypeHandle,
            methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        return new LuminAction<TTarget, T1, T2>(ref target, method);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2> Create(scoped ref TTarget? target, string methodName, Type targetType, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(targetType.TypeHandle, methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        return new LuminAction<TTarget, T1, T2>(ref target, method);
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2> Create(scoped ref TTarget? target, ReadOnlySpan<char> methodName, int methodNameHash = 0) =>
        Create(ref target, methodName.ToString(), methodNameHash);
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2> Create(scoped ref TTarget? target, ReadOnlySpan<char> methodName, Type targetType, int methodNameHash = 0) =>
        Create(ref target, methodName.ToString(), targetType, methodNameHash);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2> Create(Delegate @delegate) => 
        new LuminAction<TTarget, T1, T2>(@delegate);
    
    /// <summary>
    /// 创建绑定静态方法的Lumin委托
    /// </summary>
    /// <param name="methodName">委托绑定的方法名</param>
    /// <param name="methodNameHash">方法名哈希值（可选）</param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2> Create(string methodName, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(TargetTypeHandle, methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        if (!method.IsStatic)
            throw new ArgumentException("Method is not static, please pass in instance as parameter.", nameof(methodName));
        
        return new LuminAction<TTarget, T1, T2>(method);
    }

    #endregion
    
    #region Interface Implementation

    public void Dispose()
    {
        if (_disposed)
            return;
        
        if (IsValueType && !_isStatic && _targetPointer != null)
        {
#if NET8_0_OR_GREATER
            NativeMemory.Free(_targetPointer);
#else
            Marshal.FreeHGlobal(new IntPtr(_targetPointer));
#endif
        }
        
        _targetPointer = null;
        _referenceTarget = null;

        _disposed = true;
    }
    
    public object Clone()
    {
        ThrowIfDisposed();
        var target = _referenceTarget;
        if (target is null)
            throw new NullReferenceException("Target instance cannot be null.");
                
        return new LuminAction<TTarget, T1, T2>(ref Unsafe.As<object?, TTarget>(ref target)!, new MethodCache(_isStatic, _methodPtr, _method));
    }

    public void GetObjectData(SerializationInfo info, StreamingContext context)
    {
        throw new NotSupportedException();
    }
    
    public override bool Equals(object? obj)
    {
        return obj is LuminAction<TTarget, T1, T2> other && Equals(other);
    }

    public bool Equals(LuminAction<TTarget, T1, T2> other)
    {
        ThrowIfDisposed();
        return _methodPtr == other._methodPtr &&
               _isStatic == other._isStatic &&
               _targetPointer == other._targetPointer;
    }

    public override int GetHashCode()
    {
        ThrowIfDisposed();
        unchecked
        {
            int hash = 17;
            hash = hash * 31 + _methodPtr.GetHashCode();
            hash = hash * 31 + _isStatic.GetHashCode();
            hash = hash * 31 + ((IntPtr)_targetPointer).GetHashCode();
            return hash;
        }
    }

    #endregion
    
    #region Implicit
    
    public static implicit operator LuminAction<TTarget, T1, T2>(in Delegate action) 
        => Create(action);

    // Action 类型的隐式转换
    public static implicit operator LuminAction<TTarget, T1, T2>(Action<T1, T2> action) => 
        Create(action);
    
    #endregion

    #region Invoke

    /// <summary>
    /// 使用反射动态调用方法
    /// 慎用，开销较大
    /// </summary>
    /// <param name="args">方法参数数组</param>
    /// <returns>方法返回值</returns>
    public object? DynamicInvoke(params object?[] args)
    {
        ThrowIfDisposed();
        
        if (_isStatic)
        {
            return _method.Invoke(null, args);
        }
        else
        {
            if (typeof(TTarget).IsByRefLike)
                throw new ArgumentException(
                    "The target type is a by-ref-like type and cannot be converted to a delegate.");

#if !NET9_0_OR_GREATER
            if (IsValueType)
                throw new ArgumentException("The target type is value type and cannot dynamic invoke.");
#endif

#if NET9_0_OR_GREATER
            object? instance = IsValueType
                ? RuntimeHelpers.Box(ref Unsafe.AsRef<byte>(_targetPointer), typeof(TTarget).TypeHandle)
                : _referenceTarget;
#else
            object? instance = _referenceTarget;
#endif

            if (instance is null)
                throw new InvalidOperationException("Target instance is null.");

            return _method.Invoke(instance, args);
        }
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Invoke(T1 arg1, T2 arg2)
    {
        ThrowIfDisposed();
 
        if (!_isStatic && !IsValueType)
            ((delegate* managed<TTarget, T1, T2, void>)_methodPtr)(Unsafe.As<object?, TTarget>(ref _referenceTarget), arg1, arg2);
        else if (IsValueType)
            ((delegate* managed<ref TTarget, T1, T2, void>)_methodPtr)(ref Unsafe.AsRef<TTarget>(_targetPointer), arg1, arg2);
        else
            ((delegate* managed<T1, T2, void>)_methodPtr)(arg1, arg2);
    }

    #endregion
    
    #region Auxiliary methods
    
    public TDelegate ToDelegate<TDelegate>()
        where TDelegate : Delegate
    {
        ThrowIfDisposed();
        if (_isStatic)
        {
            return (TDelegate)Delegate.CreateDelegate(typeof(TDelegate), _method);
        }
        else
        {
            if (typeof(TTarget).IsByRefLike)
                throw new ArgumentException("The target type is a by-ref-like type and cannot be converted to a delegate.");
            
#if !NET9_0_OR_GREATER
            if (IsValueType)
                throw new ArgumentException("The target type is value type and cannot be converted to a delegate.");
#endif

#if NET9_0_OR_GREATER
            object? instance = IsValueType 
                ? RuntimeHelpers.Box(ref Unsafe.AsRef<byte>(_targetPointer), typeof(TTarget).TypeHandle)
                : _referenceTarget;
#else
            object? instance = _referenceTarget;
#endif
            
            if (instance is null)
                throw new InvalidOperationException("Target instance is null.");
            
            return (TDelegate)Delegate.CreateDelegate(typeof(TDelegate), instance, _method);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void ThrowIfDisposed()
    {
        if (_disposed)
            throw new ObjectDisposedException(nameof(LuminAction<TTarget, T1, T2>));
    }
    
    #endregion
    
    #region Static Type Hash

    private static readonly int TypeHash = ComputeTypeHash();
    private static readonly int TargetTypeHash = TargetTypeHandle.GetHashCode();
    private static readonly RuntimeTypeHandle TargetTypeHandle = typeof(TTarget).TypeHandle;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static int ComputeTypeHash()
    {
        unchecked
        {
            int h = (int)2166136261;
    
            h = (h * 16777619) ^ typeof(T1).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T2).TypeHandle.GetHashCode();
            return h;
        }
    }

    #endregion

    #region Method Caching

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static MethodCache GetCachedMethod(scoped in RuntimeTypeHandle type, string methodName, int nameHash = 0)
    {
        nameHash = nameHash is 0 ? StringComparer.Ordinal.GetHashCode(methodName) : nameHash;
        int key = type.Equals(TargetTypeHandle)
                      ? TypeHash ^ nameHash ^ TargetTypeHash
                      : TypeHash ^ nameHash ^ type.GetHashCode();

        if (!Methods.TryGetValue(key, out var result))
        {
            const BindingFlags flags = BindingFlags.Public | BindingFlags.NonPublic |
                                       BindingFlags.Instance | BindingFlags.Static;
    
            Type[] paramTypes = [ typeof(T1), typeof(T2) ];

#if NET8_0_OR_GREATER
            var method = Type.GetTypeFromHandle(type)!.GetMethod(methodName, flags, paramTypes)
                         ?? throw new MissingMethodException($"Method {methodName} not found on {Type.GetTypeFromHandle(type)!}");
#else
            var method = Type.GetTypeFromHandle(type)!.GetMethod(methodName, flags, null, paramTypes, null)
                         ?? throw new MissingMethodException($"Method {methodName} not found on {Type.GetTypeFromHandle(type)!}");
#endif
            result = new MethodCache(method.IsStatic, method.MethodHandle.GetFunctionPointer(), method);

            Methods.TryAdd(key, result);
        }

        return result;
    }
    
    #endregion
}

public unsafe struct LuminAction<
#if NET8_0_OR_GREATER
[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)]
#endif
TTarget, T1, T2, T3> : IDisposable, ICloneable, ISerializable, IEquatable<LuminAction<TTarget, T1, T2, T3>>
#if NET9_0_OR_GREATER
    where TTarget : allows ref struct
    where T1 : allows ref struct
    where T2 : allows ref struct
    where T3 : allows ref struct
#endif
{
    private void* _targetPointer; 
    private object? _referenceTarget; 
    private readonly IntPtr _methodPtr;
    private readonly bool _isStatic;
    private readonly MethodInfo _method; 
    private bool _disposed;

    private static readonly bool IsValueType = typeof(TTarget).IsValueType;
    
    public TTarget? Target
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            ThrowIfDisposed();
            
            if (_isStatic)
                return default;
            
            if (IsValueType)
                return Unsafe.AsRef<TTarget?>(_targetPointer);
            
            var target = _referenceTarget;
            return Unsafe.As<object?, TTarget?>(ref target);
        }
    }
    
    public MethodInfo Method => _method;

    #region Constructors
    
    private LuminAction(MethodCache method)
    {
        _method = method.MethodBase ?? throw new ArgumentNullException(nameof(method));
        _isStatic = method.IsStatic;
        _methodPtr = method.MethodPtr;


        if (!_isStatic)
            throw new ArgumentException("methods are not static!", method.MethodBase.Name);

        _referenceTarget = null;
        _targetPointer = null;
    }
    
    private LuminAction(scoped ref TTarget? target, MethodCache method)
    {
        _method = method.MethodBase ?? throw new ArgumentNullException(nameof(method));
        _isStatic = method.IsStatic;
        _methodPtr = method.MethodPtr;
        _targetPointer = null;        
        if (!_isStatic)
        {
            if (IsValueType)
            {
#if NET8_0_OR_GREATER
                if (Unsafe.IsNullRef(ref target))
                    throw new ArgumentException("Target value instance cannot be null.", nameof(target));
#endif

#if NET8_0_OR_GREATER
                _targetPointer = NativeMemory.Alloc((nuint)Unsafe.SizeOf<TTarget>());
#else
                _targetPointer = Marshal.AllocHGlobal(Unsafe.SizeOf<TTarget>()).ToPointer();
#endif
                Unsafe.CopyBlock(
                    _targetPointer,
                    Unsafe.AsPointer(ref target),
                    (uint)Unsafe.SizeOf<TTarget>()
                );
            }
            else
            {
                // 引用类型：固定对象并获取指针
                if (target is null)
                    throw new ArgumentException("Target instance object is null.", nameof(target));
                
                _referenceTarget = Unsafe.As<TTarget, object?>(ref target);
                
            }
        }
        else
        {
            _referenceTarget = null;
        }
    }
    
    private LuminAction(Delegate @delegate)
    {
        _method = @delegate.Method ?? throw new ArgumentNullException(nameof(@delegate.Method));
        _isStatic = @delegate.Method.IsStatic;
        _methodPtr = @delegate.Method.MethodHandle.GetFunctionPointer();
        _targetPointer = null;

        var target = @delegate.Target;
        if (!_isStatic)
        {
            if (target is not TTarget)
                throw new ArgumentException("Target instance object is not type.", typeof(TTarget).Name);
                
            if (IsValueType)
            {
#if NET8_0_OR_GREATER
                if (Unsafe.IsNullRef(ref target))
                    throw new ArgumentException("Target value instance cannot be null.", nameof(target));
#endif
                // 从Delegate创建，不可能是refLike
                var unboxedTarget = Unsafe.AsRef<TTarget>(Unsafe.AsPointer(ref target));
                
#if NET8_0_OR_GREATER
                _targetPointer = NativeMemory.Alloc((nuint)Unsafe.SizeOf<TTarget>());
#else
                _targetPointer = Marshal.AllocHGlobal(Unsafe.SizeOf<TTarget>()).ToPointer();
#endif
                Unsafe.CopyBlock(
                    _targetPointer,
                    Unsafe.AsPointer(ref unboxedTarget),
                    (uint)Unsafe.SizeOf<TTarget>()
                );
            }
            else
            {
                // 引用类型：固定对象并获取指针
                if (target is null)
                    throw new ArgumentException("Target instance object is null.", nameof(target));
                
                _referenceTarget = target;
            }
        }
        else
        {
            _referenceTarget = null;
        }
    }

    #endregion
    
    #region Create Factory

    /// <summary>
    /// 创建Lumin委托
    /// </summary>
    /// <param name="target">委托绑定的实例</param>
    /// <param name="methodName">委托绑定的方法名</param>
    /// <param name="methodNameHash">方法名哈希值（可选）</param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3> Create(scoped ref TTarget? target, string methodName, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        
        var method = GetCachedMethod(IsValueType
                ? TargetTypeHandle
                : Unsafe.As<TTarget, object?>(ref target!)?.GetType().TypeHandle ?? TargetTypeHandle,
            methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        return new LuminAction<TTarget, T1, T2, T3>(ref target, method);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3> Create(scoped ref TTarget? target, string methodName, Type targetType, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(targetType.TypeHandle, methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        return new LuminAction<TTarget, T1, T2, T3>(ref target, method);
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3> Create(scoped ref TTarget? target, ReadOnlySpan<char> methodName, int methodNameHash = 0) =>
        Create(ref target, methodName.ToString(), methodNameHash);
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3> Create(scoped ref TTarget? target, ReadOnlySpan<char> methodName, Type targetType, int methodNameHash = 0) =>
        Create(ref target, methodName.ToString(), targetType, methodNameHash);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3> Create(Delegate @delegate) => 
        new LuminAction<TTarget, T1, T2, T3>(@delegate);
    
    /// <summary>
    /// 创建绑定静态方法的Lumin委托
    /// </summary>
    /// <param name="methodName">委托绑定的方法名</param>
    /// <param name="methodNameHash">方法名哈希值（可选）</param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3> Create(string methodName, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(TargetTypeHandle, methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        if (!method.IsStatic)
            throw new ArgumentException("Method is not static, please pass in instance as parameter.", nameof(methodName));
        
        return new LuminAction<TTarget, T1, T2, T3>(method);
    }

    #endregion
    
    #region Interface Implementation

    public void Dispose()
    {
        if (_disposed)
            return;
        
        if (IsValueType && !_isStatic && _targetPointer != null)
        {
#if NET8_0_OR_GREATER
            NativeMemory.Free(_targetPointer);
#else
            Marshal.FreeHGlobal(new IntPtr(_targetPointer));
#endif
        }
        
        _targetPointer = null;
        _referenceTarget = null;

        _disposed = true;
    }
    
    public object Clone()
    {
        ThrowIfDisposed();
        var target = _referenceTarget;
        if (target is null)
            throw new NullReferenceException("Target instance cannot be null.");
                
        return new LuminAction<TTarget, T1, T2, T3>(ref Unsafe.As<object?, TTarget>(ref target)!, new MethodCache(_isStatic, _methodPtr, _method));
    }

    public void GetObjectData(SerializationInfo info, StreamingContext context)
    {
        throw new NotSupportedException();
    }
    
    public override bool Equals(object? obj)
    {
        return obj is LuminAction<TTarget, T1, T2, T3> other && Equals(other);
    }

    public bool Equals(LuminAction<TTarget, T1, T2, T3> other)
    {
        ThrowIfDisposed();
        return _methodPtr == other._methodPtr &&
               _isStatic == other._isStatic &&
               _targetPointer == other._targetPointer;
    }

    public override int GetHashCode()
    {
        ThrowIfDisposed();
        unchecked
        {
            int hash = 17;
            hash = hash * 31 + _methodPtr.GetHashCode();
            hash = hash * 31 + _isStatic.GetHashCode();
            hash = hash * 31 + ((IntPtr)_targetPointer).GetHashCode();
            return hash;
        }
    }

    #endregion
    
    #region Implicit
    
    public static implicit operator LuminAction<TTarget, T1, T2, T3>(in Delegate action) 
        => Create(action);

    // Action 类型的隐式转换
    public static implicit operator LuminAction<TTarget, T1, T2, T3>(Action<T1, T2, T3> action) => 
        Create(action);
    
    #endregion

    #region Invoke

    /// <summary>
    /// 使用反射动态调用方法
    /// 慎用，开销较大
    /// </summary>
    /// <param name="args">方法参数数组</param>
    /// <returns>方法返回值</returns>
    public object? DynamicInvoke(params object?[] args)
    {
        ThrowIfDisposed();
        
        if (_isStatic)
        {
            return _method.Invoke(null, args);
        }
        else
        {
            if (typeof(TTarget).IsByRefLike)
                throw new ArgumentException(
                    "The target type is a by-ref-like type and cannot be converted to a delegate.");

#if !NET9_0_OR_GREATER
            if (IsValueType)
                throw new ArgumentException("The target type is value type and cannot dynamic invoke.");
#endif

#if NET9_0_OR_GREATER
            object? instance = IsValueType
                ? RuntimeHelpers.Box(ref Unsafe.AsRef<byte>(_targetPointer), typeof(TTarget).TypeHandle)
                : _referenceTarget;
#else
            object? instance = _referenceTarget;
#endif

            if (instance is null)
                throw new InvalidOperationException("Target instance is null.");

            return _method.Invoke(instance, args);
        }
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Invoke(T1 arg1, T2 arg2, T3 arg3)
    {
        ThrowIfDisposed();
 
        if (!_isStatic && !IsValueType)
            ((delegate* managed<TTarget, T1, T2, T3, void>)_methodPtr)(Unsafe.As<object?, TTarget>(ref _referenceTarget), arg1, arg2, arg3);
        else if (IsValueType)
            ((delegate* managed<ref TTarget, T1, T2, T3, void>)_methodPtr)(ref Unsafe.AsRef<TTarget>(_targetPointer), arg1, arg2, arg3);
        else
            ((delegate* managed<T1, T2, T3, void>)_methodPtr)(arg1, arg2, arg3);
    }

    #endregion
    
    #region Auxiliary methods
    
    public TDelegate ToDelegate<TDelegate>()
        where TDelegate : Delegate
    {
        ThrowIfDisposed();
        if (_isStatic)
        {
            return (TDelegate)Delegate.CreateDelegate(typeof(TDelegate), _method);
        }
        else
        {
            if (typeof(TTarget).IsByRefLike)
                throw new ArgumentException("The target type is a by-ref-like type and cannot be converted to a delegate.");
            
#if !NET9_0_OR_GREATER
            if (IsValueType)
                throw new ArgumentException("The target type is value type and cannot be converted to a delegate.");
#endif

#if NET9_0_OR_GREATER
            object? instance = IsValueType 
                ? RuntimeHelpers.Box(ref Unsafe.AsRef<byte>(_targetPointer), typeof(TTarget).TypeHandle)
                : _referenceTarget;
#else
            object? instance = _referenceTarget;
#endif
            
            if (instance is null)
                throw new InvalidOperationException("Target instance is null.");
            
            return (TDelegate)Delegate.CreateDelegate(typeof(TDelegate), instance, _method);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void ThrowIfDisposed()
    {
        if (_disposed)
            throw new ObjectDisposedException(nameof(LuminAction<TTarget, T1, T2, T3>));
    }
    
    #endregion
    
    #region Static Type Hash

    private static readonly int TypeHash = ComputeTypeHash();
    private static readonly int TargetTypeHash = TargetTypeHandle.GetHashCode();
    private static readonly RuntimeTypeHandle TargetTypeHandle = typeof(TTarget).TypeHandle;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static int ComputeTypeHash()
    {
        unchecked
        {
            int h = (int)2166136261;
    
            h = (h * 16777619) ^ typeof(T1).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T2).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T3).TypeHandle.GetHashCode();
            return h;
        }
    }

    #endregion

    #region Method Caching

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static MethodCache GetCachedMethod(scoped in RuntimeTypeHandle type, string methodName, int nameHash = 0)
    {
        nameHash = nameHash is 0 ? StringComparer.Ordinal.GetHashCode(methodName) : nameHash;
        int key = type.Equals(TargetTypeHandle)
                      ? TypeHash ^ nameHash ^ TargetTypeHash
                      : TypeHash ^ nameHash ^ type.GetHashCode();

        if (!Methods.TryGetValue(key, out var result))
        {
            const BindingFlags flags = BindingFlags.Public | BindingFlags.NonPublic |
                                       BindingFlags.Instance | BindingFlags.Static;
    
            Type[] paramTypes = [ typeof(T1), typeof(T2), typeof(T3) ];

#if NET8_0_OR_GREATER
            var method = Type.GetTypeFromHandle(type)!.GetMethod(methodName, flags, paramTypes)
                         ?? throw new MissingMethodException($"Method {methodName} not found on {Type.GetTypeFromHandle(type)!}");
#else
            var method = Type.GetTypeFromHandle(type)!.GetMethod(methodName, flags, null, paramTypes, null)
                         ?? throw new MissingMethodException($"Method {methodName} not found on {Type.GetTypeFromHandle(type)!}");
#endif
            result = new MethodCache(method.IsStatic, method.MethodHandle.GetFunctionPointer(), method);

            Methods.TryAdd(key, result);
        }

        return result;
    }
    
    #endregion
}

public unsafe struct LuminAction<
#if NET8_0_OR_GREATER
[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)]
#endif
TTarget, T1, T2, T3, T4> : IDisposable, ICloneable, ISerializable, IEquatable<LuminAction<TTarget, T1, T2, T3, T4>>
#if NET9_0_OR_GREATER
    where TTarget : allows ref struct
    where T1 : allows ref struct
    where T2 : allows ref struct
    where T3 : allows ref struct
    where T4 : allows ref struct
#endif
{
    private void* _targetPointer; 
    private object? _referenceTarget; 
    private readonly IntPtr _methodPtr;
    private readonly bool _isStatic;
    private readonly MethodInfo _method; 
    private bool _disposed;

    private static readonly bool IsValueType = typeof(TTarget).IsValueType;
    
    public TTarget? Target
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            ThrowIfDisposed();
            
            if (_isStatic)
                return default;
            
            if (IsValueType)
                return Unsafe.AsRef<TTarget?>(_targetPointer);
            
            var target = _referenceTarget;
            return Unsafe.As<object?, TTarget?>(ref target);
        }
    }
    
    public MethodInfo Method => _method;

    #region Constructors
    
    private LuminAction(MethodCache method)
    {
        _method = method.MethodBase ?? throw new ArgumentNullException(nameof(method));
        _isStatic = method.IsStatic;
        _methodPtr = method.MethodPtr;


        if (!_isStatic)
            throw new ArgumentException("methods are not static!", method.MethodBase.Name);

        _referenceTarget = null;
        _targetPointer = null;
    }
    
    private LuminAction(scoped ref TTarget? target, MethodCache method)
    {
        _method = method.MethodBase ?? throw new ArgumentNullException(nameof(method));
        _isStatic = method.IsStatic;
        _methodPtr = method.MethodPtr;
        _targetPointer = null;        
        if (!_isStatic)
        {
            if (IsValueType)
            {
#if NET8_0_OR_GREATER
                if (Unsafe.IsNullRef(ref target))
                    throw new ArgumentException("Target value instance cannot be null.", nameof(target));
#endif

#if NET8_0_OR_GREATER
                _targetPointer = NativeMemory.Alloc((nuint)Unsafe.SizeOf<TTarget>());
#else
                _targetPointer = Marshal.AllocHGlobal(Unsafe.SizeOf<TTarget>()).ToPointer();
#endif
                Unsafe.CopyBlock(
                    _targetPointer,
                    Unsafe.AsPointer(ref target),
                    (uint)Unsafe.SizeOf<TTarget>()
                );
            }
            else
            {
                // 引用类型：固定对象并获取指针
                if (target is null)
                    throw new ArgumentException("Target instance object is null.", nameof(target));
                
                _referenceTarget = Unsafe.As<TTarget, object?>(ref target);
                
            }
        }
        else
        {
            _referenceTarget = null;
        }
    }
    
    private LuminAction(Delegate @delegate)
    {
        _method = @delegate.Method ?? throw new ArgumentNullException(nameof(@delegate.Method));
        _isStatic = @delegate.Method.IsStatic;
        _methodPtr = @delegate.Method.MethodHandle.GetFunctionPointer();
        _targetPointer = null;

        var target = @delegate.Target;
        if (!_isStatic)
        {
            if (target is not TTarget)
                throw new ArgumentException("Target instance object is not type.", typeof(TTarget).Name);
                
            if (IsValueType)
            {
#if NET8_0_OR_GREATER
                if (Unsafe.IsNullRef(ref target))
                    throw new ArgumentException("Target value instance cannot be null.", nameof(target));
#endif
                // 从Delegate创建，不可能是refLike
                var unboxedTarget = Unsafe.AsRef<TTarget>(Unsafe.AsPointer(ref target));
                
#if NET8_0_OR_GREATER
                _targetPointer = NativeMemory.Alloc((nuint)Unsafe.SizeOf<TTarget>());
#else
                _targetPointer = Marshal.AllocHGlobal(Unsafe.SizeOf<TTarget>()).ToPointer();
#endif
                Unsafe.CopyBlock(
                    _targetPointer,
                    Unsafe.AsPointer(ref unboxedTarget),
                    (uint)Unsafe.SizeOf<TTarget>()
                );
            }
            else
            {
                // 引用类型：固定对象并获取指针
                if (target is null)
                    throw new ArgumentException("Target instance object is null.", nameof(target));
                
                _referenceTarget = target;
            }
        }
        else
        {
            _referenceTarget = null;
        }
    }

    #endregion
    
    #region Create Factory

    /// <summary>
    /// 创建Lumin委托
    /// </summary>
    /// <param name="target">委托绑定的实例</param>
    /// <param name="methodName">委托绑定的方法名</param>
    /// <param name="methodNameHash">方法名哈希值（可选）</param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3, T4> Create(scoped ref TTarget? target, string methodName, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        
        var method = GetCachedMethod(IsValueType
                ? TargetTypeHandle
                : Unsafe.As<TTarget, object?>(ref target!)?.GetType().TypeHandle ?? TargetTypeHandle,
            methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        return new LuminAction<TTarget, T1, T2, T3, T4>(ref target, method);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3, T4> Create(scoped ref TTarget? target, string methodName, Type targetType, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(targetType.TypeHandle, methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        return new LuminAction<TTarget, T1, T2, T3, T4>(ref target, method);
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3, T4> Create(scoped ref TTarget? target, ReadOnlySpan<char> methodName, int methodNameHash = 0) =>
        Create(ref target, methodName.ToString(), methodNameHash);
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3, T4> Create(scoped ref TTarget? target, ReadOnlySpan<char> methodName, Type targetType, int methodNameHash = 0) =>
        Create(ref target, methodName.ToString(), targetType, methodNameHash);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3, T4> Create(Delegate @delegate) => 
        new LuminAction<TTarget, T1, T2, T3, T4>(@delegate);
    
    /// <summary>
    /// 创建绑定静态方法的Lumin委托
    /// </summary>
    /// <param name="methodName">委托绑定的方法名</param>
    /// <param name="methodNameHash">方法名哈希值（可选）</param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3, T4> Create(string methodName, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(TargetTypeHandle, methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        if (!method.IsStatic)
            throw new ArgumentException("Method is not static, please pass in instance as parameter.", nameof(methodName));
        
        return new LuminAction<TTarget, T1, T2, T3, T4>(method);
    }

    #endregion
    
    #region Interface Implementation

    public void Dispose()
    {
        if (_disposed)
            return;
        
        if (IsValueType && !_isStatic && _targetPointer != null)
        {
#if NET8_0_OR_GREATER
            NativeMemory.Free(_targetPointer);
#else
            Marshal.FreeHGlobal(new IntPtr(_targetPointer));
#endif
        }
        
        _targetPointer = null;
        _referenceTarget = null;

        _disposed = true;
    }
    
    public object Clone()
    {
        ThrowIfDisposed();
        var target = _referenceTarget;
        if (target is null)
            throw new NullReferenceException("Target instance cannot be null.");
                
        return new LuminAction<TTarget, T1, T2, T3, T4>(ref Unsafe.As<object?, TTarget>(ref target)!, new MethodCache(_isStatic, _methodPtr, _method));
    }

    public void GetObjectData(SerializationInfo info, StreamingContext context)
    {
        throw new NotSupportedException();
    }
    
    public override bool Equals(object? obj)
    {
        return obj is LuminAction<TTarget, T1, T2, T3, T4> other && Equals(other);
    }

    public bool Equals(LuminAction<TTarget, T1, T2, T3, T4> other)
    {
        ThrowIfDisposed();
        return _methodPtr == other._methodPtr &&
               _isStatic == other._isStatic &&
               _targetPointer == other._targetPointer;
    }

    public override int GetHashCode()
    {
        ThrowIfDisposed();
        unchecked
        {
            int hash = 17;
            hash = hash * 31 + _methodPtr.GetHashCode();
            hash = hash * 31 + _isStatic.GetHashCode();
            hash = hash * 31 + ((IntPtr)_targetPointer).GetHashCode();
            return hash;
        }
    }

    #endregion
    
    #region Implicit
    
    public static implicit operator LuminAction<TTarget, T1, T2, T3, T4>(in Delegate action) 
        => Create(action);

    // Action 类型的隐式转换
    public static implicit operator LuminAction<TTarget, T1, T2, T3, T4>(Action<T1, T2, T3, T4> action) => 
        Create(action);
    
    #endregion

    #region Invoke

    /// <summary>
    /// 使用反射动态调用方法
    /// 慎用，开销较大
    /// </summary>
    /// <param name="args">方法参数数组</param>
    /// <returns>方法返回值</returns>
    public object? DynamicInvoke(params object?[] args)
    {
        ThrowIfDisposed();
        
        if (_isStatic)
        {
            return _method.Invoke(null, args);
        }
        else
        {
            if (typeof(TTarget).IsByRefLike)
                throw new ArgumentException(
                    "The target type is a by-ref-like type and cannot be converted to a delegate.");

#if !NET9_0_OR_GREATER
            if (IsValueType)
                throw new ArgumentException("The target type is value type and cannot dynamic invoke.");
#endif

#if NET9_0_OR_GREATER
            object? instance = IsValueType
                ? RuntimeHelpers.Box(ref Unsafe.AsRef<byte>(_targetPointer), typeof(TTarget).TypeHandle)
                : _referenceTarget;
#else
            object? instance = _referenceTarget;
#endif

            if (instance is null)
                throw new InvalidOperationException("Target instance is null.");

            return _method.Invoke(instance, args);
        }
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4)
    {
        ThrowIfDisposed();
 
        if (!_isStatic && !IsValueType)
            ((delegate* managed<TTarget, T1, T2, T3, T4, void>)_methodPtr)(Unsafe.As<object?, TTarget>(ref _referenceTarget), arg1, arg2, arg3, arg4);
        else if (IsValueType)
            ((delegate* managed<ref TTarget, T1, T2, T3, T4, void>)_methodPtr)(ref Unsafe.AsRef<TTarget>(_targetPointer), arg1, arg2, arg3, arg4);
        else
            ((delegate* managed<T1, T2, T3, T4, void>)_methodPtr)(arg1, arg2, arg3, arg4);
    }

    #endregion
    
    #region Auxiliary methods
    
    public TDelegate ToDelegate<TDelegate>()
        where TDelegate : Delegate
    {
        ThrowIfDisposed();
        if (_isStatic)
        {
            return (TDelegate)Delegate.CreateDelegate(typeof(TDelegate), _method);
        }
        else
        {
            if (typeof(TTarget).IsByRefLike)
                throw new ArgumentException("The target type is a by-ref-like type and cannot be converted to a delegate.");
            
#if !NET9_0_OR_GREATER
            if (IsValueType)
                throw new ArgumentException("The target type is value type and cannot be converted to a delegate.");
#endif

#if NET9_0_OR_GREATER
            object? instance = IsValueType 
                ? RuntimeHelpers.Box(ref Unsafe.AsRef<byte>(_targetPointer), typeof(TTarget).TypeHandle)
                : _referenceTarget;
#else
            object? instance = _referenceTarget;
#endif
            
            if (instance is null)
                throw new InvalidOperationException("Target instance is null.");
            
            return (TDelegate)Delegate.CreateDelegate(typeof(TDelegate), instance, _method);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void ThrowIfDisposed()
    {
        if (_disposed)
            throw new ObjectDisposedException(nameof(LuminAction<TTarget, T1, T2, T3, T4>));
    }
    
    #endregion
    
    #region Static Type Hash

    private static readonly int TypeHash = ComputeTypeHash();
    private static readonly int TargetTypeHash = TargetTypeHandle.GetHashCode();
    private static readonly RuntimeTypeHandle TargetTypeHandle = typeof(TTarget).TypeHandle;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static int ComputeTypeHash()
    {
        unchecked
        {
            int h = (int)2166136261;
    
            h = (h * 16777619) ^ typeof(T1).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T2).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T3).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T4).TypeHandle.GetHashCode();
            return h;
        }
    }

    #endregion

    #region Method Caching

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static MethodCache GetCachedMethod(scoped in RuntimeTypeHandle type, string methodName, int nameHash = 0)
    {
        nameHash = nameHash is 0 ? StringComparer.Ordinal.GetHashCode(methodName) : nameHash;
        int key = type.Equals(TargetTypeHandle)
                      ? TypeHash ^ nameHash ^ TargetTypeHash
                      : TypeHash ^ nameHash ^ type.GetHashCode();

        if (!Methods.TryGetValue(key, out var result))
        {
            const BindingFlags flags = BindingFlags.Public | BindingFlags.NonPublic |
                                       BindingFlags.Instance | BindingFlags.Static;
    
            Type[] paramTypes = [ typeof(T1), typeof(T2), typeof(T3), typeof(T4) ];

#if NET8_0_OR_GREATER
            var method = Type.GetTypeFromHandle(type)!.GetMethod(methodName, flags, paramTypes)
                         ?? throw new MissingMethodException($"Method {methodName} not found on {Type.GetTypeFromHandle(type)!}");
#else
            var method = Type.GetTypeFromHandle(type)!.GetMethod(methodName, flags, null, paramTypes, null)
                         ?? throw new MissingMethodException($"Method {methodName} not found on {Type.GetTypeFromHandle(type)!}");
#endif
            result = new MethodCache(method.IsStatic, method.MethodHandle.GetFunctionPointer(), method);

            Methods.TryAdd(key, result);
        }

        return result;
    }
    
    #endregion
}

public unsafe struct LuminAction<
#if NET8_0_OR_GREATER
[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)]
#endif
TTarget, T1, T2, T3, T4, T5> : IDisposable, ICloneable, ISerializable, IEquatable<LuminAction<TTarget, T1, T2, T3, T4, T5>>
#if NET9_0_OR_GREATER
    where TTarget : allows ref struct
    where T1 : allows ref struct
    where T2 : allows ref struct
    where T3 : allows ref struct
    where T4 : allows ref struct
    where T5 : allows ref struct
#endif
{
    private void* _targetPointer; 
    private object? _referenceTarget; 
    private readonly IntPtr _methodPtr;
    private readonly bool _isStatic;
    private readonly MethodInfo _method; 
    private bool _disposed;

    private static readonly bool IsValueType = typeof(TTarget).IsValueType;
    
    public TTarget? Target
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            ThrowIfDisposed();
            
            if (_isStatic)
                return default;
            
            if (IsValueType)
                return Unsafe.AsRef<TTarget?>(_targetPointer);
            
            var target = _referenceTarget;
            return Unsafe.As<object?, TTarget?>(ref target);
        }
    }
    
    public MethodInfo Method => _method;

    #region Constructors
    
    private LuminAction(MethodCache method)
    {
        _method = method.MethodBase ?? throw new ArgumentNullException(nameof(method));
        _isStatic = method.IsStatic;
        _methodPtr = method.MethodPtr;


        if (!_isStatic)
            throw new ArgumentException("methods are not static!", method.MethodBase.Name);

        _referenceTarget = null;
        _targetPointer = null;
    }
    
    private LuminAction(scoped ref TTarget? target, MethodCache method)
    {
        _method = method.MethodBase ?? throw new ArgumentNullException(nameof(method));
        _isStatic = method.IsStatic;
        _methodPtr = method.MethodPtr;
        _targetPointer = null;        
        if (!_isStatic)
        {
            if (IsValueType)
            {
#if NET8_0_OR_GREATER
                if (Unsafe.IsNullRef(ref target))
                    throw new ArgumentException("Target value instance cannot be null.", nameof(target));
#endif

#if NET8_0_OR_GREATER
                _targetPointer = NativeMemory.Alloc((nuint)Unsafe.SizeOf<TTarget>());
#else
                _targetPointer = Marshal.AllocHGlobal(Unsafe.SizeOf<TTarget>()).ToPointer();
#endif
                Unsafe.CopyBlock(
                    _targetPointer,
                    Unsafe.AsPointer(ref target),
                    (uint)Unsafe.SizeOf<TTarget>()
                );
            }
            else
            {
                // 引用类型：固定对象并获取指针
                if (target is null)
                    throw new ArgumentException("Target instance object is null.", nameof(target));
                
                _referenceTarget = Unsafe.As<TTarget, object?>(ref target);
                
            }
        }
        else
        {
            _referenceTarget = null;
        }
    }
    
    private LuminAction(Delegate @delegate)
    {
        _method = @delegate.Method ?? throw new ArgumentNullException(nameof(@delegate.Method));
        _isStatic = @delegate.Method.IsStatic;
        _methodPtr = @delegate.Method.MethodHandle.GetFunctionPointer();
        _targetPointer = null;

        var target = @delegate.Target;
        if (!_isStatic)
        {
            if (target is not TTarget)
                throw new ArgumentException("Target instance object is not type.", typeof(TTarget).Name);
                
            if (IsValueType)
            {
#if NET8_0_OR_GREATER
                if (Unsafe.IsNullRef(ref target))
                    throw new ArgumentException("Target value instance cannot be null.", nameof(target));
#endif
                // 从Delegate创建，不可能是refLike
                var unboxedTarget = Unsafe.AsRef<TTarget>(Unsafe.AsPointer(ref target));
                
#if NET8_0_OR_GREATER
                _targetPointer = NativeMemory.Alloc((nuint)Unsafe.SizeOf<TTarget>());
#else
                _targetPointer = Marshal.AllocHGlobal(Unsafe.SizeOf<TTarget>()).ToPointer();
#endif
                Unsafe.CopyBlock(
                    _targetPointer,
                    Unsafe.AsPointer(ref unboxedTarget),
                    (uint)Unsafe.SizeOf<TTarget>()
                );
            }
            else
            {
                // 引用类型：固定对象并获取指针
                if (target is null)
                    throw new ArgumentException("Target instance object is null.", nameof(target));
                
                _referenceTarget = target;
            }
        }
        else
        {
            _referenceTarget = null;
        }
    }

    #endregion
    
    #region Create Factory

    /// <summary>
    /// 创建Lumin委托
    /// </summary>
    /// <param name="target">委托绑定的实例</param>
    /// <param name="methodName">委托绑定的方法名</param>
    /// <param name="methodNameHash">方法名哈希值（可选）</param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3, T4, T5> Create(scoped ref TTarget? target, string methodName, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        
        var method = GetCachedMethod(IsValueType
                ? TargetTypeHandle
                : Unsafe.As<TTarget, object?>(ref target!)?.GetType().TypeHandle ?? TargetTypeHandle,
            methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        return new LuminAction<TTarget, T1, T2, T3, T4, T5>(ref target, method);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3, T4, T5> Create(scoped ref TTarget? target, string methodName, Type targetType, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(targetType.TypeHandle, methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        return new LuminAction<TTarget, T1, T2, T3, T4, T5>(ref target, method);
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3, T4, T5> Create(scoped ref TTarget? target, ReadOnlySpan<char> methodName, int methodNameHash = 0) =>
        Create(ref target, methodName.ToString(), methodNameHash);
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3, T4, T5> Create(scoped ref TTarget? target, ReadOnlySpan<char> methodName, Type targetType, int methodNameHash = 0) =>
        Create(ref target, methodName.ToString(), targetType, methodNameHash);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3, T4, T5> Create(Delegate @delegate) => 
        new LuminAction<TTarget, T1, T2, T3, T4, T5>(@delegate);
    
    /// <summary>
    /// 创建绑定静态方法的Lumin委托
    /// </summary>
    /// <param name="methodName">委托绑定的方法名</param>
    /// <param name="methodNameHash">方法名哈希值（可选）</param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3, T4, T5> Create(string methodName, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(TargetTypeHandle, methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        if (!method.IsStatic)
            throw new ArgumentException("Method is not static, please pass in instance as parameter.", nameof(methodName));
        
        return new LuminAction<TTarget, T1, T2, T3, T4, T5>(method);
    }

    #endregion
    
    #region Interface Implementation

    public void Dispose()
    {
        if (_disposed)
            return;
        
        if (IsValueType && !_isStatic && _targetPointer != null)
        {
#if NET8_0_OR_GREATER
            NativeMemory.Free(_targetPointer);
#else
            Marshal.FreeHGlobal(new IntPtr(_targetPointer));
#endif
        }
        
        _targetPointer = null;
        _referenceTarget = null;

        _disposed = true;
    }
    
    public object Clone()
    {
        ThrowIfDisposed();
        var target = _referenceTarget;
        if (target is null)
            throw new NullReferenceException("Target instance cannot be null.");
                
        return new LuminAction<TTarget, T1, T2, T3, T4, T5>(ref Unsafe.As<object?, TTarget>(ref target)!, new MethodCache(_isStatic, _methodPtr, _method));
    }

    public void GetObjectData(SerializationInfo info, StreamingContext context)
    {
        throw new NotSupportedException();
    }
    
    public override bool Equals(object? obj)
    {
        return obj is LuminAction<TTarget, T1, T2, T3, T4, T5> other && Equals(other);
    }

    public bool Equals(LuminAction<TTarget, T1, T2, T3, T4, T5> other)
    {
        ThrowIfDisposed();
        return _methodPtr == other._methodPtr &&
               _isStatic == other._isStatic &&
               _targetPointer == other._targetPointer;
    }

    public override int GetHashCode()
    {
        ThrowIfDisposed();
        unchecked
        {
            int hash = 17;
            hash = hash * 31 + _methodPtr.GetHashCode();
            hash = hash * 31 + _isStatic.GetHashCode();
            hash = hash * 31 + ((IntPtr)_targetPointer).GetHashCode();
            return hash;
        }
    }

    #endregion
    
    #region Implicit
    
    public static implicit operator LuminAction<TTarget, T1, T2, T3, T4, T5>(in Delegate action) 
        => Create(action);

    // Action 类型的隐式转换
    public static implicit operator LuminAction<TTarget, T1, T2, T3, T4, T5>(Action<T1, T2, T3, T4, T5> action) => 
        Create(action);
    
    #endregion

    #region Invoke

    /// <summary>
    /// 使用反射动态调用方法
    /// 慎用，开销较大
    /// </summary>
    /// <param name="args">方法参数数组</param>
    /// <returns>方法返回值</returns>
    public object? DynamicInvoke(params object?[] args)
    {
        ThrowIfDisposed();
        
        if (_isStatic)
        {
            return _method.Invoke(null, args);
        }
        else
        {
            if (typeof(TTarget).IsByRefLike)
                throw new ArgumentException(
                    "The target type is a by-ref-like type and cannot be converted to a delegate.");

#if !NET9_0_OR_GREATER
            if (IsValueType)
                throw new ArgumentException("The target type is value type and cannot dynamic invoke.");
#endif

#if NET9_0_OR_GREATER
            object? instance = IsValueType
                ? RuntimeHelpers.Box(ref Unsafe.AsRef<byte>(_targetPointer), typeof(TTarget).TypeHandle)
                : _referenceTarget;
#else
            object? instance = _referenceTarget;
#endif

            if (instance is null)
                throw new InvalidOperationException("Target instance is null.");

            return _method.Invoke(instance, args);
        }
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5)
    {
        ThrowIfDisposed();
 
        if (!_isStatic && !IsValueType)
            ((delegate* managed<TTarget, T1, T2, T3, T4, T5, void>)_methodPtr)(Unsafe.As<object?, TTarget>(ref _referenceTarget), arg1, arg2, arg3, arg4, arg5);
        else if (IsValueType)
            ((delegate* managed<ref TTarget, T1, T2, T3, T4, T5, void>)_methodPtr)(ref Unsafe.AsRef<TTarget>(_targetPointer), arg1, arg2, arg3, arg4, arg5);
        else
            ((delegate* managed<T1, T2, T3, T4, T5, void>)_methodPtr)(arg1, arg2, arg3, arg4, arg5);
    }

    #endregion
    
    #region Auxiliary methods
    
    public TDelegate ToDelegate<TDelegate>()
        where TDelegate : Delegate
    {
        ThrowIfDisposed();
        if (_isStatic)
        {
            return (TDelegate)Delegate.CreateDelegate(typeof(TDelegate), _method);
        }
        else
        {
            if (typeof(TTarget).IsByRefLike)
                throw new ArgumentException("The target type is a by-ref-like type and cannot be converted to a delegate.");
            
#if !NET9_0_OR_GREATER
            if (IsValueType)
                throw new ArgumentException("The target type is value type and cannot be converted to a delegate.");
#endif

#if NET9_0_OR_GREATER
            object? instance = IsValueType 
                ? RuntimeHelpers.Box(ref Unsafe.AsRef<byte>(_targetPointer), typeof(TTarget).TypeHandle)
                : _referenceTarget;
#else
            object? instance = _referenceTarget;
#endif
            
            if (instance is null)
                throw new InvalidOperationException("Target instance is null.");
            
            return (TDelegate)Delegate.CreateDelegate(typeof(TDelegate), instance, _method);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void ThrowIfDisposed()
    {
        if (_disposed)
            throw new ObjectDisposedException(nameof(LuminAction<TTarget, T1, T2, T3, T4, T5>));
    }
    
    #endregion
    
    #region Static Type Hash

    private static readonly int TypeHash = ComputeTypeHash();
    private static readonly int TargetTypeHash = TargetTypeHandle.GetHashCode();
    private static readonly RuntimeTypeHandle TargetTypeHandle = typeof(TTarget).TypeHandle;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static int ComputeTypeHash()
    {
        unchecked
        {
            int h = (int)2166136261;
    
            h = (h * 16777619) ^ typeof(T1).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T2).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T3).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T4).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T5).TypeHandle.GetHashCode();
            return h;
        }
    }

    #endregion

    #region Method Caching

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static MethodCache GetCachedMethod(scoped in RuntimeTypeHandle type, string methodName, int nameHash = 0)
    {
        nameHash = nameHash is 0 ? StringComparer.Ordinal.GetHashCode(methodName) : nameHash;
        int key = type.Equals(TargetTypeHandle)
                      ? TypeHash ^ nameHash ^ TargetTypeHash
                      : TypeHash ^ nameHash ^ type.GetHashCode();

        if (!Methods.TryGetValue(key, out var result))
        {
            const BindingFlags flags = BindingFlags.Public | BindingFlags.NonPublic |
                                       BindingFlags.Instance | BindingFlags.Static;
    
            Type[] paramTypes = [ typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5) ];

#if NET8_0_OR_GREATER
            var method = Type.GetTypeFromHandle(type)!.GetMethod(methodName, flags, paramTypes)
                         ?? throw new MissingMethodException($"Method {methodName} not found on {Type.GetTypeFromHandle(type)!}");
#else
            var method = Type.GetTypeFromHandle(type)!.GetMethod(methodName, flags, null, paramTypes, null)
                         ?? throw new MissingMethodException($"Method {methodName} not found on {Type.GetTypeFromHandle(type)!}");
#endif
            result = new MethodCache(method.IsStatic, method.MethodHandle.GetFunctionPointer(), method);

            Methods.TryAdd(key, result);
        }

        return result;
    }
    
    #endregion
}

public unsafe struct LuminAction<
#if NET8_0_OR_GREATER
[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)]
#endif
TTarget, T1, T2, T3, T4, T5, T6> : IDisposable, ICloneable, ISerializable, IEquatable<LuminAction<TTarget, T1, T2, T3, T4, T5, T6>>
#if NET9_0_OR_GREATER
    where TTarget : allows ref struct
    where T1 : allows ref struct
    where T2 : allows ref struct
    where T3 : allows ref struct
    where T4 : allows ref struct
    where T5 : allows ref struct
    where T6 : allows ref struct
#endif
{
    private void* _targetPointer; 
    private object? _referenceTarget; 
    private readonly IntPtr _methodPtr;
    private readonly bool _isStatic;
    private readonly MethodInfo _method; 
    private bool _disposed;

    private static readonly bool IsValueType = typeof(TTarget).IsValueType;
    
    public TTarget? Target
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            ThrowIfDisposed();
            
            if (_isStatic)
                return default;
            
            if (IsValueType)
                return Unsafe.AsRef<TTarget?>(_targetPointer);
            
            var target = _referenceTarget;
            return Unsafe.As<object?, TTarget?>(ref target);
        }
    }
    
    public MethodInfo Method => _method;

    #region Constructors
    
    private LuminAction(MethodCache method)
    {
        _method = method.MethodBase ?? throw new ArgumentNullException(nameof(method));
        _isStatic = method.IsStatic;
        _methodPtr = method.MethodPtr;


        if (!_isStatic)
            throw new ArgumentException("methods are not static!", method.MethodBase.Name);

        _referenceTarget = null;
        _targetPointer = null;
    }
    
    private LuminAction(scoped ref TTarget? target, MethodCache method)
    {
        _method = method.MethodBase ?? throw new ArgumentNullException(nameof(method));
        _isStatic = method.IsStatic;
        _methodPtr = method.MethodPtr;
        _targetPointer = null;        
        if (!_isStatic)
        {
            if (IsValueType)
            {
#if NET8_0_OR_GREATER
                if (Unsafe.IsNullRef(ref target))
                    throw new ArgumentException("Target value instance cannot be null.", nameof(target));
#endif

#if NET8_0_OR_GREATER
                _targetPointer = NativeMemory.Alloc((nuint)Unsafe.SizeOf<TTarget>());
#else
                _targetPointer = Marshal.AllocHGlobal(Unsafe.SizeOf<TTarget>()).ToPointer();
#endif
                Unsafe.CopyBlock(
                    _targetPointer,
                    Unsafe.AsPointer(ref target),
                    (uint)Unsafe.SizeOf<TTarget>()
                );
            }
            else
            {
                // 引用类型：固定对象并获取指针
                if (target is null)
                    throw new ArgumentException("Target instance object is null.", nameof(target));
                
                _referenceTarget = Unsafe.As<TTarget, object?>(ref target);
                
            }
        }
        else
        {
            _referenceTarget = null;
        }
    }
    
    private LuminAction(Delegate @delegate)
    {
        _method = @delegate.Method ?? throw new ArgumentNullException(nameof(@delegate.Method));
        _isStatic = @delegate.Method.IsStatic;
        _methodPtr = @delegate.Method.MethodHandle.GetFunctionPointer();
        _targetPointer = null;

        var target = @delegate.Target;
        if (!_isStatic)
        {
            if (target is not TTarget)
                throw new ArgumentException("Target instance object is not type.", typeof(TTarget).Name);
                
            if (IsValueType)
            {
#if NET8_0_OR_GREATER
                if (Unsafe.IsNullRef(ref target))
                    throw new ArgumentException("Target value instance cannot be null.", nameof(target));
#endif
                // 从Delegate创建，不可能是refLike
                var unboxedTarget = Unsafe.AsRef<TTarget>(Unsafe.AsPointer(ref target));
                
#if NET8_0_OR_GREATER
                _targetPointer = NativeMemory.Alloc((nuint)Unsafe.SizeOf<TTarget>());
#else
                _targetPointer = Marshal.AllocHGlobal(Unsafe.SizeOf<TTarget>()).ToPointer();
#endif
                Unsafe.CopyBlock(
                    _targetPointer,
                    Unsafe.AsPointer(ref unboxedTarget),
                    (uint)Unsafe.SizeOf<TTarget>()
                );
            }
            else
            {
                // 引用类型：固定对象并获取指针
                if (target is null)
                    throw new ArgumentException("Target instance object is null.", nameof(target));
                
                _referenceTarget = target;
            }
        }
        else
        {
            _referenceTarget = null;
        }
    }

    #endregion
    
    #region Create Factory

    /// <summary>
    /// 创建Lumin委托
    /// </summary>
    /// <param name="target">委托绑定的实例</param>
    /// <param name="methodName">委托绑定的方法名</param>
    /// <param name="methodNameHash">方法名哈希值（可选）</param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3, T4, T5, T6> Create(scoped ref TTarget? target, string methodName, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        
        var method = GetCachedMethod(IsValueType
                ? TargetTypeHandle
                : Unsafe.As<TTarget, object?>(ref target!)?.GetType().TypeHandle ?? TargetTypeHandle,
            methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        return new LuminAction<TTarget, T1, T2, T3, T4, T5, T6>(ref target, method);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3, T4, T5, T6> Create(scoped ref TTarget? target, string methodName, Type targetType, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(targetType.TypeHandle, methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        return new LuminAction<TTarget, T1, T2, T3, T4, T5, T6>(ref target, method);
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3, T4, T5, T6> Create(scoped ref TTarget? target, ReadOnlySpan<char> methodName, int methodNameHash = 0) =>
        Create(ref target, methodName.ToString(), methodNameHash);
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3, T4, T5, T6> Create(scoped ref TTarget? target, ReadOnlySpan<char> methodName, Type targetType, int methodNameHash = 0) =>
        Create(ref target, methodName.ToString(), targetType, methodNameHash);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3, T4, T5, T6> Create(Delegate @delegate) => 
        new LuminAction<TTarget, T1, T2, T3, T4, T5, T6>(@delegate);
    
    /// <summary>
    /// 创建绑定静态方法的Lumin委托
    /// </summary>
    /// <param name="methodName">委托绑定的方法名</param>
    /// <param name="methodNameHash">方法名哈希值（可选）</param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3, T4, T5, T6> Create(string methodName, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(TargetTypeHandle, methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        if (!method.IsStatic)
            throw new ArgumentException("Method is not static, please pass in instance as parameter.", nameof(methodName));
        
        return new LuminAction<TTarget, T1, T2, T3, T4, T5, T6>(method);
    }

    #endregion
    
    #region Interface Implementation

    public void Dispose()
    {
        if (_disposed)
            return;
        
        if (IsValueType && !_isStatic && _targetPointer != null)
        {
#if NET8_0_OR_GREATER
            NativeMemory.Free(_targetPointer);
#else
            Marshal.FreeHGlobal(new IntPtr(_targetPointer));
#endif
        }
        
        _targetPointer = null;
        _referenceTarget = null;

        _disposed = true;
    }
    
    public object Clone()
    {
        ThrowIfDisposed();
        var target = _referenceTarget;
        if (target is null)
            throw new NullReferenceException("Target instance cannot be null.");
                
        return new LuminAction<TTarget, T1, T2, T3, T4, T5, T6>(ref Unsafe.As<object?, TTarget>(ref target)!, new MethodCache(_isStatic, _methodPtr, _method));
    }

    public void GetObjectData(SerializationInfo info, StreamingContext context)
    {
        throw new NotSupportedException();
    }
    
    public override bool Equals(object? obj)
    {
        return obj is LuminAction<TTarget, T1, T2, T3, T4, T5, T6> other && Equals(other);
    }

    public bool Equals(LuminAction<TTarget, T1, T2, T3, T4, T5, T6> other)
    {
        ThrowIfDisposed();
        return _methodPtr == other._methodPtr &&
               _isStatic == other._isStatic &&
               _targetPointer == other._targetPointer;
    }

    public override int GetHashCode()
    {
        ThrowIfDisposed();
        unchecked
        {
            int hash = 17;
            hash = hash * 31 + _methodPtr.GetHashCode();
            hash = hash * 31 + _isStatic.GetHashCode();
            hash = hash * 31 + ((IntPtr)_targetPointer).GetHashCode();
            return hash;
        }
    }

    #endregion
    
    #region Implicit
    
    public static implicit operator LuminAction<TTarget, T1, T2, T3, T4, T5, T6>(in Delegate action) 
        => Create(action);

    // Action 类型的隐式转换
    public static implicit operator LuminAction<TTarget, T1, T2, T3, T4, T5, T6>(Action<T1, T2, T3, T4, T5, T6> action) => 
        Create(action);
    
    #endregion

    #region Invoke

    /// <summary>
    /// 使用反射动态调用方法
    /// 慎用，开销较大
    /// </summary>
    /// <param name="args">方法参数数组</param>
    /// <returns>方法返回值</returns>
    public object? DynamicInvoke(params object?[] args)
    {
        ThrowIfDisposed();
        
        if (_isStatic)
        {
            return _method.Invoke(null, args);
        }
        else
        {
            if (typeof(TTarget).IsByRefLike)
                throw new ArgumentException(
                    "The target type is a by-ref-like type and cannot be converted to a delegate.");

#if !NET9_0_OR_GREATER
            if (IsValueType)
                throw new ArgumentException("The target type is value type and cannot dynamic invoke.");
#endif

#if NET9_0_OR_GREATER
            object? instance = IsValueType
                ? RuntimeHelpers.Box(ref Unsafe.AsRef<byte>(_targetPointer), typeof(TTarget).TypeHandle)
                : _referenceTarget;
#else
            object? instance = _referenceTarget;
#endif

            if (instance is null)
                throw new InvalidOperationException("Target instance is null.");

            return _method.Invoke(instance, args);
        }
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6)
    {
        ThrowIfDisposed();
 
        if (!_isStatic && !IsValueType)
            ((delegate* managed<TTarget, T1, T2, T3, T4, T5, T6, void>)_methodPtr)(Unsafe.As<object?, TTarget>(ref _referenceTarget), arg1, arg2, arg3, arg4, arg5, arg6);
        else if (IsValueType)
            ((delegate* managed<ref TTarget, T1, T2, T3, T4, T5, T6, void>)_methodPtr)(ref Unsafe.AsRef<TTarget>(_targetPointer), arg1, arg2, arg3, arg4, arg5, arg6);
        else
            ((delegate* managed<T1, T2, T3, T4, T5, T6, void>)_methodPtr)(arg1, arg2, arg3, arg4, arg5, arg6);
    }

    #endregion
    
    #region Auxiliary methods
    
    public TDelegate ToDelegate<TDelegate>()
        where TDelegate : Delegate
    {
        ThrowIfDisposed();
        if (_isStatic)
        {
            return (TDelegate)Delegate.CreateDelegate(typeof(TDelegate), _method);
        }
        else
        {
            if (typeof(TTarget).IsByRefLike)
                throw new ArgumentException("The target type is a by-ref-like type and cannot be converted to a delegate.");
            
#if !NET9_0_OR_GREATER
            if (IsValueType)
                throw new ArgumentException("The target type is value type and cannot be converted to a delegate.");
#endif

#if NET9_0_OR_GREATER
            object? instance = IsValueType 
                ? RuntimeHelpers.Box(ref Unsafe.AsRef<byte>(_targetPointer), typeof(TTarget).TypeHandle)
                : _referenceTarget;
#else
            object? instance = _referenceTarget;
#endif
            
            if (instance is null)
                throw new InvalidOperationException("Target instance is null.");
            
            return (TDelegate)Delegate.CreateDelegate(typeof(TDelegate), instance, _method);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void ThrowIfDisposed()
    {
        if (_disposed)
            throw new ObjectDisposedException(nameof(LuminAction<TTarget, T1, T2, T3, T4, T5, T6>));
    }
    
    #endregion
    
    #region Static Type Hash

    private static readonly int TypeHash = ComputeTypeHash();
    private static readonly int TargetTypeHash = TargetTypeHandle.GetHashCode();
    private static readonly RuntimeTypeHandle TargetTypeHandle = typeof(TTarget).TypeHandle;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static int ComputeTypeHash()
    {
        unchecked
        {
            int h = (int)2166136261;
    
            h = (h * 16777619) ^ typeof(T1).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T2).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T3).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T4).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T5).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T6).TypeHandle.GetHashCode();
            return h;
        }
    }

    #endregion

    #region Method Caching

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static MethodCache GetCachedMethod(scoped in RuntimeTypeHandle type, string methodName, int nameHash = 0)
    {
        nameHash = nameHash is 0 ? StringComparer.Ordinal.GetHashCode(methodName) : nameHash;
        int key = type.Equals(TargetTypeHandle)
                      ? TypeHash ^ nameHash ^ TargetTypeHash
                      : TypeHash ^ nameHash ^ type.GetHashCode();

        if (!Methods.TryGetValue(key, out var result))
        {
            const BindingFlags flags = BindingFlags.Public | BindingFlags.NonPublic |
                                       BindingFlags.Instance | BindingFlags.Static;
    
            Type[] paramTypes = [ typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6) ];

#if NET8_0_OR_GREATER
            var method = Type.GetTypeFromHandle(type)!.GetMethod(methodName, flags, paramTypes)
                         ?? throw new MissingMethodException($"Method {methodName} not found on {Type.GetTypeFromHandle(type)!}");
#else
            var method = Type.GetTypeFromHandle(type)!.GetMethod(methodName, flags, null, paramTypes, null)
                         ?? throw new MissingMethodException($"Method {methodName} not found on {Type.GetTypeFromHandle(type)!}");
#endif
            result = new MethodCache(method.IsStatic, method.MethodHandle.GetFunctionPointer(), method);

            Methods.TryAdd(key, result);
        }

        return result;
    }
    
    #endregion
}

public unsafe struct LuminAction<
#if NET8_0_OR_GREATER
[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)]
#endif
TTarget, T1, T2, T3, T4, T5, T6, T7> : IDisposable, ICloneable, ISerializable, IEquatable<LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7>>
#if NET9_0_OR_GREATER
    where TTarget : allows ref struct
    where T1 : allows ref struct
    where T2 : allows ref struct
    where T3 : allows ref struct
    where T4 : allows ref struct
    where T5 : allows ref struct
    where T6 : allows ref struct
    where T7 : allows ref struct
#endif
{
    private void* _targetPointer; 
    private object? _referenceTarget; 
    private readonly IntPtr _methodPtr;
    private readonly bool _isStatic;
    private readonly MethodInfo _method; 
    private bool _disposed;

    private static readonly bool IsValueType = typeof(TTarget).IsValueType;
    
    public TTarget? Target
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            ThrowIfDisposed();
            
            if (_isStatic)
                return default;
            
            if (IsValueType)
                return Unsafe.AsRef<TTarget?>(_targetPointer);
            
            var target = _referenceTarget;
            return Unsafe.As<object?, TTarget?>(ref target);
        }
    }
    
    public MethodInfo Method => _method;

    #region Constructors
    
    private LuminAction(MethodCache method)
    {
        _method = method.MethodBase ?? throw new ArgumentNullException(nameof(method));
        _isStatic = method.IsStatic;
        _methodPtr = method.MethodPtr;


        if (!_isStatic)
            throw new ArgumentException("methods are not static!", method.MethodBase.Name);

        _referenceTarget = null;
        _targetPointer = null;
    }
    
    private LuminAction(scoped ref TTarget? target, MethodCache method)
    {
        _method = method.MethodBase ?? throw new ArgumentNullException(nameof(method));
        _isStatic = method.IsStatic;
        _methodPtr = method.MethodPtr;
        _targetPointer = null;        
        if (!_isStatic)
        {
            if (IsValueType)
            {
#if NET8_0_OR_GREATER
                if (Unsafe.IsNullRef(ref target))
                    throw new ArgumentException("Target value instance cannot be null.", nameof(target));
#endif

#if NET8_0_OR_GREATER
                _targetPointer = NativeMemory.Alloc((nuint)Unsafe.SizeOf<TTarget>());
#else
                _targetPointer = Marshal.AllocHGlobal(Unsafe.SizeOf<TTarget>()).ToPointer();
#endif
                Unsafe.CopyBlock(
                    _targetPointer,
                    Unsafe.AsPointer(ref target),
                    (uint)Unsafe.SizeOf<TTarget>()
                );
            }
            else
            {
                // 引用类型：固定对象并获取指针
                if (target is null)
                    throw new ArgumentException("Target instance object is null.", nameof(target));
                
                _referenceTarget = Unsafe.As<TTarget, object?>(ref target);
                
            }
        }
        else
        {
            _referenceTarget = null;
        }
    }
    
    private LuminAction(Delegate @delegate)
    {
        _method = @delegate.Method ?? throw new ArgumentNullException(nameof(@delegate.Method));
        _isStatic = @delegate.Method.IsStatic;
        _methodPtr = @delegate.Method.MethodHandle.GetFunctionPointer();
        _targetPointer = null;

        var target = @delegate.Target;
        if (!_isStatic)
        {
            if (target is not TTarget)
                throw new ArgumentException("Target instance object is not type.", typeof(TTarget).Name);
                
            if (IsValueType)
            {
#if NET8_0_OR_GREATER
                if (Unsafe.IsNullRef(ref target))
                    throw new ArgumentException("Target value instance cannot be null.", nameof(target));
#endif
                // 从Delegate创建，不可能是refLike
                var unboxedTarget = Unsafe.AsRef<TTarget>(Unsafe.AsPointer(ref target));
                
#if NET8_0_OR_GREATER
                _targetPointer = NativeMemory.Alloc((nuint)Unsafe.SizeOf<TTarget>());
#else
                _targetPointer = Marshal.AllocHGlobal(Unsafe.SizeOf<TTarget>()).ToPointer();
#endif
                Unsafe.CopyBlock(
                    _targetPointer,
                    Unsafe.AsPointer(ref unboxedTarget),
                    (uint)Unsafe.SizeOf<TTarget>()
                );
            }
            else
            {
                // 引用类型：固定对象并获取指针
                if (target is null)
                    throw new ArgumentException("Target instance object is null.", nameof(target));
                
                _referenceTarget = target;
            }
        }
        else
        {
            _referenceTarget = null;
        }
    }

    #endregion
    
    #region Create Factory

    /// <summary>
    /// 创建Lumin委托
    /// </summary>
    /// <param name="target">委托绑定的实例</param>
    /// <param name="methodName">委托绑定的方法名</param>
    /// <param name="methodNameHash">方法名哈希值（可选）</param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7> Create(scoped ref TTarget? target, string methodName, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        
        var method = GetCachedMethod(IsValueType
                ? TargetTypeHandle
                : Unsafe.As<TTarget, object?>(ref target!)?.GetType().TypeHandle ?? TargetTypeHandle,
            methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        return new LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7>(ref target, method);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7> Create(scoped ref TTarget? target, string methodName, Type targetType, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(targetType.TypeHandle, methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        return new LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7>(ref target, method);
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7> Create(scoped ref TTarget? target, ReadOnlySpan<char> methodName, int methodNameHash = 0) =>
        Create(ref target, methodName.ToString(), methodNameHash);
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7> Create(scoped ref TTarget? target, ReadOnlySpan<char> methodName, Type targetType, int methodNameHash = 0) =>
        Create(ref target, methodName.ToString(), targetType, methodNameHash);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7> Create(Delegate @delegate) => 
        new LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7>(@delegate);
    
    /// <summary>
    /// 创建绑定静态方法的Lumin委托
    /// </summary>
    /// <param name="methodName">委托绑定的方法名</param>
    /// <param name="methodNameHash">方法名哈希值（可选）</param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7> Create(string methodName, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(TargetTypeHandle, methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        if (!method.IsStatic)
            throw new ArgumentException("Method is not static, please pass in instance as parameter.", nameof(methodName));
        
        return new LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7>(method);
    }

    #endregion
    
    #region Interface Implementation

    public void Dispose()
    {
        if (_disposed)
            return;
        
        if (IsValueType && !_isStatic && _targetPointer != null)
        {
#if NET8_0_OR_GREATER
            NativeMemory.Free(_targetPointer);
#else
            Marshal.FreeHGlobal(new IntPtr(_targetPointer));
#endif
        }
        
        _targetPointer = null;
        _referenceTarget = null;

        _disposed = true;
    }
    
    public object Clone()
    {
        ThrowIfDisposed();
        var target = _referenceTarget;
        if (target is null)
            throw new NullReferenceException("Target instance cannot be null.");
                
        return new LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7>(ref Unsafe.As<object?, TTarget>(ref target)!, new MethodCache(_isStatic, _methodPtr, _method));
    }

    public void GetObjectData(SerializationInfo info, StreamingContext context)
    {
        throw new NotSupportedException();
    }
    
    public override bool Equals(object? obj)
    {
        return obj is LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7> other && Equals(other);
    }

    public bool Equals(LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7> other)
    {
        ThrowIfDisposed();
        return _methodPtr == other._methodPtr &&
               _isStatic == other._isStatic &&
               _targetPointer == other._targetPointer;
    }

    public override int GetHashCode()
    {
        ThrowIfDisposed();
        unchecked
        {
            int hash = 17;
            hash = hash * 31 + _methodPtr.GetHashCode();
            hash = hash * 31 + _isStatic.GetHashCode();
            hash = hash * 31 + ((IntPtr)_targetPointer).GetHashCode();
            return hash;
        }
    }

    #endregion
    
    #region Implicit
    
    public static implicit operator LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7>(in Delegate action) 
        => Create(action);

    // Action 类型的隐式转换
    public static implicit operator LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7>(Action<T1, T2, T3, T4, T5, T6, T7> action) => 
        Create(action);
    
    #endregion

    #region Invoke

    /// <summary>
    /// 使用反射动态调用方法
    /// 慎用，开销较大
    /// </summary>
    /// <param name="args">方法参数数组</param>
    /// <returns>方法返回值</returns>
    public object? DynamicInvoke(params object?[] args)
    {
        ThrowIfDisposed();
        
        if (_isStatic)
        {
            return _method.Invoke(null, args);
        }
        else
        {
            if (typeof(TTarget).IsByRefLike)
                throw new ArgumentException(
                    "The target type is a by-ref-like type and cannot be converted to a delegate.");

#if !NET9_0_OR_GREATER
            if (IsValueType)
                throw new ArgumentException("The target type is value type and cannot dynamic invoke.");
#endif

#if NET9_0_OR_GREATER
            object? instance = IsValueType
                ? RuntimeHelpers.Box(ref Unsafe.AsRef<byte>(_targetPointer), typeof(TTarget).TypeHandle)
                : _referenceTarget;
#else
            object? instance = _referenceTarget;
#endif

            if (instance is null)
                throw new InvalidOperationException("Target instance is null.");

            return _method.Invoke(instance, args);
        }
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7)
    {
        ThrowIfDisposed();
 
        if (!_isStatic && !IsValueType)
            ((delegate* managed<TTarget, T1, T2, T3, T4, T5, T6, T7, void>)_methodPtr)(Unsafe.As<object?, TTarget>(ref _referenceTarget), arg1, arg2, arg3, arg4, arg5, arg6, arg7);
        else if (IsValueType)
            ((delegate* managed<ref TTarget, T1, T2, T3, T4, T5, T6, T7, void>)_methodPtr)(ref Unsafe.AsRef<TTarget>(_targetPointer), arg1, arg2, arg3, arg4, arg5, arg6, arg7);
        else
            ((delegate* managed<T1, T2, T3, T4, T5, T6, T7, void>)_methodPtr)(arg1, arg2, arg3, arg4, arg5, arg6, arg7);
    }

    #endregion
    
    #region Auxiliary methods
    
    public TDelegate ToDelegate<TDelegate>()
        where TDelegate : Delegate
    {
        ThrowIfDisposed();
        if (_isStatic)
        {
            return (TDelegate)Delegate.CreateDelegate(typeof(TDelegate), _method);
        }
        else
        {
            if (typeof(TTarget).IsByRefLike)
                throw new ArgumentException("The target type is a by-ref-like type and cannot be converted to a delegate.");
            
#if !NET9_0_OR_GREATER
            if (IsValueType)
                throw new ArgumentException("The target type is value type and cannot be converted to a delegate.");
#endif

#if NET9_0_OR_GREATER
            object? instance = IsValueType 
                ? RuntimeHelpers.Box(ref Unsafe.AsRef<byte>(_targetPointer), typeof(TTarget).TypeHandle)
                : _referenceTarget;
#else
            object? instance = _referenceTarget;
#endif
            
            if (instance is null)
                throw new InvalidOperationException("Target instance is null.");
            
            return (TDelegate)Delegate.CreateDelegate(typeof(TDelegate), instance, _method);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void ThrowIfDisposed()
    {
        if (_disposed)
            throw new ObjectDisposedException(nameof(LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7>));
    }
    
    #endregion
    
    #region Static Type Hash

    private static readonly int TypeHash = ComputeTypeHash();
    private static readonly int TargetTypeHash = TargetTypeHandle.GetHashCode();
    private static readonly RuntimeTypeHandle TargetTypeHandle = typeof(TTarget).TypeHandle;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static int ComputeTypeHash()
    {
        unchecked
        {
            int h = (int)2166136261;
    
            h = (h * 16777619) ^ typeof(T1).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T2).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T3).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T4).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T5).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T6).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T7).TypeHandle.GetHashCode();
            return h;
        }
    }

    #endregion

    #region Method Caching

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static MethodCache GetCachedMethod(scoped in RuntimeTypeHandle type, string methodName, int nameHash = 0)
    {
        nameHash = nameHash is 0 ? StringComparer.Ordinal.GetHashCode(methodName) : nameHash;
        int key = type.Equals(TargetTypeHandle)
                      ? TypeHash ^ nameHash ^ TargetTypeHash
                      : TypeHash ^ nameHash ^ type.GetHashCode();

        if (!Methods.TryGetValue(key, out var result))
        {
            const BindingFlags flags = BindingFlags.Public | BindingFlags.NonPublic |
                                       BindingFlags.Instance | BindingFlags.Static;
    
            Type[] paramTypes = [ typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7) ];

#if NET8_0_OR_GREATER
            var method = Type.GetTypeFromHandle(type)!.GetMethod(methodName, flags, paramTypes)
                         ?? throw new MissingMethodException($"Method {methodName} not found on {Type.GetTypeFromHandle(type)!}");
#else
            var method = Type.GetTypeFromHandle(type)!.GetMethod(methodName, flags, null, paramTypes, null)
                         ?? throw new MissingMethodException($"Method {methodName} not found on {Type.GetTypeFromHandle(type)!}");
#endif
            result = new MethodCache(method.IsStatic, method.MethodHandle.GetFunctionPointer(), method);

            Methods.TryAdd(key, result);
        }

        return result;
    }
    
    #endregion
}

public unsafe struct LuminAction<
#if NET8_0_OR_GREATER
[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)]
#endif
TTarget, T1, T2, T3, T4, T5, T6, T7, T8> : IDisposable, ICloneable, ISerializable, IEquatable<LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8>>
#if NET9_0_OR_GREATER
    where TTarget : allows ref struct
    where T1 : allows ref struct
    where T2 : allows ref struct
    where T3 : allows ref struct
    where T4 : allows ref struct
    where T5 : allows ref struct
    where T6 : allows ref struct
    where T7 : allows ref struct
    where T8 : allows ref struct
#endif
{
    private void* _targetPointer; 
    private object? _referenceTarget; 
    private readonly IntPtr _methodPtr;
    private readonly bool _isStatic;
    private readonly MethodInfo _method; 
    private bool _disposed;

    private static readonly bool IsValueType = typeof(TTarget).IsValueType;
    
    public TTarget? Target
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            ThrowIfDisposed();
            
            if (_isStatic)
                return default;
            
            if (IsValueType)
                return Unsafe.AsRef<TTarget?>(_targetPointer);
            
            var target = _referenceTarget;
            return Unsafe.As<object?, TTarget?>(ref target);
        }
    }
    
    public MethodInfo Method => _method;

    #region Constructors
    
    private LuminAction(MethodCache method)
    {
        _method = method.MethodBase ?? throw new ArgumentNullException(nameof(method));
        _isStatic = method.IsStatic;
        _methodPtr = method.MethodPtr;


        if (!_isStatic)
            throw new ArgumentException("methods are not static!", method.MethodBase.Name);

        _referenceTarget = null;
        _targetPointer = null;
    }
    
    private LuminAction(scoped ref TTarget? target, MethodCache method)
    {
        _method = method.MethodBase ?? throw new ArgumentNullException(nameof(method));
        _isStatic = method.IsStatic;
        _methodPtr = method.MethodPtr;
        _targetPointer = null;        
        if (!_isStatic)
        {
            if (IsValueType)
            {
#if NET8_0_OR_GREATER
                if (Unsafe.IsNullRef(ref target))
                    throw new ArgumentException("Target value instance cannot be null.", nameof(target));
#endif

#if NET8_0_OR_GREATER
                _targetPointer = NativeMemory.Alloc((nuint)Unsafe.SizeOf<TTarget>());
#else
                _targetPointer = Marshal.AllocHGlobal(Unsafe.SizeOf<TTarget>()).ToPointer();
#endif
                Unsafe.CopyBlock(
                    _targetPointer,
                    Unsafe.AsPointer(ref target),
                    (uint)Unsafe.SizeOf<TTarget>()
                );
            }
            else
            {
                // 引用类型：固定对象并获取指针
                if (target is null)
                    throw new ArgumentException("Target instance object is null.", nameof(target));
                
                _referenceTarget = Unsafe.As<TTarget, object?>(ref target);
                
            }
        }
        else
        {
            _referenceTarget = null;
        }
    }
    
    private LuminAction(Delegate @delegate)
    {
        _method = @delegate.Method ?? throw new ArgumentNullException(nameof(@delegate.Method));
        _isStatic = @delegate.Method.IsStatic;
        _methodPtr = @delegate.Method.MethodHandle.GetFunctionPointer();
        _targetPointer = null;

        var target = @delegate.Target;
        if (!_isStatic)
        {
            if (target is not TTarget)
                throw new ArgumentException("Target instance object is not type.", typeof(TTarget).Name);
                
            if (IsValueType)
            {
#if NET8_0_OR_GREATER
                if (Unsafe.IsNullRef(ref target))
                    throw new ArgumentException("Target value instance cannot be null.", nameof(target));
#endif
                // 从Delegate创建，不可能是refLike
                var unboxedTarget = Unsafe.AsRef<TTarget>(Unsafe.AsPointer(ref target));
                
#if NET8_0_OR_GREATER
                _targetPointer = NativeMemory.Alloc((nuint)Unsafe.SizeOf<TTarget>());
#else
                _targetPointer = Marshal.AllocHGlobal(Unsafe.SizeOf<TTarget>()).ToPointer();
#endif
                Unsafe.CopyBlock(
                    _targetPointer,
                    Unsafe.AsPointer(ref unboxedTarget),
                    (uint)Unsafe.SizeOf<TTarget>()
                );
            }
            else
            {
                // 引用类型：固定对象并获取指针
                if (target is null)
                    throw new ArgumentException("Target instance object is null.", nameof(target));
                
                _referenceTarget = target;
            }
        }
        else
        {
            _referenceTarget = null;
        }
    }

    #endregion
    
    #region Create Factory

    /// <summary>
    /// 创建Lumin委托
    /// </summary>
    /// <param name="target">委托绑定的实例</param>
    /// <param name="methodName">委托绑定的方法名</param>
    /// <param name="methodNameHash">方法名哈希值（可选）</param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8> Create(scoped ref TTarget? target, string methodName, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        
        var method = GetCachedMethod(IsValueType
                ? TargetTypeHandle
                : Unsafe.As<TTarget, object?>(ref target!)?.GetType().TypeHandle ?? TargetTypeHandle,
            methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        return new LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8>(ref target, method);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8> Create(scoped ref TTarget? target, string methodName, Type targetType, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(targetType.TypeHandle, methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        return new LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8>(ref target, method);
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8> Create(scoped ref TTarget? target, ReadOnlySpan<char> methodName, int methodNameHash = 0) =>
        Create(ref target, methodName.ToString(), methodNameHash);
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8> Create(scoped ref TTarget? target, ReadOnlySpan<char> methodName, Type targetType, int methodNameHash = 0) =>
        Create(ref target, methodName.ToString(), targetType, methodNameHash);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8> Create(Delegate @delegate) => 
        new LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8>(@delegate);
    
    /// <summary>
    /// 创建绑定静态方法的Lumin委托
    /// </summary>
    /// <param name="methodName">委托绑定的方法名</param>
    /// <param name="methodNameHash">方法名哈希值（可选）</param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8> Create(string methodName, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(TargetTypeHandle, methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        if (!method.IsStatic)
            throw new ArgumentException("Method is not static, please pass in instance as parameter.", nameof(methodName));
        
        return new LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8>(method);
    }

    #endregion
    
    #region Interface Implementation

    public void Dispose()
    {
        if (_disposed)
            return;
        
        if (IsValueType && !_isStatic && _targetPointer != null)
        {
#if NET8_0_OR_GREATER
            NativeMemory.Free(_targetPointer);
#else
            Marshal.FreeHGlobal(new IntPtr(_targetPointer));
#endif
        }
        
        _targetPointer = null;
        _referenceTarget = null;

        _disposed = true;
    }
    
    public object Clone()
    {
        ThrowIfDisposed();
        var target = _referenceTarget;
        if (target is null)
            throw new NullReferenceException("Target instance cannot be null.");
                
        return new LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8>(ref Unsafe.As<object?, TTarget>(ref target)!, new MethodCache(_isStatic, _methodPtr, _method));
    }

    public void GetObjectData(SerializationInfo info, StreamingContext context)
    {
        throw new NotSupportedException();
    }
    
    public override bool Equals(object? obj)
    {
        return obj is LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8> other && Equals(other);
    }

    public bool Equals(LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8> other)
    {
        ThrowIfDisposed();
        return _methodPtr == other._methodPtr &&
               _isStatic == other._isStatic &&
               _targetPointer == other._targetPointer;
    }

    public override int GetHashCode()
    {
        ThrowIfDisposed();
        unchecked
        {
            int hash = 17;
            hash = hash * 31 + _methodPtr.GetHashCode();
            hash = hash * 31 + _isStatic.GetHashCode();
            hash = hash * 31 + ((IntPtr)_targetPointer).GetHashCode();
            return hash;
        }
    }

    #endregion
    
    #region Implicit
    
    public static implicit operator LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8>(in Delegate action) 
        => Create(action);

    // Action 类型的隐式转换
    public static implicit operator LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8>(Action<T1, T2, T3, T4, T5, T6, T7, T8> action) => 
        Create(action);
    
    #endregion

    #region Invoke

    /// <summary>
    /// 使用反射动态调用方法
    /// 慎用，开销较大
    /// </summary>
    /// <param name="args">方法参数数组</param>
    /// <returns>方法返回值</returns>
    public object? DynamicInvoke(params object?[] args)
    {
        ThrowIfDisposed();
        
        if (_isStatic)
        {
            return _method.Invoke(null, args);
        }
        else
        {
            if (typeof(TTarget).IsByRefLike)
                throw new ArgumentException(
                    "The target type is a by-ref-like type and cannot be converted to a delegate.");

#if !NET9_0_OR_GREATER
            if (IsValueType)
                throw new ArgumentException("The target type is value type and cannot dynamic invoke.");
#endif

#if NET9_0_OR_GREATER
            object? instance = IsValueType
                ? RuntimeHelpers.Box(ref Unsafe.AsRef<byte>(_targetPointer), typeof(TTarget).TypeHandle)
                : _referenceTarget;
#else
            object? instance = _referenceTarget;
#endif

            if (instance is null)
                throw new InvalidOperationException("Target instance is null.");

            return _method.Invoke(instance, args);
        }
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8)
    {
        ThrowIfDisposed();
 
        if (!_isStatic && !IsValueType)
            ((delegate* managed<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, void>)_methodPtr)(Unsafe.As<object?, TTarget>(ref _referenceTarget), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
        else if (IsValueType)
            ((delegate* managed<ref TTarget, T1, T2, T3, T4, T5, T6, T7, T8, void>)_methodPtr)(ref Unsafe.AsRef<TTarget>(_targetPointer), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
        else
            ((delegate* managed<T1, T2, T3, T4, T5, T6, T7, T8, void>)_methodPtr)(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
    }

    #endregion
    
    #region Auxiliary methods
    
    public TDelegate ToDelegate<TDelegate>()
        where TDelegate : Delegate
    {
        ThrowIfDisposed();
        if (_isStatic)
        {
            return (TDelegate)Delegate.CreateDelegate(typeof(TDelegate), _method);
        }
        else
        {
            if (typeof(TTarget).IsByRefLike)
                throw new ArgumentException("The target type is a by-ref-like type and cannot be converted to a delegate.");
            
#if !NET9_0_OR_GREATER
            if (IsValueType)
                throw new ArgumentException("The target type is value type and cannot be converted to a delegate.");
#endif

#if NET9_0_OR_GREATER
            object? instance = IsValueType 
                ? RuntimeHelpers.Box(ref Unsafe.AsRef<byte>(_targetPointer), typeof(TTarget).TypeHandle)
                : _referenceTarget;
#else
            object? instance = _referenceTarget;
#endif
            
            if (instance is null)
                throw new InvalidOperationException("Target instance is null.");
            
            return (TDelegate)Delegate.CreateDelegate(typeof(TDelegate), instance, _method);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void ThrowIfDisposed()
    {
        if (_disposed)
            throw new ObjectDisposedException(nameof(LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8>));
    }
    
    #endregion
    
    #region Static Type Hash

    private static readonly int TypeHash = ComputeTypeHash();
    private static readonly int TargetTypeHash = TargetTypeHandle.GetHashCode();
    private static readonly RuntimeTypeHandle TargetTypeHandle = typeof(TTarget).TypeHandle;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static int ComputeTypeHash()
    {
        unchecked
        {
            int h = (int)2166136261;
    
            h = (h * 16777619) ^ typeof(T1).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T2).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T3).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T4).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T5).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T6).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T7).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T8).TypeHandle.GetHashCode();
            return h;
        }
    }

    #endregion

    #region Method Caching

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static MethodCache GetCachedMethod(scoped in RuntimeTypeHandle type, string methodName, int nameHash = 0)
    {
        nameHash = nameHash is 0 ? StringComparer.Ordinal.GetHashCode(methodName) : nameHash;
        int key = type.Equals(TargetTypeHandle)
                      ? TypeHash ^ nameHash ^ TargetTypeHash
                      : TypeHash ^ nameHash ^ type.GetHashCode();

        if (!Methods.TryGetValue(key, out var result))
        {
            const BindingFlags flags = BindingFlags.Public | BindingFlags.NonPublic |
                                       BindingFlags.Instance | BindingFlags.Static;
    
            Type[] paramTypes = [ typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8) ];

#if NET8_0_OR_GREATER
            var method = Type.GetTypeFromHandle(type)!.GetMethod(methodName, flags, paramTypes)
                         ?? throw new MissingMethodException($"Method {methodName} not found on {Type.GetTypeFromHandle(type)!}");
#else
            var method = Type.GetTypeFromHandle(type)!.GetMethod(methodName, flags, null, paramTypes, null)
                         ?? throw new MissingMethodException($"Method {methodName} not found on {Type.GetTypeFromHandle(type)!}");
#endif
            result = new MethodCache(method.IsStatic, method.MethodHandle.GetFunctionPointer(), method);

            Methods.TryAdd(key, result);
        }

        return result;
    }
    
    #endregion
}

public unsafe struct LuminAction<
#if NET8_0_OR_GREATER
[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)]
#endif
TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9> : IDisposable, ICloneable, ISerializable, IEquatable<LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9>>
#if NET9_0_OR_GREATER
    where TTarget : allows ref struct
    where T1 : allows ref struct
    where T2 : allows ref struct
    where T3 : allows ref struct
    where T4 : allows ref struct
    where T5 : allows ref struct
    where T6 : allows ref struct
    where T7 : allows ref struct
    where T8 : allows ref struct
    where T9 : allows ref struct
#endif
{
    private void* _targetPointer; 
    private object? _referenceTarget; 
    private readonly IntPtr _methodPtr;
    private readonly bool _isStatic;
    private readonly MethodInfo _method; 
    private bool _disposed;

    private static readonly bool IsValueType = typeof(TTarget).IsValueType;
    
    public TTarget? Target
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            ThrowIfDisposed();
            
            if (_isStatic)
                return default;
            
            if (IsValueType)
                return Unsafe.AsRef<TTarget?>(_targetPointer);
            
            var target = _referenceTarget;
            return Unsafe.As<object?, TTarget?>(ref target);
        }
    }
    
    public MethodInfo Method => _method;

    #region Constructors
    
    private LuminAction(MethodCache method)
    {
        _method = method.MethodBase ?? throw new ArgumentNullException(nameof(method));
        _isStatic = method.IsStatic;
        _methodPtr = method.MethodPtr;


        if (!_isStatic)
            throw new ArgumentException("methods are not static!", method.MethodBase.Name);

        _referenceTarget = null;
        _targetPointer = null;
    }
    
    private LuminAction(scoped ref TTarget? target, MethodCache method)
    {
        _method = method.MethodBase ?? throw new ArgumentNullException(nameof(method));
        _isStatic = method.IsStatic;
        _methodPtr = method.MethodPtr;
        _targetPointer = null;        
        if (!_isStatic)
        {
            if (IsValueType)
            {
#if NET8_0_OR_GREATER
                if (Unsafe.IsNullRef(ref target))
                    throw new ArgumentException("Target value instance cannot be null.", nameof(target));
#endif

#if NET8_0_OR_GREATER
                _targetPointer = NativeMemory.Alloc((nuint)Unsafe.SizeOf<TTarget>());
#else
                _targetPointer = Marshal.AllocHGlobal(Unsafe.SizeOf<TTarget>()).ToPointer();
#endif
                Unsafe.CopyBlock(
                    _targetPointer,
                    Unsafe.AsPointer(ref target),
                    (uint)Unsafe.SizeOf<TTarget>()
                );
            }
            else
            {
                // 引用类型：固定对象并获取指针
                if (target is null)
                    throw new ArgumentException("Target instance object is null.", nameof(target));
                
                _referenceTarget = Unsafe.As<TTarget, object?>(ref target);
                
            }
        }
        else
        {
            _referenceTarget = null;
        }
    }
    
    private LuminAction(Delegate @delegate)
    {
        _method = @delegate.Method ?? throw new ArgumentNullException(nameof(@delegate.Method));
        _isStatic = @delegate.Method.IsStatic;
        _methodPtr = @delegate.Method.MethodHandle.GetFunctionPointer();
        _targetPointer = null;

        var target = @delegate.Target;
        if (!_isStatic)
        {
            if (target is not TTarget)
                throw new ArgumentException("Target instance object is not type.", typeof(TTarget).Name);
                
            if (IsValueType)
            {
#if NET8_0_OR_GREATER
                if (Unsafe.IsNullRef(ref target))
                    throw new ArgumentException("Target value instance cannot be null.", nameof(target));
#endif
                // 从Delegate创建，不可能是refLike
                var unboxedTarget = Unsafe.AsRef<TTarget>(Unsafe.AsPointer(ref target));
                
#if NET8_0_OR_GREATER
                _targetPointer = NativeMemory.Alloc((nuint)Unsafe.SizeOf<TTarget>());
#else
                _targetPointer = Marshal.AllocHGlobal(Unsafe.SizeOf<TTarget>()).ToPointer();
#endif
                Unsafe.CopyBlock(
                    _targetPointer,
                    Unsafe.AsPointer(ref unboxedTarget),
                    (uint)Unsafe.SizeOf<TTarget>()
                );
            }
            else
            {
                // 引用类型：固定对象并获取指针
                if (target is null)
                    throw new ArgumentException("Target instance object is null.", nameof(target));
                
                _referenceTarget = target;
            }
        }
        else
        {
            _referenceTarget = null;
        }
    }

    #endregion
    
    #region Create Factory

    /// <summary>
    /// 创建Lumin委托
    /// </summary>
    /// <param name="target">委托绑定的实例</param>
    /// <param name="methodName">委托绑定的方法名</param>
    /// <param name="methodNameHash">方法名哈希值（可选）</param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9> Create(scoped ref TTarget? target, string methodName, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        
        var method = GetCachedMethod(IsValueType
                ? TargetTypeHandle
                : Unsafe.As<TTarget, object?>(ref target!)?.GetType().TypeHandle ?? TargetTypeHandle,
            methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        return new LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9>(ref target, method);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9> Create(scoped ref TTarget? target, string methodName, Type targetType, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(targetType.TypeHandle, methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        return new LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9>(ref target, method);
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9> Create(scoped ref TTarget? target, ReadOnlySpan<char> methodName, int methodNameHash = 0) =>
        Create(ref target, methodName.ToString(), methodNameHash);
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9> Create(scoped ref TTarget? target, ReadOnlySpan<char> methodName, Type targetType, int methodNameHash = 0) =>
        Create(ref target, methodName.ToString(), targetType, methodNameHash);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9> Create(Delegate @delegate) => 
        new LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9>(@delegate);
    
    /// <summary>
    /// 创建绑定静态方法的Lumin委托
    /// </summary>
    /// <param name="methodName">委托绑定的方法名</param>
    /// <param name="methodNameHash">方法名哈希值（可选）</param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9> Create(string methodName, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(TargetTypeHandle, methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        if (!method.IsStatic)
            throw new ArgumentException("Method is not static, please pass in instance as parameter.", nameof(methodName));
        
        return new LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9>(method);
    }

    #endregion
    
    #region Interface Implementation

    public void Dispose()
    {
        if (_disposed)
            return;
        
        if (IsValueType && !_isStatic && _targetPointer != null)
        {
#if NET8_0_OR_GREATER
            NativeMemory.Free(_targetPointer);
#else
            Marshal.FreeHGlobal(new IntPtr(_targetPointer));
#endif
        }
        
        _targetPointer = null;
        _referenceTarget = null;

        _disposed = true;
    }
    
    public object Clone()
    {
        ThrowIfDisposed();
        var target = _referenceTarget;
        if (target is null)
            throw new NullReferenceException("Target instance cannot be null.");
                
        return new LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9>(ref Unsafe.As<object?, TTarget>(ref target)!, new MethodCache(_isStatic, _methodPtr, _method));
    }

    public void GetObjectData(SerializationInfo info, StreamingContext context)
    {
        throw new NotSupportedException();
    }
    
    public override bool Equals(object? obj)
    {
        return obj is LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9> other && Equals(other);
    }

    public bool Equals(LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9> other)
    {
        ThrowIfDisposed();
        return _methodPtr == other._methodPtr &&
               _isStatic == other._isStatic &&
               _targetPointer == other._targetPointer;
    }

    public override int GetHashCode()
    {
        ThrowIfDisposed();
        unchecked
        {
            int hash = 17;
            hash = hash * 31 + _methodPtr.GetHashCode();
            hash = hash * 31 + _isStatic.GetHashCode();
            hash = hash * 31 + ((IntPtr)_targetPointer).GetHashCode();
            return hash;
        }
    }

    #endregion
    
    #region Implicit
    
    public static implicit operator LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9>(in Delegate action) 
        => Create(action);

    // Action 类型的隐式转换
    public static implicit operator LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9>(Action<T1, T2, T3, T4, T5, T6, T7, T8, T9> action) => 
        Create(action);
    
    #endregion

    #region Invoke

    /// <summary>
    /// 使用反射动态调用方法
    /// 慎用，开销较大
    /// </summary>
    /// <param name="args">方法参数数组</param>
    /// <returns>方法返回值</returns>
    public object? DynamicInvoke(params object?[] args)
    {
        ThrowIfDisposed();
        
        if (_isStatic)
        {
            return _method.Invoke(null, args);
        }
        else
        {
            if (typeof(TTarget).IsByRefLike)
                throw new ArgumentException(
                    "The target type is a by-ref-like type and cannot be converted to a delegate.");

#if !NET9_0_OR_GREATER
            if (IsValueType)
                throw new ArgumentException("The target type is value type and cannot dynamic invoke.");
#endif

#if NET9_0_OR_GREATER
            object? instance = IsValueType
                ? RuntimeHelpers.Box(ref Unsafe.AsRef<byte>(_targetPointer), typeof(TTarget).TypeHandle)
                : _referenceTarget;
#else
            object? instance = _referenceTarget;
#endif

            if (instance is null)
                throw new InvalidOperationException("Target instance is null.");

            return _method.Invoke(instance, args);
        }
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9)
    {
        ThrowIfDisposed();
 
        if (!_isStatic && !IsValueType)
            ((delegate* managed<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, void>)_methodPtr)(Unsafe.As<object?, TTarget>(ref _referenceTarget), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
        else if (IsValueType)
            ((delegate* managed<ref TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, void>)_methodPtr)(ref Unsafe.AsRef<TTarget>(_targetPointer), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
        else
            ((delegate* managed<T1, T2, T3, T4, T5, T6, T7, T8, T9, void>)_methodPtr)(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
    }

    #endregion
    
    #region Auxiliary methods
    
    public TDelegate ToDelegate<TDelegate>()
        where TDelegate : Delegate
    {
        ThrowIfDisposed();
        if (_isStatic)
        {
            return (TDelegate)Delegate.CreateDelegate(typeof(TDelegate), _method);
        }
        else
        {
            if (typeof(TTarget).IsByRefLike)
                throw new ArgumentException("The target type is a by-ref-like type and cannot be converted to a delegate.");
            
#if !NET9_0_OR_GREATER
            if (IsValueType)
                throw new ArgumentException("The target type is value type and cannot be converted to a delegate.");
#endif

#if NET9_0_OR_GREATER
            object? instance = IsValueType 
                ? RuntimeHelpers.Box(ref Unsafe.AsRef<byte>(_targetPointer), typeof(TTarget).TypeHandle)
                : _referenceTarget;
#else
            object? instance = _referenceTarget;
#endif
            
            if (instance is null)
                throw new InvalidOperationException("Target instance is null.");
            
            return (TDelegate)Delegate.CreateDelegate(typeof(TDelegate), instance, _method);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void ThrowIfDisposed()
    {
        if (_disposed)
            throw new ObjectDisposedException(nameof(LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9>));
    }
    
    #endregion
    
    #region Static Type Hash

    private static readonly int TypeHash = ComputeTypeHash();
    private static readonly int TargetTypeHash = TargetTypeHandle.GetHashCode();
    private static readonly RuntimeTypeHandle TargetTypeHandle = typeof(TTarget).TypeHandle;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static int ComputeTypeHash()
    {
        unchecked
        {
            int h = (int)2166136261;
    
            h = (h * 16777619) ^ typeof(T1).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T2).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T3).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T4).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T5).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T6).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T7).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T8).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T9).TypeHandle.GetHashCode();
            return h;
        }
    }

    #endregion

    #region Method Caching

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static MethodCache GetCachedMethod(scoped in RuntimeTypeHandle type, string methodName, int nameHash = 0)
    {
        nameHash = nameHash is 0 ? StringComparer.Ordinal.GetHashCode(methodName) : nameHash;
        int key = type.Equals(TargetTypeHandle)
                      ? TypeHash ^ nameHash ^ TargetTypeHash
                      : TypeHash ^ nameHash ^ type.GetHashCode();

        if (!Methods.TryGetValue(key, out var result))
        {
            const BindingFlags flags = BindingFlags.Public | BindingFlags.NonPublic |
                                       BindingFlags.Instance | BindingFlags.Static;
    
            Type[] paramTypes = [ typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9) ];

#if NET8_0_OR_GREATER
            var method = Type.GetTypeFromHandle(type)!.GetMethod(methodName, flags, paramTypes)
                         ?? throw new MissingMethodException($"Method {methodName} not found on {Type.GetTypeFromHandle(type)!}");
#else
            var method = Type.GetTypeFromHandle(type)!.GetMethod(methodName, flags, null, paramTypes, null)
                         ?? throw new MissingMethodException($"Method {methodName} not found on {Type.GetTypeFromHandle(type)!}");
#endif
            result = new MethodCache(method.IsStatic, method.MethodHandle.GetFunctionPointer(), method);

            Methods.TryAdd(key, result);
        }

        return result;
    }
    
    #endregion
}

public unsafe struct LuminAction<
#if NET8_0_OR_GREATER
[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)]
#endif
TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> : IDisposable, ICloneable, ISerializable, IEquatable<LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>>
#if NET9_0_OR_GREATER
    where TTarget : allows ref struct
    where T1 : allows ref struct
    where T2 : allows ref struct
    where T3 : allows ref struct
    where T4 : allows ref struct
    where T5 : allows ref struct
    where T6 : allows ref struct
    where T7 : allows ref struct
    where T8 : allows ref struct
    where T9 : allows ref struct
    where T10 : allows ref struct
#endif
{
    private void* _targetPointer; 
    private object? _referenceTarget; 
    private readonly IntPtr _methodPtr;
    private readonly bool _isStatic;
    private readonly MethodInfo _method; 
    private bool _disposed;

    private static readonly bool IsValueType = typeof(TTarget).IsValueType;
    
    public TTarget? Target
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            ThrowIfDisposed();
            
            if (_isStatic)
                return default;
            
            if (IsValueType)
                return Unsafe.AsRef<TTarget?>(_targetPointer);
            
            var target = _referenceTarget;
            return Unsafe.As<object?, TTarget?>(ref target);
        }
    }
    
    public MethodInfo Method => _method;

    #region Constructors
    
    private LuminAction(MethodCache method)
    {
        _method = method.MethodBase ?? throw new ArgumentNullException(nameof(method));
        _isStatic = method.IsStatic;
        _methodPtr = method.MethodPtr;


        if (!_isStatic)
            throw new ArgumentException("methods are not static!", method.MethodBase.Name);

        _referenceTarget = null;
        _targetPointer = null;
    }
    
    private LuminAction(scoped ref TTarget? target, MethodCache method)
    {
        _method = method.MethodBase ?? throw new ArgumentNullException(nameof(method));
        _isStatic = method.IsStatic;
        _methodPtr = method.MethodPtr;
        _targetPointer = null;        
        if (!_isStatic)
        {
            if (IsValueType)
            {
#if NET8_0_OR_GREATER
                if (Unsafe.IsNullRef(ref target))
                    throw new ArgumentException("Target value instance cannot be null.", nameof(target));
#endif

#if NET8_0_OR_GREATER
                _targetPointer = NativeMemory.Alloc((nuint)Unsafe.SizeOf<TTarget>());
#else
                _targetPointer = Marshal.AllocHGlobal(Unsafe.SizeOf<TTarget>()).ToPointer();
#endif
                Unsafe.CopyBlock(
                    _targetPointer,
                    Unsafe.AsPointer(ref target),
                    (uint)Unsafe.SizeOf<TTarget>()
                );
            }
            else
            {
                // 引用类型：固定对象并获取指针
                if (target is null)
                    throw new ArgumentException("Target instance object is null.", nameof(target));
                
                _referenceTarget = Unsafe.As<TTarget, object?>(ref target);
                
            }
        }
        else
        {
            _referenceTarget = null;
        }
    }
    
    private LuminAction(Delegate @delegate)
    {
        _method = @delegate.Method ?? throw new ArgumentNullException(nameof(@delegate.Method));
        _isStatic = @delegate.Method.IsStatic;
        _methodPtr = @delegate.Method.MethodHandle.GetFunctionPointer();
        _targetPointer = null;

        var target = @delegate.Target;
        if (!_isStatic)
        {
            if (target is not TTarget)
                throw new ArgumentException("Target instance object is not type.", typeof(TTarget).Name);
                
            if (IsValueType)
            {
#if NET8_0_OR_GREATER
                if (Unsafe.IsNullRef(ref target))
                    throw new ArgumentException("Target value instance cannot be null.", nameof(target));
#endif
                // 从Delegate创建，不可能是refLike
                var unboxedTarget = Unsafe.AsRef<TTarget>(Unsafe.AsPointer(ref target));
                
#if NET8_0_OR_GREATER
                _targetPointer = NativeMemory.Alloc((nuint)Unsafe.SizeOf<TTarget>());
#else
                _targetPointer = Marshal.AllocHGlobal(Unsafe.SizeOf<TTarget>()).ToPointer();
#endif
                Unsafe.CopyBlock(
                    _targetPointer,
                    Unsafe.AsPointer(ref unboxedTarget),
                    (uint)Unsafe.SizeOf<TTarget>()
                );
            }
            else
            {
                // 引用类型：固定对象并获取指针
                if (target is null)
                    throw new ArgumentException("Target instance object is null.", nameof(target));
                
                _referenceTarget = target;
            }
        }
        else
        {
            _referenceTarget = null;
        }
    }

    #endregion
    
    #region Create Factory

    /// <summary>
    /// 创建Lumin委托
    /// </summary>
    /// <param name="target">委托绑定的实例</param>
    /// <param name="methodName">委托绑定的方法名</param>
    /// <param name="methodNameHash">方法名哈希值（可选）</param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> Create(scoped ref TTarget? target, string methodName, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        
        var method = GetCachedMethod(IsValueType
                ? TargetTypeHandle
                : Unsafe.As<TTarget, object?>(ref target!)?.GetType().TypeHandle ?? TargetTypeHandle,
            methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        return new LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(ref target, method);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> Create(scoped ref TTarget? target, string methodName, Type targetType, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(targetType.TypeHandle, methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        return new LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(ref target, method);
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> Create(scoped ref TTarget? target, ReadOnlySpan<char> methodName, int methodNameHash = 0) =>
        Create(ref target, methodName.ToString(), methodNameHash);
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> Create(scoped ref TTarget? target, ReadOnlySpan<char> methodName, Type targetType, int methodNameHash = 0) =>
        Create(ref target, methodName.ToString(), targetType, methodNameHash);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> Create(Delegate @delegate) => 
        new LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(@delegate);
    
    /// <summary>
    /// 创建绑定静态方法的Lumin委托
    /// </summary>
    /// <param name="methodName">委托绑定的方法名</param>
    /// <param name="methodNameHash">方法名哈希值（可选）</param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> Create(string methodName, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(TargetTypeHandle, methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        if (!method.IsStatic)
            throw new ArgumentException("Method is not static, please pass in instance as parameter.", nameof(methodName));
        
        return new LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(method);
    }

    #endregion
    
    #region Interface Implementation

    public void Dispose()
    {
        if (_disposed)
            return;
        
        if (IsValueType && !_isStatic && _targetPointer != null)
        {
#if NET8_0_OR_GREATER
            NativeMemory.Free(_targetPointer);
#else
            Marshal.FreeHGlobal(new IntPtr(_targetPointer));
#endif
        }
        
        _targetPointer = null;
        _referenceTarget = null;

        _disposed = true;
    }
    
    public object Clone()
    {
        ThrowIfDisposed();
        var target = _referenceTarget;
        if (target is null)
            throw new NullReferenceException("Target instance cannot be null.");
                
        return new LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(ref Unsafe.As<object?, TTarget>(ref target)!, new MethodCache(_isStatic, _methodPtr, _method));
    }

    public void GetObjectData(SerializationInfo info, StreamingContext context)
    {
        throw new NotSupportedException();
    }
    
    public override bool Equals(object? obj)
    {
        return obj is LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> other && Equals(other);
    }

    public bool Equals(LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> other)
    {
        ThrowIfDisposed();
        return _methodPtr == other._methodPtr &&
               _isStatic == other._isStatic &&
               _targetPointer == other._targetPointer;
    }

    public override int GetHashCode()
    {
        ThrowIfDisposed();
        unchecked
        {
            int hash = 17;
            hash = hash * 31 + _methodPtr.GetHashCode();
            hash = hash * 31 + _isStatic.GetHashCode();
            hash = hash * 31 + ((IntPtr)_targetPointer).GetHashCode();
            return hash;
        }
    }

    #endregion
    
    #region Implicit
    
    public static implicit operator LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(in Delegate action) 
        => Create(action);

    // Action 类型的隐式转换
    public static implicit operator LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(Action<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> action) => 
        Create(action);
    
    #endregion

    #region Invoke

    /// <summary>
    /// 使用反射动态调用方法
    /// 慎用，开销较大
    /// </summary>
    /// <param name="args">方法参数数组</param>
    /// <returns>方法返回值</returns>
    public object? DynamicInvoke(params object?[] args)
    {
        ThrowIfDisposed();
        
        if (_isStatic)
        {
            return _method.Invoke(null, args);
        }
        else
        {
            if (typeof(TTarget).IsByRefLike)
                throw new ArgumentException(
                    "The target type is a by-ref-like type and cannot be converted to a delegate.");

#if !NET9_0_OR_GREATER
            if (IsValueType)
                throw new ArgumentException("The target type is value type and cannot dynamic invoke.");
#endif

#if NET9_0_OR_GREATER
            object? instance = IsValueType
                ? RuntimeHelpers.Box(ref Unsafe.AsRef<byte>(_targetPointer), typeof(TTarget).TypeHandle)
                : _referenceTarget;
#else
            object? instance = _referenceTarget;
#endif

            if (instance is null)
                throw new InvalidOperationException("Target instance is null.");

            return _method.Invoke(instance, args);
        }
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10)
    {
        ThrowIfDisposed();
 
        if (!_isStatic && !IsValueType)
            ((delegate* managed<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, void>)_methodPtr)(Unsafe.As<object?, TTarget>(ref _referenceTarget), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
        else if (IsValueType)
            ((delegate* managed<ref TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, void>)_methodPtr)(ref Unsafe.AsRef<TTarget>(_targetPointer), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
        else
            ((delegate* managed<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, void>)_methodPtr)(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
    }

    #endregion
    
    #region Auxiliary methods
    
    public TDelegate ToDelegate<TDelegate>()
        where TDelegate : Delegate
    {
        ThrowIfDisposed();
        if (_isStatic)
        {
            return (TDelegate)Delegate.CreateDelegate(typeof(TDelegate), _method);
        }
        else
        {
            if (typeof(TTarget).IsByRefLike)
                throw new ArgumentException("The target type is a by-ref-like type and cannot be converted to a delegate.");
            
#if !NET9_0_OR_GREATER
            if (IsValueType)
                throw new ArgumentException("The target type is value type and cannot be converted to a delegate.");
#endif

#if NET9_0_OR_GREATER
            object? instance = IsValueType 
                ? RuntimeHelpers.Box(ref Unsafe.AsRef<byte>(_targetPointer), typeof(TTarget).TypeHandle)
                : _referenceTarget;
#else
            object? instance = _referenceTarget;
#endif
            
            if (instance is null)
                throw new InvalidOperationException("Target instance is null.");
            
            return (TDelegate)Delegate.CreateDelegate(typeof(TDelegate), instance, _method);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void ThrowIfDisposed()
    {
        if (_disposed)
            throw new ObjectDisposedException(nameof(LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>));
    }
    
    #endregion
    
    #region Static Type Hash

    private static readonly int TypeHash = ComputeTypeHash();
    private static readonly int TargetTypeHash = TargetTypeHandle.GetHashCode();
    private static readonly RuntimeTypeHandle TargetTypeHandle = typeof(TTarget).TypeHandle;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static int ComputeTypeHash()
    {
        unchecked
        {
            int h = (int)2166136261;
    
            h = (h * 16777619) ^ typeof(T1).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T2).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T3).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T4).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T5).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T6).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T7).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T8).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T9).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T10).TypeHandle.GetHashCode();
            return h;
        }
    }

    #endregion

    #region Method Caching

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static MethodCache GetCachedMethod(scoped in RuntimeTypeHandle type, string methodName, int nameHash = 0)
    {
        nameHash = nameHash is 0 ? StringComparer.Ordinal.GetHashCode(methodName) : nameHash;
        int key = type.Equals(TargetTypeHandle)
                      ? TypeHash ^ nameHash ^ TargetTypeHash
                      : TypeHash ^ nameHash ^ type.GetHashCode();

        if (!Methods.TryGetValue(key, out var result))
        {
            const BindingFlags flags = BindingFlags.Public | BindingFlags.NonPublic |
                                       BindingFlags.Instance | BindingFlags.Static;
    
            Type[] paramTypes = [ typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10) ];

#if NET8_0_OR_GREATER
            var method = Type.GetTypeFromHandle(type)!.GetMethod(methodName, flags, paramTypes)
                         ?? throw new MissingMethodException($"Method {methodName} not found on {Type.GetTypeFromHandle(type)!}");
#else
            var method = Type.GetTypeFromHandle(type)!.GetMethod(methodName, flags, null, paramTypes, null)
                         ?? throw new MissingMethodException($"Method {methodName} not found on {Type.GetTypeFromHandle(type)!}");
#endif
            result = new MethodCache(method.IsStatic, method.MethodHandle.GetFunctionPointer(), method);

            Methods.TryAdd(key, result);
        }

        return result;
    }
    
    #endregion
}

public unsafe struct LuminAction<
#if NET8_0_OR_GREATER
[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)]
#endif
TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> : IDisposable, ICloneable, ISerializable, IEquatable<LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>>
#if NET9_0_OR_GREATER
    where TTarget : allows ref struct
    where T1 : allows ref struct
    where T2 : allows ref struct
    where T3 : allows ref struct
    where T4 : allows ref struct
    where T5 : allows ref struct
    where T6 : allows ref struct
    where T7 : allows ref struct
    where T8 : allows ref struct
    where T9 : allows ref struct
    where T10 : allows ref struct
    where T11 : allows ref struct
#endif
{
    private void* _targetPointer; 
    private object? _referenceTarget; 
    private readonly IntPtr _methodPtr;
    private readonly bool _isStatic;
    private readonly MethodInfo _method; 
    private bool _disposed;

    private static readonly bool IsValueType = typeof(TTarget).IsValueType;
    
    public TTarget? Target
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            ThrowIfDisposed();
            
            if (_isStatic)
                return default;
            
            if (IsValueType)
                return Unsafe.AsRef<TTarget?>(_targetPointer);
            
            var target = _referenceTarget;
            return Unsafe.As<object?, TTarget?>(ref target);
        }
    }
    
    public MethodInfo Method => _method;

    #region Constructors
    
    private LuminAction(MethodCache method)
    {
        _method = method.MethodBase ?? throw new ArgumentNullException(nameof(method));
        _isStatic = method.IsStatic;
        _methodPtr = method.MethodPtr;


        if (!_isStatic)
            throw new ArgumentException("methods are not static!", method.MethodBase.Name);

        _referenceTarget = null;
        _targetPointer = null;
    }
    
    private LuminAction(scoped ref TTarget? target, MethodCache method)
    {
        _method = method.MethodBase ?? throw new ArgumentNullException(nameof(method));
        _isStatic = method.IsStatic;
        _methodPtr = method.MethodPtr;
        _targetPointer = null;        
        if (!_isStatic)
        {
            if (IsValueType)
            {
#if NET8_0_OR_GREATER
                if (Unsafe.IsNullRef(ref target))
                    throw new ArgumentException("Target value instance cannot be null.", nameof(target));
#endif

#if NET8_0_OR_GREATER
                _targetPointer = NativeMemory.Alloc((nuint)Unsafe.SizeOf<TTarget>());
#else
                _targetPointer = Marshal.AllocHGlobal(Unsafe.SizeOf<TTarget>()).ToPointer();
#endif
                Unsafe.CopyBlock(
                    _targetPointer,
                    Unsafe.AsPointer(ref target),
                    (uint)Unsafe.SizeOf<TTarget>()
                );
            }
            else
            {
                // 引用类型：固定对象并获取指针
                if (target is null)
                    throw new ArgumentException("Target instance object is null.", nameof(target));
                
                _referenceTarget = Unsafe.As<TTarget, object?>(ref target);
                
            }
        }
        else
        {
            _referenceTarget = null;
        }
    }
    
    private LuminAction(Delegate @delegate)
    {
        _method = @delegate.Method ?? throw new ArgumentNullException(nameof(@delegate.Method));
        _isStatic = @delegate.Method.IsStatic;
        _methodPtr = @delegate.Method.MethodHandle.GetFunctionPointer();
        _targetPointer = null;

        var target = @delegate.Target;
        if (!_isStatic)
        {
            if (target is not TTarget)
                throw new ArgumentException("Target instance object is not type.", typeof(TTarget).Name);
                
            if (IsValueType)
            {
#if NET8_0_OR_GREATER
                if (Unsafe.IsNullRef(ref target))
                    throw new ArgumentException("Target value instance cannot be null.", nameof(target));
#endif
                // 从Delegate创建，不可能是refLike
                var unboxedTarget = Unsafe.AsRef<TTarget>(Unsafe.AsPointer(ref target));
                
#if NET8_0_OR_GREATER
                _targetPointer = NativeMemory.Alloc((nuint)Unsafe.SizeOf<TTarget>());
#else
                _targetPointer = Marshal.AllocHGlobal(Unsafe.SizeOf<TTarget>()).ToPointer();
#endif
                Unsafe.CopyBlock(
                    _targetPointer,
                    Unsafe.AsPointer(ref unboxedTarget),
                    (uint)Unsafe.SizeOf<TTarget>()
                );
            }
            else
            {
                // 引用类型：固定对象并获取指针
                if (target is null)
                    throw new ArgumentException("Target instance object is null.", nameof(target));
                
                _referenceTarget = target;
            }
        }
        else
        {
            _referenceTarget = null;
        }
    }

    #endregion
    
    #region Create Factory

    /// <summary>
    /// 创建Lumin委托
    /// </summary>
    /// <param name="target">委托绑定的实例</param>
    /// <param name="methodName">委托绑定的方法名</param>
    /// <param name="methodNameHash">方法名哈希值（可选）</param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> Create(scoped ref TTarget? target, string methodName, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        
        var method = GetCachedMethod(IsValueType
                ? TargetTypeHandle
                : Unsafe.As<TTarget, object?>(ref target!)?.GetType().TypeHandle ?? TargetTypeHandle,
            methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        return new LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(ref target, method);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> Create(scoped ref TTarget? target, string methodName, Type targetType, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(targetType.TypeHandle, methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        return new LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(ref target, method);
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> Create(scoped ref TTarget? target, ReadOnlySpan<char> methodName, int methodNameHash = 0) =>
        Create(ref target, methodName.ToString(), methodNameHash);
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> Create(scoped ref TTarget? target, ReadOnlySpan<char> methodName, Type targetType, int methodNameHash = 0) =>
        Create(ref target, methodName.ToString(), targetType, methodNameHash);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> Create(Delegate @delegate) => 
        new LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(@delegate);
    
    /// <summary>
    /// 创建绑定静态方法的Lumin委托
    /// </summary>
    /// <param name="methodName">委托绑定的方法名</param>
    /// <param name="methodNameHash">方法名哈希值（可选）</param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> Create(string methodName, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(TargetTypeHandle, methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        if (!method.IsStatic)
            throw new ArgumentException("Method is not static, please pass in instance as parameter.", nameof(methodName));
        
        return new LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(method);
    }

    #endregion
    
    #region Interface Implementation

    public void Dispose()
    {
        if (_disposed)
            return;
        
        if (IsValueType && !_isStatic && _targetPointer != null)
        {
#if NET8_0_OR_GREATER
            NativeMemory.Free(_targetPointer);
#else
            Marshal.FreeHGlobal(new IntPtr(_targetPointer));
#endif
        }
        
        _targetPointer = null;
        _referenceTarget = null;

        _disposed = true;
    }
    
    public object Clone()
    {
        ThrowIfDisposed();
        var target = _referenceTarget;
        if (target is null)
            throw new NullReferenceException("Target instance cannot be null.");
                
        return new LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(ref Unsafe.As<object?, TTarget>(ref target)!, new MethodCache(_isStatic, _methodPtr, _method));
    }

    public void GetObjectData(SerializationInfo info, StreamingContext context)
    {
        throw new NotSupportedException();
    }
    
    public override bool Equals(object? obj)
    {
        return obj is LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> other && Equals(other);
    }

    public bool Equals(LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> other)
    {
        ThrowIfDisposed();
        return _methodPtr == other._methodPtr &&
               _isStatic == other._isStatic &&
               _targetPointer == other._targetPointer;
    }

    public override int GetHashCode()
    {
        ThrowIfDisposed();
        unchecked
        {
            int hash = 17;
            hash = hash * 31 + _methodPtr.GetHashCode();
            hash = hash * 31 + _isStatic.GetHashCode();
            hash = hash * 31 + ((IntPtr)_targetPointer).GetHashCode();
            return hash;
        }
    }

    #endregion
    
    #region Implicit
    
    public static implicit operator LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(in Delegate action) 
        => Create(action);

    // Action 类型的隐式转换
    public static implicit operator LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(Action<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> action) => 
        Create(action);
    
    #endregion

    #region Invoke

    /// <summary>
    /// 使用反射动态调用方法
    /// 慎用，开销较大
    /// </summary>
    /// <param name="args">方法参数数组</param>
    /// <returns>方法返回值</returns>
    public object? DynamicInvoke(params object?[] args)
    {
        ThrowIfDisposed();
        
        if (_isStatic)
        {
            return _method.Invoke(null, args);
        }
        else
        {
            if (typeof(TTarget).IsByRefLike)
                throw new ArgumentException(
                    "The target type is a by-ref-like type and cannot be converted to a delegate.");

#if !NET9_0_OR_GREATER
            if (IsValueType)
                throw new ArgumentException("The target type is value type and cannot dynamic invoke.");
#endif

#if NET9_0_OR_GREATER
            object? instance = IsValueType
                ? RuntimeHelpers.Box(ref Unsafe.AsRef<byte>(_targetPointer), typeof(TTarget).TypeHandle)
                : _referenceTarget;
#else
            object? instance = _referenceTarget;
#endif

            if (instance is null)
                throw new InvalidOperationException("Target instance is null.");

            return _method.Invoke(instance, args);
        }
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11)
    {
        ThrowIfDisposed();
 
        if (!_isStatic && !IsValueType)
            ((delegate* managed<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, void>)_methodPtr)(Unsafe.As<object?, TTarget>(ref _referenceTarget), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11);
        else if (IsValueType)
            ((delegate* managed<ref TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, void>)_methodPtr)(ref Unsafe.AsRef<TTarget>(_targetPointer), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11);
        else
            ((delegate* managed<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, void>)_methodPtr)(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11);
    }

    #endregion
    
    #region Auxiliary methods
    
    public TDelegate ToDelegate<TDelegate>()
        where TDelegate : Delegate
    {
        ThrowIfDisposed();
        if (_isStatic)
        {
            return (TDelegate)Delegate.CreateDelegate(typeof(TDelegate), _method);
        }
        else
        {
            if (typeof(TTarget).IsByRefLike)
                throw new ArgumentException("The target type is a by-ref-like type and cannot be converted to a delegate.");
            
#if !NET9_0_OR_GREATER
            if (IsValueType)
                throw new ArgumentException("The target type is value type and cannot be converted to a delegate.");
#endif

#if NET9_0_OR_GREATER
            object? instance = IsValueType 
                ? RuntimeHelpers.Box(ref Unsafe.AsRef<byte>(_targetPointer), typeof(TTarget).TypeHandle)
                : _referenceTarget;
#else
            object? instance = _referenceTarget;
#endif
            
            if (instance is null)
                throw new InvalidOperationException("Target instance is null.");
            
            return (TDelegate)Delegate.CreateDelegate(typeof(TDelegate), instance, _method);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void ThrowIfDisposed()
    {
        if (_disposed)
            throw new ObjectDisposedException(nameof(LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>));
    }
    
    #endregion
    
    #region Static Type Hash

    private static readonly int TypeHash = ComputeTypeHash();
    private static readonly int TargetTypeHash = TargetTypeHandle.GetHashCode();
    private static readonly RuntimeTypeHandle TargetTypeHandle = typeof(TTarget).TypeHandle;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static int ComputeTypeHash()
    {
        unchecked
        {
            int h = (int)2166136261;
    
            h = (h * 16777619) ^ typeof(T1).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T2).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T3).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T4).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T5).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T6).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T7).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T8).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T9).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T10).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T11).TypeHandle.GetHashCode();
            return h;
        }
    }

    #endregion

    #region Method Caching

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static MethodCache GetCachedMethod(scoped in RuntimeTypeHandle type, string methodName, int nameHash = 0)
    {
        nameHash = nameHash is 0 ? StringComparer.Ordinal.GetHashCode(methodName) : nameHash;
        int key = type.Equals(TargetTypeHandle)
                      ? TypeHash ^ nameHash ^ TargetTypeHash
                      : TypeHash ^ nameHash ^ type.GetHashCode();

        if (!Methods.TryGetValue(key, out var result))
        {
            const BindingFlags flags = BindingFlags.Public | BindingFlags.NonPublic |
                                       BindingFlags.Instance | BindingFlags.Static;
    
            Type[] paramTypes = [ typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11) ];

#if NET8_0_OR_GREATER
            var method = Type.GetTypeFromHandle(type)!.GetMethod(methodName, flags, paramTypes)
                         ?? throw new MissingMethodException($"Method {methodName} not found on {Type.GetTypeFromHandle(type)!}");
#else
            var method = Type.GetTypeFromHandle(type)!.GetMethod(methodName, flags, null, paramTypes, null)
                         ?? throw new MissingMethodException($"Method {methodName} not found on {Type.GetTypeFromHandle(type)!}");
#endif
            result = new MethodCache(method.IsStatic, method.MethodHandle.GetFunctionPointer(), method);

            Methods.TryAdd(key, result);
        }

        return result;
    }
    
    #endregion
}

public unsafe struct LuminAction<
#if NET8_0_OR_GREATER
[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)]
#endif
TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> : IDisposable, ICloneable, ISerializable, IEquatable<LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>>
#if NET9_0_OR_GREATER
    where TTarget : allows ref struct
    where T1 : allows ref struct
    where T2 : allows ref struct
    where T3 : allows ref struct
    where T4 : allows ref struct
    where T5 : allows ref struct
    where T6 : allows ref struct
    where T7 : allows ref struct
    where T8 : allows ref struct
    where T9 : allows ref struct
    where T10 : allows ref struct
    where T11 : allows ref struct
    where T12 : allows ref struct
#endif
{
    private void* _targetPointer; 
    private object? _referenceTarget; 
    private readonly IntPtr _methodPtr;
    private readonly bool _isStatic;
    private readonly MethodInfo _method; 
    private bool _disposed;

    private static readonly bool IsValueType = typeof(TTarget).IsValueType;
    
    public TTarget? Target
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            ThrowIfDisposed();
            
            if (_isStatic)
                return default;
            
            if (IsValueType)
                return Unsafe.AsRef<TTarget?>(_targetPointer);
            
            var target = _referenceTarget;
            return Unsafe.As<object?, TTarget?>(ref target);
        }
    }
    
    public MethodInfo Method => _method;

    #region Constructors
    
    private LuminAction(MethodCache method)
    {
        _method = method.MethodBase ?? throw new ArgumentNullException(nameof(method));
        _isStatic = method.IsStatic;
        _methodPtr = method.MethodPtr;


        if (!_isStatic)
            throw new ArgumentException("methods are not static!", method.MethodBase.Name);

        _referenceTarget = null;
        _targetPointer = null;
    }
    
    private LuminAction(scoped ref TTarget? target, MethodCache method)
    {
        _method = method.MethodBase ?? throw new ArgumentNullException(nameof(method));
        _isStatic = method.IsStatic;
        _methodPtr = method.MethodPtr;
        _targetPointer = null;        
        if (!_isStatic)
        {
            if (IsValueType)
            {
#if NET8_0_OR_GREATER
                if (Unsafe.IsNullRef(ref target))
                    throw new ArgumentException("Target value instance cannot be null.", nameof(target));
#endif

#if NET8_0_OR_GREATER
                _targetPointer = NativeMemory.Alloc((nuint)Unsafe.SizeOf<TTarget>());
#else
                _targetPointer = Marshal.AllocHGlobal(Unsafe.SizeOf<TTarget>()).ToPointer();
#endif
                Unsafe.CopyBlock(
                    _targetPointer,
                    Unsafe.AsPointer(ref target),
                    (uint)Unsafe.SizeOf<TTarget>()
                );
            }
            else
            {
                // 引用类型：固定对象并获取指针
                if (target is null)
                    throw new ArgumentException("Target instance object is null.", nameof(target));
                
                _referenceTarget = Unsafe.As<TTarget, object?>(ref target);
                
            }
        }
        else
        {
            _referenceTarget = null;
        }
    }
    
    private LuminAction(Delegate @delegate)
    {
        _method = @delegate.Method ?? throw new ArgumentNullException(nameof(@delegate.Method));
        _isStatic = @delegate.Method.IsStatic;
        _methodPtr = @delegate.Method.MethodHandle.GetFunctionPointer();
        _targetPointer = null;

        var target = @delegate.Target;
        if (!_isStatic)
        {
            if (target is not TTarget)
                throw new ArgumentException("Target instance object is not type.", typeof(TTarget).Name);
                
            if (IsValueType)
            {
#if NET8_0_OR_GREATER
                if (Unsafe.IsNullRef(ref target))
                    throw new ArgumentException("Target value instance cannot be null.", nameof(target));
#endif
                // 从Delegate创建，不可能是refLike
                var unboxedTarget = Unsafe.AsRef<TTarget>(Unsafe.AsPointer(ref target));
                
#if NET8_0_OR_GREATER
                _targetPointer = NativeMemory.Alloc((nuint)Unsafe.SizeOf<TTarget>());
#else
                _targetPointer = Marshal.AllocHGlobal(Unsafe.SizeOf<TTarget>()).ToPointer();
#endif
                Unsafe.CopyBlock(
                    _targetPointer,
                    Unsafe.AsPointer(ref unboxedTarget),
                    (uint)Unsafe.SizeOf<TTarget>()
                );
            }
            else
            {
                // 引用类型：固定对象并获取指针
                if (target is null)
                    throw new ArgumentException("Target instance object is null.", nameof(target));
                
                _referenceTarget = target;
            }
        }
        else
        {
            _referenceTarget = null;
        }
    }

    #endregion
    
    #region Create Factory

    /// <summary>
    /// 创建Lumin委托
    /// </summary>
    /// <param name="target">委托绑定的实例</param>
    /// <param name="methodName">委托绑定的方法名</param>
    /// <param name="methodNameHash">方法名哈希值（可选）</param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> Create(scoped ref TTarget? target, string methodName, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        
        var method = GetCachedMethod(IsValueType
                ? TargetTypeHandle
                : Unsafe.As<TTarget, object?>(ref target!)?.GetType().TypeHandle ?? TargetTypeHandle,
            methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        return new LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(ref target, method);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> Create(scoped ref TTarget? target, string methodName, Type targetType, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(targetType.TypeHandle, methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        return new LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(ref target, method);
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> Create(scoped ref TTarget? target, ReadOnlySpan<char> methodName, int methodNameHash = 0) =>
        Create(ref target, methodName.ToString(), methodNameHash);
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> Create(scoped ref TTarget? target, ReadOnlySpan<char> methodName, Type targetType, int methodNameHash = 0) =>
        Create(ref target, methodName.ToString(), targetType, methodNameHash);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> Create(Delegate @delegate) => 
        new LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(@delegate);
    
    /// <summary>
    /// 创建绑定静态方法的Lumin委托
    /// </summary>
    /// <param name="methodName">委托绑定的方法名</param>
    /// <param name="methodNameHash">方法名哈希值（可选）</param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> Create(string methodName, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(TargetTypeHandle, methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        if (!method.IsStatic)
            throw new ArgumentException("Method is not static, please pass in instance as parameter.", nameof(methodName));
        
        return new LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(method);
    }

    #endregion
    
    #region Interface Implementation

    public void Dispose()
    {
        if (_disposed)
            return;
        
        if (IsValueType && !_isStatic && _targetPointer != null)
        {
#if NET8_0_OR_GREATER
            NativeMemory.Free(_targetPointer);
#else
            Marshal.FreeHGlobal(new IntPtr(_targetPointer));
#endif
        }
        
        _targetPointer = null;
        _referenceTarget = null;

        _disposed = true;
    }
    
    public object Clone()
    {
        ThrowIfDisposed();
        var target = _referenceTarget;
        if (target is null)
            throw new NullReferenceException("Target instance cannot be null.");
                
        return new LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(ref Unsafe.As<object?, TTarget>(ref target)!, new MethodCache(_isStatic, _methodPtr, _method));
    }

    public void GetObjectData(SerializationInfo info, StreamingContext context)
    {
        throw new NotSupportedException();
    }
    
    public override bool Equals(object? obj)
    {
        return obj is LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> other && Equals(other);
    }

    public bool Equals(LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> other)
    {
        ThrowIfDisposed();
        return _methodPtr == other._methodPtr &&
               _isStatic == other._isStatic &&
               _targetPointer == other._targetPointer;
    }

    public override int GetHashCode()
    {
        ThrowIfDisposed();
        unchecked
        {
            int hash = 17;
            hash = hash * 31 + _methodPtr.GetHashCode();
            hash = hash * 31 + _isStatic.GetHashCode();
            hash = hash * 31 + ((IntPtr)_targetPointer).GetHashCode();
            return hash;
        }
    }

    #endregion
    
    #region Implicit
    
    public static implicit operator LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(in Delegate action) 
        => Create(action);

    // Action 类型的隐式转换
    public static implicit operator LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(Action<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> action) => 
        Create(action);
    
    #endregion

    #region Invoke

    /// <summary>
    /// 使用反射动态调用方法
    /// 慎用，开销较大
    /// </summary>
    /// <param name="args">方法参数数组</param>
    /// <returns>方法返回值</returns>
    public object? DynamicInvoke(params object?[] args)
    {
        ThrowIfDisposed();
        
        if (_isStatic)
        {
            return _method.Invoke(null, args);
        }
        else
        {
            if (typeof(TTarget).IsByRefLike)
                throw new ArgumentException(
                    "The target type is a by-ref-like type and cannot be converted to a delegate.");

#if !NET9_0_OR_GREATER
            if (IsValueType)
                throw new ArgumentException("The target type is value type and cannot dynamic invoke.");
#endif

#if NET9_0_OR_GREATER
            object? instance = IsValueType
                ? RuntimeHelpers.Box(ref Unsafe.AsRef<byte>(_targetPointer), typeof(TTarget).TypeHandle)
                : _referenceTarget;
#else
            object? instance = _referenceTarget;
#endif

            if (instance is null)
                throw new InvalidOperationException("Target instance is null.");

            return _method.Invoke(instance, args);
        }
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12)
    {
        ThrowIfDisposed();
 
        if (!_isStatic && !IsValueType)
            ((delegate* managed<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, void>)_methodPtr)(Unsafe.As<object?, TTarget>(ref _referenceTarget), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12);
        else if (IsValueType)
            ((delegate* managed<ref TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, void>)_methodPtr)(ref Unsafe.AsRef<TTarget>(_targetPointer), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12);
        else
            ((delegate* managed<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, void>)_methodPtr)(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12);
    }

    #endregion
    
    #region Auxiliary methods
    
    public TDelegate ToDelegate<TDelegate>()
        where TDelegate : Delegate
    {
        ThrowIfDisposed();
        if (_isStatic)
        {
            return (TDelegate)Delegate.CreateDelegate(typeof(TDelegate), _method);
        }
        else
        {
            if (typeof(TTarget).IsByRefLike)
                throw new ArgumentException("The target type is a by-ref-like type and cannot be converted to a delegate.");
            
#if !NET9_0_OR_GREATER
            if (IsValueType)
                throw new ArgumentException("The target type is value type and cannot be converted to a delegate.");
#endif

#if NET9_0_OR_GREATER
            object? instance = IsValueType 
                ? RuntimeHelpers.Box(ref Unsafe.AsRef<byte>(_targetPointer), typeof(TTarget).TypeHandle)
                : _referenceTarget;
#else
            object? instance = _referenceTarget;
#endif
            
            if (instance is null)
                throw new InvalidOperationException("Target instance is null.");
            
            return (TDelegate)Delegate.CreateDelegate(typeof(TDelegate), instance, _method);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void ThrowIfDisposed()
    {
        if (_disposed)
            throw new ObjectDisposedException(nameof(LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>));
    }
    
    #endregion
    
    #region Static Type Hash

    private static readonly int TypeHash = ComputeTypeHash();
    private static readonly int TargetTypeHash = TargetTypeHandle.GetHashCode();
    private static readonly RuntimeTypeHandle TargetTypeHandle = typeof(TTarget).TypeHandle;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static int ComputeTypeHash()
    {
        unchecked
        {
            int h = (int)2166136261;
    
            h = (h * 16777619) ^ typeof(T1).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T2).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T3).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T4).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T5).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T6).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T7).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T8).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T9).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T10).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T11).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T12).TypeHandle.GetHashCode();
            return h;
        }
    }

    #endregion

    #region Method Caching

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static MethodCache GetCachedMethod(scoped in RuntimeTypeHandle type, string methodName, int nameHash = 0)
    {
        nameHash = nameHash is 0 ? StringComparer.Ordinal.GetHashCode(methodName) : nameHash;
        int key = type.Equals(TargetTypeHandle)
                      ? TypeHash ^ nameHash ^ TargetTypeHash
                      : TypeHash ^ nameHash ^ type.GetHashCode();

        if (!Methods.TryGetValue(key, out var result))
        {
            const BindingFlags flags = BindingFlags.Public | BindingFlags.NonPublic |
                                       BindingFlags.Instance | BindingFlags.Static;
    
            Type[] paramTypes = [ typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), typeof(T12) ];

#if NET8_0_OR_GREATER
            var method = Type.GetTypeFromHandle(type)!.GetMethod(methodName, flags, paramTypes)
                         ?? throw new MissingMethodException($"Method {methodName} not found on {Type.GetTypeFromHandle(type)!}");
#else
            var method = Type.GetTypeFromHandle(type)!.GetMethod(methodName, flags, null, paramTypes, null)
                         ?? throw new MissingMethodException($"Method {methodName} not found on {Type.GetTypeFromHandle(type)!}");
#endif
            result = new MethodCache(method.IsStatic, method.MethodHandle.GetFunctionPointer(), method);

            Methods.TryAdd(key, result);
        }

        return result;
    }
    
    #endregion
}

public unsafe struct LuminAction<
#if NET8_0_OR_GREATER
[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)]
#endif
TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> : IDisposable, ICloneable, ISerializable, IEquatable<LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>>
#if NET9_0_OR_GREATER
    where TTarget : allows ref struct
    where T1 : allows ref struct
    where T2 : allows ref struct
    where T3 : allows ref struct
    where T4 : allows ref struct
    where T5 : allows ref struct
    where T6 : allows ref struct
    where T7 : allows ref struct
    where T8 : allows ref struct
    where T9 : allows ref struct
    where T10 : allows ref struct
    where T11 : allows ref struct
    where T12 : allows ref struct
    where T13 : allows ref struct
#endif
{
    private void* _targetPointer; 
    private object? _referenceTarget; 
    private readonly IntPtr _methodPtr;
    private readonly bool _isStatic;
    private readonly MethodInfo _method; 
    private bool _disposed;

    private static readonly bool IsValueType = typeof(TTarget).IsValueType;
    
    public TTarget? Target
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            ThrowIfDisposed();
            
            if (_isStatic)
                return default;
            
            if (IsValueType)
                return Unsafe.AsRef<TTarget?>(_targetPointer);
            
            var target = _referenceTarget;
            return Unsafe.As<object?, TTarget?>(ref target);
        }
    }
    
    public MethodInfo Method => _method;

    #region Constructors
    
    private LuminAction(MethodCache method)
    {
        _method = method.MethodBase ?? throw new ArgumentNullException(nameof(method));
        _isStatic = method.IsStatic;
        _methodPtr = method.MethodPtr;


        if (!_isStatic)
            throw new ArgumentException("methods are not static!", method.MethodBase.Name);

        _referenceTarget = null;
        _targetPointer = null;
    }
    
    private LuminAction(scoped ref TTarget? target, MethodCache method)
    {
        _method = method.MethodBase ?? throw new ArgumentNullException(nameof(method));
        _isStatic = method.IsStatic;
        _methodPtr = method.MethodPtr;
        _targetPointer = null;        
        if (!_isStatic)
        {
            if (IsValueType)
            {
#if NET8_0_OR_GREATER
                if (Unsafe.IsNullRef(ref target))
                    throw new ArgumentException("Target value instance cannot be null.", nameof(target));
#endif

#if NET8_0_OR_GREATER
                _targetPointer = NativeMemory.Alloc((nuint)Unsafe.SizeOf<TTarget>());
#else
                _targetPointer = Marshal.AllocHGlobal(Unsafe.SizeOf<TTarget>()).ToPointer();
#endif
                Unsafe.CopyBlock(
                    _targetPointer,
                    Unsafe.AsPointer(ref target),
                    (uint)Unsafe.SizeOf<TTarget>()
                );
            }
            else
            {
                // 引用类型：固定对象并获取指针
                if (target is null)
                    throw new ArgumentException("Target instance object is null.", nameof(target));
                
                _referenceTarget = Unsafe.As<TTarget, object?>(ref target);
                
            }
        }
        else
        {
            _referenceTarget = null;
        }
    }
    
    private LuminAction(Delegate @delegate)
    {
        _method = @delegate.Method ?? throw new ArgumentNullException(nameof(@delegate.Method));
        _isStatic = @delegate.Method.IsStatic;
        _methodPtr = @delegate.Method.MethodHandle.GetFunctionPointer();
        _targetPointer = null;

        var target = @delegate.Target;
        if (!_isStatic)
        {
            if (target is not TTarget)
                throw new ArgumentException("Target instance object is not type.", typeof(TTarget).Name);
                
            if (IsValueType)
            {
#if NET8_0_OR_GREATER
                if (Unsafe.IsNullRef(ref target))
                    throw new ArgumentException("Target value instance cannot be null.", nameof(target));
#endif
                // 从Delegate创建，不可能是refLike
                var unboxedTarget = Unsafe.AsRef<TTarget>(Unsafe.AsPointer(ref target));
                
#if NET8_0_OR_GREATER
                _targetPointer = NativeMemory.Alloc((nuint)Unsafe.SizeOf<TTarget>());
#else
                _targetPointer = Marshal.AllocHGlobal(Unsafe.SizeOf<TTarget>()).ToPointer();
#endif
                Unsafe.CopyBlock(
                    _targetPointer,
                    Unsafe.AsPointer(ref unboxedTarget),
                    (uint)Unsafe.SizeOf<TTarget>()
                );
            }
            else
            {
                // 引用类型：固定对象并获取指针
                if (target is null)
                    throw new ArgumentException("Target instance object is null.", nameof(target));
                
                _referenceTarget = target;
            }
        }
        else
        {
            _referenceTarget = null;
        }
    }

    #endregion
    
    #region Create Factory

    /// <summary>
    /// 创建Lumin委托
    /// </summary>
    /// <param name="target">委托绑定的实例</param>
    /// <param name="methodName">委托绑定的方法名</param>
    /// <param name="methodNameHash">方法名哈希值（可选）</param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> Create(scoped ref TTarget? target, string methodName, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        
        var method = GetCachedMethod(IsValueType
                ? TargetTypeHandle
                : Unsafe.As<TTarget, object?>(ref target!)?.GetType().TypeHandle ?? TargetTypeHandle,
            methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        return new LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(ref target, method);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> Create(scoped ref TTarget? target, string methodName, Type targetType, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(targetType.TypeHandle, methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        return new LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(ref target, method);
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> Create(scoped ref TTarget? target, ReadOnlySpan<char> methodName, int methodNameHash = 0) =>
        Create(ref target, methodName.ToString(), methodNameHash);
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> Create(scoped ref TTarget? target, ReadOnlySpan<char> methodName, Type targetType, int methodNameHash = 0) =>
        Create(ref target, methodName.ToString(), targetType, methodNameHash);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> Create(Delegate @delegate) => 
        new LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(@delegate);
    
    /// <summary>
    /// 创建绑定静态方法的Lumin委托
    /// </summary>
    /// <param name="methodName">委托绑定的方法名</param>
    /// <param name="methodNameHash">方法名哈希值（可选）</param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> Create(string methodName, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(TargetTypeHandle, methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        if (!method.IsStatic)
            throw new ArgumentException("Method is not static, please pass in instance as parameter.", nameof(methodName));
        
        return new LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(method);
    }

    #endregion
    
    #region Interface Implementation

    public void Dispose()
    {
        if (_disposed)
            return;
        
        if (IsValueType && !_isStatic && _targetPointer != null)
        {
#if NET8_0_OR_GREATER
            NativeMemory.Free(_targetPointer);
#else
            Marshal.FreeHGlobal(new IntPtr(_targetPointer));
#endif
        }
        
        _targetPointer = null;
        _referenceTarget = null;

        _disposed = true;
    }
    
    public object Clone()
    {
        ThrowIfDisposed();
        var target = _referenceTarget;
        if (target is null)
            throw new NullReferenceException("Target instance cannot be null.");
                
        return new LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(ref Unsafe.As<object?, TTarget>(ref target)!, new MethodCache(_isStatic, _methodPtr, _method));
    }

    public void GetObjectData(SerializationInfo info, StreamingContext context)
    {
        throw new NotSupportedException();
    }
    
    public override bool Equals(object? obj)
    {
        return obj is LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> other && Equals(other);
    }

    public bool Equals(LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> other)
    {
        ThrowIfDisposed();
        return _methodPtr == other._methodPtr &&
               _isStatic == other._isStatic &&
               _targetPointer == other._targetPointer;
    }

    public override int GetHashCode()
    {
        ThrowIfDisposed();
        unchecked
        {
            int hash = 17;
            hash = hash * 31 + _methodPtr.GetHashCode();
            hash = hash * 31 + _isStatic.GetHashCode();
            hash = hash * 31 + ((IntPtr)_targetPointer).GetHashCode();
            return hash;
        }
    }

    #endregion
    
    #region Implicit
    
    public static implicit operator LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(in Delegate action) 
        => Create(action);

    // Action 类型的隐式转换
    public static implicit operator LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(Action<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> action) => 
        Create(action);
    
    #endregion

    #region Invoke

    /// <summary>
    /// 使用反射动态调用方法
    /// 慎用，开销较大
    /// </summary>
    /// <param name="args">方法参数数组</param>
    /// <returns>方法返回值</returns>
    public object? DynamicInvoke(params object?[] args)
    {
        ThrowIfDisposed();
        
        if (_isStatic)
        {
            return _method.Invoke(null, args);
        }
        else
        {
            if (typeof(TTarget).IsByRefLike)
                throw new ArgumentException(
                    "The target type is a by-ref-like type and cannot be converted to a delegate.");

#if !NET9_0_OR_GREATER
            if (IsValueType)
                throw new ArgumentException("The target type is value type and cannot dynamic invoke.");
#endif

#if NET9_0_OR_GREATER
            object? instance = IsValueType
                ? RuntimeHelpers.Box(ref Unsafe.AsRef<byte>(_targetPointer), typeof(TTarget).TypeHandle)
                : _referenceTarget;
#else
            object? instance = _referenceTarget;
#endif

            if (instance is null)
                throw new InvalidOperationException("Target instance is null.");

            return _method.Invoke(instance, args);
        }
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13)
    {
        ThrowIfDisposed();
 
        if (!_isStatic && !IsValueType)
            ((delegate* managed<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, void>)_methodPtr)(Unsafe.As<object?, TTarget>(ref _referenceTarget), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13);
        else if (IsValueType)
            ((delegate* managed<ref TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, void>)_methodPtr)(ref Unsafe.AsRef<TTarget>(_targetPointer), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13);
        else
            ((delegate* managed<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, void>)_methodPtr)(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13);
    }

    #endregion
    
    #region Auxiliary methods
    
    public TDelegate ToDelegate<TDelegate>()
        where TDelegate : Delegate
    {
        ThrowIfDisposed();
        if (_isStatic)
        {
            return (TDelegate)Delegate.CreateDelegate(typeof(TDelegate), _method);
        }
        else
        {
            if (typeof(TTarget).IsByRefLike)
                throw new ArgumentException("The target type is a by-ref-like type and cannot be converted to a delegate.");
            
#if !NET9_0_OR_GREATER
            if (IsValueType)
                throw new ArgumentException("The target type is value type and cannot be converted to a delegate.");
#endif

#if NET9_0_OR_GREATER
            object? instance = IsValueType 
                ? RuntimeHelpers.Box(ref Unsafe.AsRef<byte>(_targetPointer), typeof(TTarget).TypeHandle)
                : _referenceTarget;
#else
            object? instance = _referenceTarget;
#endif
            
            if (instance is null)
                throw new InvalidOperationException("Target instance is null.");
            
            return (TDelegate)Delegate.CreateDelegate(typeof(TDelegate), instance, _method);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void ThrowIfDisposed()
    {
        if (_disposed)
            throw new ObjectDisposedException(nameof(LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>));
    }
    
    #endregion
    
    #region Static Type Hash

    private static readonly int TypeHash = ComputeTypeHash();
    private static readonly int TargetTypeHash = TargetTypeHandle.GetHashCode();
    private static readonly RuntimeTypeHandle TargetTypeHandle = typeof(TTarget).TypeHandle;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static int ComputeTypeHash()
    {
        unchecked
        {
            int h = (int)2166136261;
    
            h = (h * 16777619) ^ typeof(T1).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T2).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T3).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T4).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T5).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T6).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T7).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T8).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T9).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T10).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T11).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T12).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T13).TypeHandle.GetHashCode();
            return h;
        }
    }

    #endregion

    #region Method Caching

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static MethodCache GetCachedMethod(scoped in RuntimeTypeHandle type, string methodName, int nameHash = 0)
    {
        nameHash = nameHash is 0 ? StringComparer.Ordinal.GetHashCode(methodName) : nameHash;
        int key = type.Equals(TargetTypeHandle)
                      ? TypeHash ^ nameHash ^ TargetTypeHash
                      : TypeHash ^ nameHash ^ type.GetHashCode();

        if (!Methods.TryGetValue(key, out var result))
        {
            const BindingFlags flags = BindingFlags.Public | BindingFlags.NonPublic |
                                       BindingFlags.Instance | BindingFlags.Static;
    
            Type[] paramTypes = [ typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), typeof(T12), typeof(T13) ];

#if NET8_0_OR_GREATER
            var method = Type.GetTypeFromHandle(type)!.GetMethod(methodName, flags, paramTypes)
                         ?? throw new MissingMethodException($"Method {methodName} not found on {Type.GetTypeFromHandle(type)!}");
#else
            var method = Type.GetTypeFromHandle(type)!.GetMethod(methodName, flags, null, paramTypes, null)
                         ?? throw new MissingMethodException($"Method {methodName} not found on {Type.GetTypeFromHandle(type)!}");
#endif
            result = new MethodCache(method.IsStatic, method.MethodHandle.GetFunctionPointer(), method);

            Methods.TryAdd(key, result);
        }

        return result;
    }
    
    #endregion
}

public unsafe struct LuminAction<
#if NET8_0_OR_GREATER
[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)]
#endif
TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> : IDisposable, ICloneable, ISerializable, IEquatable<LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>>
#if NET9_0_OR_GREATER
    where TTarget : allows ref struct
    where T1 : allows ref struct
    where T2 : allows ref struct
    where T3 : allows ref struct
    where T4 : allows ref struct
    where T5 : allows ref struct
    where T6 : allows ref struct
    where T7 : allows ref struct
    where T8 : allows ref struct
    where T9 : allows ref struct
    where T10 : allows ref struct
    where T11 : allows ref struct
    where T12 : allows ref struct
    where T13 : allows ref struct
    where T14 : allows ref struct
#endif
{
    private void* _targetPointer; 
    private object? _referenceTarget; 
    private readonly IntPtr _methodPtr;
    private readonly bool _isStatic;
    private readonly MethodInfo _method; 
    private bool _disposed;

    private static readonly bool IsValueType = typeof(TTarget).IsValueType;
    
    public TTarget? Target
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            ThrowIfDisposed();
            
            if (_isStatic)
                return default;
            
            if (IsValueType)
                return Unsafe.AsRef<TTarget?>(_targetPointer);
            
            var target = _referenceTarget;
            return Unsafe.As<object?, TTarget?>(ref target);
        }
    }
    
    public MethodInfo Method => _method;

    #region Constructors
    
    private LuminAction(MethodCache method)
    {
        _method = method.MethodBase ?? throw new ArgumentNullException(nameof(method));
        _isStatic = method.IsStatic;
        _methodPtr = method.MethodPtr;


        if (!_isStatic)
            throw new ArgumentException("methods are not static!", method.MethodBase.Name);

        _referenceTarget = null;
        _targetPointer = null;
    }
    
    private LuminAction(scoped ref TTarget? target, MethodCache method)
    {
        _method = method.MethodBase ?? throw new ArgumentNullException(nameof(method));
        _isStatic = method.IsStatic;
        _methodPtr = method.MethodPtr;
        _targetPointer = null;        
        if (!_isStatic)
        {
            if (IsValueType)
            {
#if NET8_0_OR_GREATER
                if (Unsafe.IsNullRef(ref target))
                    throw new ArgumentException("Target value instance cannot be null.", nameof(target));
#endif

#if NET8_0_OR_GREATER
                _targetPointer = NativeMemory.Alloc((nuint)Unsafe.SizeOf<TTarget>());
#else
                _targetPointer = Marshal.AllocHGlobal(Unsafe.SizeOf<TTarget>()).ToPointer();
#endif
                Unsafe.CopyBlock(
                    _targetPointer,
                    Unsafe.AsPointer(ref target),
                    (uint)Unsafe.SizeOf<TTarget>()
                );
            }
            else
            {
                // 引用类型：固定对象并获取指针
                if (target is null)
                    throw new ArgumentException("Target instance object is null.", nameof(target));
                
                _referenceTarget = Unsafe.As<TTarget, object?>(ref target);
                
            }
        }
        else
        {
            _referenceTarget = null;
        }
    }
    
    private LuminAction(Delegate @delegate)
    {
        _method = @delegate.Method ?? throw new ArgumentNullException(nameof(@delegate.Method));
        _isStatic = @delegate.Method.IsStatic;
        _methodPtr = @delegate.Method.MethodHandle.GetFunctionPointer();
        _targetPointer = null;

        var target = @delegate.Target;
        if (!_isStatic)
        {
            if (target is not TTarget)
                throw new ArgumentException("Target instance object is not type.", typeof(TTarget).Name);
                
            if (IsValueType)
            {
#if NET8_0_OR_GREATER
                if (Unsafe.IsNullRef(ref target))
                    throw new ArgumentException("Target value instance cannot be null.", nameof(target));
#endif
                // 从Delegate创建，不可能是refLike
                var unboxedTarget = Unsafe.AsRef<TTarget>(Unsafe.AsPointer(ref target));
                
#if NET8_0_OR_GREATER
                _targetPointer = NativeMemory.Alloc((nuint)Unsafe.SizeOf<TTarget>());
#else
                _targetPointer = Marshal.AllocHGlobal(Unsafe.SizeOf<TTarget>()).ToPointer();
#endif
                Unsafe.CopyBlock(
                    _targetPointer,
                    Unsafe.AsPointer(ref unboxedTarget),
                    (uint)Unsafe.SizeOf<TTarget>()
                );
            }
            else
            {
                // 引用类型：固定对象并获取指针
                if (target is null)
                    throw new ArgumentException("Target instance object is null.", nameof(target));
                
                _referenceTarget = target;
            }
        }
        else
        {
            _referenceTarget = null;
        }
    }

    #endregion
    
    #region Create Factory

    /// <summary>
    /// 创建Lumin委托
    /// </summary>
    /// <param name="target">委托绑定的实例</param>
    /// <param name="methodName">委托绑定的方法名</param>
    /// <param name="methodNameHash">方法名哈希值（可选）</param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> Create(scoped ref TTarget? target, string methodName, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        
        var method = GetCachedMethod(IsValueType
                ? TargetTypeHandle
                : Unsafe.As<TTarget, object?>(ref target!)?.GetType().TypeHandle ?? TargetTypeHandle,
            methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        return new LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(ref target, method);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> Create(scoped ref TTarget? target, string methodName, Type targetType, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(targetType.TypeHandle, methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        return new LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(ref target, method);
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> Create(scoped ref TTarget? target, ReadOnlySpan<char> methodName, int methodNameHash = 0) =>
        Create(ref target, methodName.ToString(), methodNameHash);
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> Create(scoped ref TTarget? target, ReadOnlySpan<char> methodName, Type targetType, int methodNameHash = 0) =>
        Create(ref target, methodName.ToString(), targetType, methodNameHash);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> Create(Delegate @delegate) => 
        new LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(@delegate);
    
    /// <summary>
    /// 创建绑定静态方法的Lumin委托
    /// </summary>
    /// <param name="methodName">委托绑定的方法名</param>
    /// <param name="methodNameHash">方法名哈希值（可选）</param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> Create(string methodName, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(TargetTypeHandle, methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        if (!method.IsStatic)
            throw new ArgumentException("Method is not static, please pass in instance as parameter.", nameof(methodName));
        
        return new LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(method);
    }

    #endregion
    
    #region Interface Implementation

    public void Dispose()
    {
        if (_disposed)
            return;
        
        if (IsValueType && !_isStatic && _targetPointer != null)
        {
#if NET8_0_OR_GREATER
            NativeMemory.Free(_targetPointer);
#else
            Marshal.FreeHGlobal(new IntPtr(_targetPointer));
#endif
        }
        
        _targetPointer = null;
        _referenceTarget = null;

        _disposed = true;
    }
    
    public object Clone()
    {
        ThrowIfDisposed();
        var target = _referenceTarget;
        if (target is null)
            throw new NullReferenceException("Target instance cannot be null.");
                
        return new LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(ref Unsafe.As<object?, TTarget>(ref target)!, new MethodCache(_isStatic, _methodPtr, _method));
    }

    public void GetObjectData(SerializationInfo info, StreamingContext context)
    {
        throw new NotSupportedException();
    }
    
    public override bool Equals(object? obj)
    {
        return obj is LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> other && Equals(other);
    }

    public bool Equals(LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> other)
    {
        ThrowIfDisposed();
        return _methodPtr == other._methodPtr &&
               _isStatic == other._isStatic &&
               _targetPointer == other._targetPointer;
    }

    public override int GetHashCode()
    {
        ThrowIfDisposed();
        unchecked
        {
            int hash = 17;
            hash = hash * 31 + _methodPtr.GetHashCode();
            hash = hash * 31 + _isStatic.GetHashCode();
            hash = hash * 31 + ((IntPtr)_targetPointer).GetHashCode();
            return hash;
        }
    }

    #endregion
    
    #region Implicit
    
    public static implicit operator LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(in Delegate action) 
        => Create(action);

    // Action 类型的隐式转换
    public static implicit operator LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(Action<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> action) => 
        Create(action);
    
    #endregion

    #region Invoke

    /// <summary>
    /// 使用反射动态调用方法
    /// 慎用，开销较大
    /// </summary>
    /// <param name="args">方法参数数组</param>
    /// <returns>方法返回值</returns>
    public object? DynamicInvoke(params object?[] args)
    {
        ThrowIfDisposed();
        
        if (_isStatic)
        {
            return _method.Invoke(null, args);
        }
        else
        {
            if (typeof(TTarget).IsByRefLike)
                throw new ArgumentException(
                    "The target type is a by-ref-like type and cannot be converted to a delegate.");

#if !NET9_0_OR_GREATER
            if (IsValueType)
                throw new ArgumentException("The target type is value type and cannot dynamic invoke.");
#endif

#if NET9_0_OR_GREATER
            object? instance = IsValueType
                ? RuntimeHelpers.Box(ref Unsafe.AsRef<byte>(_targetPointer), typeof(TTarget).TypeHandle)
                : _referenceTarget;
#else
            object? instance = _referenceTarget;
#endif

            if (instance is null)
                throw new InvalidOperationException("Target instance is null.");

            return _method.Invoke(instance, args);
        }
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14)
    {
        ThrowIfDisposed();
 
        if (!_isStatic && !IsValueType)
            ((delegate* managed<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, void>)_methodPtr)(Unsafe.As<object?, TTarget>(ref _referenceTarget), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14);
        else if (IsValueType)
            ((delegate* managed<ref TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, void>)_methodPtr)(ref Unsafe.AsRef<TTarget>(_targetPointer), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14);
        else
            ((delegate* managed<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, void>)_methodPtr)(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14);
    }

    #endregion
    
    #region Auxiliary methods
    
    public TDelegate ToDelegate<TDelegate>()
        where TDelegate : Delegate
    {
        ThrowIfDisposed();
        if (_isStatic)
        {
            return (TDelegate)Delegate.CreateDelegate(typeof(TDelegate), _method);
        }
        else
        {
            if (typeof(TTarget).IsByRefLike)
                throw new ArgumentException("The target type is a by-ref-like type and cannot be converted to a delegate.");
            
#if !NET9_0_OR_GREATER
            if (IsValueType)
                throw new ArgumentException("The target type is value type and cannot be converted to a delegate.");
#endif

#if NET9_0_OR_GREATER
            object? instance = IsValueType 
                ? RuntimeHelpers.Box(ref Unsafe.AsRef<byte>(_targetPointer), typeof(TTarget).TypeHandle)
                : _referenceTarget;
#else
            object? instance = _referenceTarget;
#endif
            
            if (instance is null)
                throw new InvalidOperationException("Target instance is null.");
            
            return (TDelegate)Delegate.CreateDelegate(typeof(TDelegate), instance, _method);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void ThrowIfDisposed()
    {
        if (_disposed)
            throw new ObjectDisposedException(nameof(LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>));
    }
    
    #endregion
    
    #region Static Type Hash

    private static readonly int TypeHash = ComputeTypeHash();
    private static readonly int TargetTypeHash = TargetTypeHandle.GetHashCode();
    private static readonly RuntimeTypeHandle TargetTypeHandle = typeof(TTarget).TypeHandle;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static int ComputeTypeHash()
    {
        unchecked
        {
            int h = (int)2166136261;
    
            h = (h * 16777619) ^ typeof(T1).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T2).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T3).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T4).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T5).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T6).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T7).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T8).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T9).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T10).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T11).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T12).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T13).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T14).TypeHandle.GetHashCode();
            return h;
        }
    }

    #endregion

    #region Method Caching

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static MethodCache GetCachedMethod(scoped in RuntimeTypeHandle type, string methodName, int nameHash = 0)
    {
        nameHash = nameHash is 0 ? StringComparer.Ordinal.GetHashCode(methodName) : nameHash;
        int key = type.Equals(TargetTypeHandle)
                      ? TypeHash ^ nameHash ^ TargetTypeHash
                      : TypeHash ^ nameHash ^ type.GetHashCode();

        if (!Methods.TryGetValue(key, out var result))
        {
            const BindingFlags flags = BindingFlags.Public | BindingFlags.NonPublic |
                                       BindingFlags.Instance | BindingFlags.Static;
    
            Type[] paramTypes = [ typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), typeof(T12), typeof(T13), typeof(T14) ];

#if NET8_0_OR_GREATER
            var method = Type.GetTypeFromHandle(type)!.GetMethod(methodName, flags, paramTypes)
                         ?? throw new MissingMethodException($"Method {methodName} not found on {Type.GetTypeFromHandle(type)!}");
#else
            var method = Type.GetTypeFromHandle(type)!.GetMethod(methodName, flags, null, paramTypes, null)
                         ?? throw new MissingMethodException($"Method {methodName} not found on {Type.GetTypeFromHandle(type)!}");
#endif
            result = new MethodCache(method.IsStatic, method.MethodHandle.GetFunctionPointer(), method);

            Methods.TryAdd(key, result);
        }

        return result;
    }
    
    #endregion
}

public unsafe struct LuminAction<
#if NET8_0_OR_GREATER
[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)]
#endif
TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> : IDisposable, ICloneable, ISerializable, IEquatable<LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>>
#if NET9_0_OR_GREATER
    where TTarget : allows ref struct
    where T1 : allows ref struct
    where T2 : allows ref struct
    where T3 : allows ref struct
    where T4 : allows ref struct
    where T5 : allows ref struct
    where T6 : allows ref struct
    where T7 : allows ref struct
    where T8 : allows ref struct
    where T9 : allows ref struct
    where T10 : allows ref struct
    where T11 : allows ref struct
    where T12 : allows ref struct
    where T13 : allows ref struct
    where T14 : allows ref struct
    where T15 : allows ref struct
#endif
{
    private void* _targetPointer; 
    private object? _referenceTarget; 
    private readonly IntPtr _methodPtr;
    private readonly bool _isStatic;
    private readonly MethodInfo _method; 
    private bool _disposed;

    private static readonly bool IsValueType = typeof(TTarget).IsValueType;
    
    public TTarget? Target
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            ThrowIfDisposed();
            
            if (_isStatic)
                return default;
            
            if (IsValueType)
                return Unsafe.AsRef<TTarget?>(_targetPointer);
            
            var target = _referenceTarget;
            return Unsafe.As<object?, TTarget?>(ref target);
        }
    }
    
    public MethodInfo Method => _method;

    #region Constructors
    
    private LuminAction(MethodCache method)
    {
        _method = method.MethodBase ?? throw new ArgumentNullException(nameof(method));
        _isStatic = method.IsStatic;
        _methodPtr = method.MethodPtr;


        if (!_isStatic)
            throw new ArgumentException("methods are not static!", method.MethodBase.Name);

        _referenceTarget = null;
        _targetPointer = null;
    }
    
    private LuminAction(scoped ref TTarget? target, MethodCache method)
    {
        _method = method.MethodBase ?? throw new ArgumentNullException(nameof(method));
        _isStatic = method.IsStatic;
        _methodPtr = method.MethodPtr;
        _targetPointer = null;        
        if (!_isStatic)
        {
            if (IsValueType)
            {
#if NET8_0_OR_GREATER
                if (Unsafe.IsNullRef(ref target))
                    throw new ArgumentException("Target value instance cannot be null.", nameof(target));
#endif

#if NET8_0_OR_GREATER
                _targetPointer = NativeMemory.Alloc((nuint)Unsafe.SizeOf<TTarget>());
#else
                _targetPointer = Marshal.AllocHGlobal(Unsafe.SizeOf<TTarget>()).ToPointer();
#endif
                Unsafe.CopyBlock(
                    _targetPointer,
                    Unsafe.AsPointer(ref target),
                    (uint)Unsafe.SizeOf<TTarget>()
                );
            }
            else
            {
                // 引用类型：固定对象并获取指针
                if (target is null)
                    throw new ArgumentException("Target instance object is null.", nameof(target));
                
                _referenceTarget = Unsafe.As<TTarget, object?>(ref target);
                
            }
        }
        else
        {
            _referenceTarget = null;
        }
    }
    
    private LuminAction(Delegate @delegate)
    {
        _method = @delegate.Method ?? throw new ArgumentNullException(nameof(@delegate.Method));
        _isStatic = @delegate.Method.IsStatic;
        _methodPtr = @delegate.Method.MethodHandle.GetFunctionPointer();
        _targetPointer = null;

        var target = @delegate.Target;
        if (!_isStatic)
        {
            if (target is not TTarget)
                throw new ArgumentException("Target instance object is not type.", typeof(TTarget).Name);
                
            if (IsValueType)
            {
#if NET8_0_OR_GREATER
                if (Unsafe.IsNullRef(ref target))
                    throw new ArgumentException("Target value instance cannot be null.", nameof(target));
#endif
                // 从Delegate创建，不可能是refLike
                var unboxedTarget = Unsafe.AsRef<TTarget>(Unsafe.AsPointer(ref target));
                
#if NET8_0_OR_GREATER
                _targetPointer = NativeMemory.Alloc((nuint)Unsafe.SizeOf<TTarget>());
#else
                _targetPointer = Marshal.AllocHGlobal(Unsafe.SizeOf<TTarget>()).ToPointer();
#endif
                Unsafe.CopyBlock(
                    _targetPointer,
                    Unsafe.AsPointer(ref unboxedTarget),
                    (uint)Unsafe.SizeOf<TTarget>()
                );
            }
            else
            {
                // 引用类型：固定对象并获取指针
                if (target is null)
                    throw new ArgumentException("Target instance object is null.", nameof(target));
                
                _referenceTarget = target;
            }
        }
        else
        {
            _referenceTarget = null;
        }
    }

    #endregion
    
    #region Create Factory

    /// <summary>
    /// 创建Lumin委托
    /// </summary>
    /// <param name="target">委托绑定的实例</param>
    /// <param name="methodName">委托绑定的方法名</param>
    /// <param name="methodNameHash">方法名哈希值（可选）</param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> Create(scoped ref TTarget? target, string methodName, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        
        var method = GetCachedMethod(IsValueType
                ? TargetTypeHandle
                : Unsafe.As<TTarget, object?>(ref target!)?.GetType().TypeHandle ?? TargetTypeHandle,
            methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        return new LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(ref target, method);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> Create(scoped ref TTarget? target, string methodName, Type targetType, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(targetType.TypeHandle, methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        return new LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(ref target, method);
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> Create(scoped ref TTarget? target, ReadOnlySpan<char> methodName, int methodNameHash = 0) =>
        Create(ref target, methodName.ToString(), methodNameHash);
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> Create(scoped ref TTarget? target, ReadOnlySpan<char> methodName, Type targetType, int methodNameHash = 0) =>
        Create(ref target, methodName.ToString(), targetType, methodNameHash);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> Create(Delegate @delegate) => 
        new LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(@delegate);
    
    /// <summary>
    /// 创建绑定静态方法的Lumin委托
    /// </summary>
    /// <param name="methodName">委托绑定的方法名</param>
    /// <param name="methodNameHash">方法名哈希值（可选）</param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> Create(string methodName, int methodNameHash = 0)
    {
        if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("Method name cannot be null or empty.", nameof(methodName));
        
        var method = GetCachedMethod(TargetTypeHandle, methodName, methodNameHash);
        
        if (method.MethodBase is null)
            throw new ArgumentException("Method does not exist.", nameof(methodName));
        
        if (!method.IsStatic)
            throw new ArgumentException("Method is not static, please pass in instance as parameter.", nameof(methodName));
        
        return new LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(method);
    }

    #endregion
    
    #region Interface Implementation

    public void Dispose()
    {
        if (_disposed)
            return;
        
        if (IsValueType && !_isStatic && _targetPointer != null)
        {
#if NET8_0_OR_GREATER
            NativeMemory.Free(_targetPointer);
#else
            Marshal.FreeHGlobal(new IntPtr(_targetPointer));
#endif
        }
        
        _targetPointer = null;
        _referenceTarget = null;

        _disposed = true;
    }
    
    public object Clone()
    {
        ThrowIfDisposed();
        var target = _referenceTarget;
        if (target is null)
            throw new NullReferenceException("Target instance cannot be null.");
                
        return new LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(ref Unsafe.As<object?, TTarget>(ref target)!, new MethodCache(_isStatic, _methodPtr, _method));
    }

    public void GetObjectData(SerializationInfo info, StreamingContext context)
    {
        throw new NotSupportedException();
    }
    
    public override bool Equals(object? obj)
    {
        return obj is LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> other && Equals(other);
    }

    public bool Equals(LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> other)
    {
        ThrowIfDisposed();
        return _methodPtr == other._methodPtr &&
               _isStatic == other._isStatic &&
               _targetPointer == other._targetPointer;
    }

    public override int GetHashCode()
    {
        ThrowIfDisposed();
        unchecked
        {
            int hash = 17;
            hash = hash * 31 + _methodPtr.GetHashCode();
            hash = hash * 31 + _isStatic.GetHashCode();
            hash = hash * 31 + ((IntPtr)_targetPointer).GetHashCode();
            return hash;
        }
    }

    #endregion
    
    #region Implicit
    
    public static implicit operator LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(in Delegate action) 
        => Create(action);

    // Action 类型的隐式转换
    public static implicit operator LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(Action<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> action) => 
        Create(action);
    
    #endregion

    #region Invoke

    /// <summary>
    /// 使用反射动态调用方法
    /// 慎用，开销较大
    /// </summary>
    /// <param name="args">方法参数数组</param>
    /// <returns>方法返回值</returns>
    public object? DynamicInvoke(params object?[] args)
    {
        ThrowIfDisposed();
        
        if (_isStatic)
        {
            return _method.Invoke(null, args);
        }
        else
        {
            if (typeof(TTarget).IsByRefLike)
                throw new ArgumentException(
                    "The target type is a by-ref-like type and cannot be converted to a delegate.");

#if !NET9_0_OR_GREATER
            if (IsValueType)
                throw new ArgumentException("The target type is value type and cannot dynamic invoke.");
#endif

#if NET9_0_OR_GREATER
            object? instance = IsValueType
                ? RuntimeHelpers.Box(ref Unsafe.AsRef<byte>(_targetPointer), typeof(TTarget).TypeHandle)
                : _referenceTarget;
#else
            object? instance = _referenceTarget;
#endif

            if (instance is null)
                throw new InvalidOperationException("Target instance is null.");

            return _method.Invoke(instance, args);
        }
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15)
    {
        ThrowIfDisposed();
 
        if (!_isStatic && !IsValueType)
            ((delegate* managed<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, void>)_methodPtr)(Unsafe.As<object?, TTarget>(ref _referenceTarget), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15);
        else if (IsValueType)
            ((delegate* managed<ref TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, void>)_methodPtr)(ref Unsafe.AsRef<TTarget>(_targetPointer), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15);
        else
            ((delegate* managed<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, void>)_methodPtr)(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15);
    }

    #endregion
    
    #region Auxiliary methods
    
    public TDelegate ToDelegate<TDelegate>()
        where TDelegate : Delegate
    {
        ThrowIfDisposed();
        if (_isStatic)
        {
            return (TDelegate)Delegate.CreateDelegate(typeof(TDelegate), _method);
        }
        else
        {
            if (typeof(TTarget).IsByRefLike)
                throw new ArgumentException("The target type is a by-ref-like type and cannot be converted to a delegate.");
            
#if !NET9_0_OR_GREATER
            if (IsValueType)
                throw new ArgumentException("The target type is value type and cannot be converted to a delegate.");
#endif

#if NET9_0_OR_GREATER
            object? instance = IsValueType 
                ? RuntimeHelpers.Box(ref Unsafe.AsRef<byte>(_targetPointer), typeof(TTarget).TypeHandle)
                : _referenceTarget;
#else
            object? instance = _referenceTarget;
#endif
            
            if (instance is null)
                throw new InvalidOperationException("Target instance is null.");
            
            return (TDelegate)Delegate.CreateDelegate(typeof(TDelegate), instance, _method);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void ThrowIfDisposed()
    {
        if (_disposed)
            throw new ObjectDisposedException(nameof(LuminAction<TTarget, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>));
    }
    
    #endregion
    
    #region Static Type Hash

    private static readonly int TypeHash = ComputeTypeHash();
    private static readonly int TargetTypeHash = TargetTypeHandle.GetHashCode();
    private static readonly RuntimeTypeHandle TargetTypeHandle = typeof(TTarget).TypeHandle;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static int ComputeTypeHash()
    {
        unchecked
        {
            int h = (int)2166136261;
    
            h = (h * 16777619) ^ typeof(T1).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T2).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T3).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T4).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T5).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T6).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T7).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T8).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T9).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T10).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T11).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T12).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T13).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T14).TypeHandle.GetHashCode();
            h = (h * 16777619) ^ typeof(T15).TypeHandle.GetHashCode();
            return h;
        }
    }

    #endregion

    #region Method Caching

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static MethodCache GetCachedMethod(scoped in RuntimeTypeHandle type, string methodName, int nameHash = 0)
    {
        nameHash = nameHash is 0 ? StringComparer.Ordinal.GetHashCode(methodName) : nameHash;
        int key = type.Equals(TargetTypeHandle)
                      ? TypeHash ^ nameHash ^ TargetTypeHash
                      : TypeHash ^ nameHash ^ type.GetHashCode();

        if (!Methods.TryGetValue(key, out var result))
        {
            const BindingFlags flags = BindingFlags.Public | BindingFlags.NonPublic |
                                       BindingFlags.Instance | BindingFlags.Static;
    
            Type[] paramTypes = [ typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), typeof(T12), typeof(T13), typeof(T14), typeof(T15) ];

#if NET8_0_OR_GREATER
            var method = Type.GetTypeFromHandle(type)!.GetMethod(methodName, flags, paramTypes)
                         ?? throw new MissingMethodException($"Method {methodName} not found on {Type.GetTypeFromHandle(type)!}");
#else
            var method = Type.GetTypeFromHandle(type)!.GetMethod(methodName, flags, null, paramTypes, null)
                         ?? throw new MissingMethodException($"Method {methodName} not found on {Type.GetTypeFromHandle(type)!}");
#endif
            result = new MethodCache(method.IsStatic, method.MethodHandle.GetFunctionPointer(), method);

            Methods.TryAdd(key, result);
        }

        return result;
    }
    
    #endregion
}
